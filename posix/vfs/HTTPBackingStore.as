// Copyright (c) 2013 Adobe Systems Inc

// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:

// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.

// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

package com.adobe.flascc.vfs
{
	import flash.display.Loader;
	import flash.events.AsyncErrorEvent;
	import flash.events.Event;
	import flash.events.EventDispatcher;
	import flash.events.IOErrorEvent;
	import flash.events.ProgressEvent;
	import flash.events.SecurityErrorEvent;
	import flash.net.URLLoader;
	import flash.net.URLLoaderDataFormat;
	import flash.net.URLRequest;
	import flash.utils.ByteArray;
	import flash.utils.Endian;

	/**
	* A BackingStore that uses a URLLoader to load its files. This requires a manifest.as file to be
	* generated by the "genfs" tool in the flascc SDK. After being constructed, an instance of this
	* BackingStore will start downloading the files from the manifest. You can listen to the <code>progress</code>,
	* <code>complete</code> and <code>ioerror</code> events to monitor download progress.
	*
	* <p>After a download has completed it is added to the VFS and is available for use.</p>
	*/
	public class HTTPBackingStore extends InMemoryBackingStore
	{
        // The genfs program generates an as file that
        // defines some of the data needed by this script
        include 'manifest.as'
		
        private var bytesLoaded:uint
		private var percentComplete:uint
		private var currentLoader:URLLoader
		private var currentVPath:String
		private var currentUrls:Array = []
		private var currentContents:ByteArray

		public function HTTPBackingStore()
		{
            initDirs()
			startNewFile()
		}

		private function startNewFile():void
		{
			if(currentVPath == null)
			{
				var newfile:Array = vfsFiles.shift()
				if(newfile == null)
				{
					// All files finished
			        this.dispatchEvent(new Event(Event.COMPLETE))
					return
				}

				currentVPath = newfile[0]
				currentContents = new ByteArray()
				currentContents.endian = Endian.LITTLE_ENDIAN
				currentContents.length = newfile[1]
				currentContents.position = 0
				currentUrls.length = 0
				for(var i:int=2;i<newfile.length; i++)
					currentUrls.push(newfile[i])
			}

			startNewDownload()
		}

		private function startNewDownload():void
		{
			var url:String = currentUrls.shift()
			if(url == null) {
				// we're done with this file, put it in the VFS
				//currentContents.uncompress()
                addFile(currentVPath, currentContents);
				
				// start a new file download
				currentVPath = null
				startNewFile()
				return
			}

			currentLoader = new URLLoader(new URLRequest(url));
			currentLoader.dataFormat= URLLoaderDataFormat.BINARY;
        	currentLoader.addEventListener(AsyncErrorEvent.ASYNC_ERROR, onError)
        	currentLoader.addEventListener(SecurityErrorEvent.SECURITY_ERROR, onError)
        	currentLoader.addEventListener(IOErrorEvent.IO_ERROR, onError)
        	currentLoader.addEventListener(Event.COMPLETE, onComplete)
        	currentLoader.addEventListener(ProgressEvent.PROGRESS, onProgress)
		}

        private function onComplete(e:Event):void
        {
        	bytesLoaded += currentLoader.data.length
        	currentContents.writeBytes(currentLoader.data)

        	var pe:ProgressEvent = new ProgressEvent(ProgressEvent.PROGRESS)
        	pe.bytesLoaded = bytesLoaded
        	pe.bytesTotal = vfsTotalSize
            this.dispatchEvent(pe)
            
            startNewDownload()
        }

        private function onError(e:Event):void
        {
            this.dispatchEvent(e)
        }

      	private function onProgress(e:Event):void
        {
        	var pe:ProgressEvent = new ProgressEvent(ProgressEvent.PROGRESS)
        	pe.bytesLoaded = bytesLoaded + e.target.bytesLoaded
        	pe.bytesTotal = vfsTotalSize
            this.dispatchEvent(pe)
        }  
	} 
}