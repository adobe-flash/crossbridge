/* translation of file "util.k" */
/* generated by:
 *  @(#)$Author: criswell $
 */
#ifndef KC_FUNCTIONS_util_HEADER
#define KC_FUNCTIONS_util_HEADER
#include "k.h"    /* in case a user forgets */

namespace kc { }
using namespace kc;
/* included stuff */
//
// The Termprocessor Kimwitu++
//
// Copyright (C) 1991 University of Twente, Dept TIOS.
// Copyright (C) 1998-2003 Humboldt-University of Berlin, Institute of Informatics
// All rights reserved.
//
// Kimwitu++ is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation; either version 2 of the License, or
// (at your option) any later version.
//
// Kimwitu++ is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with Kimwitu++; if not, write to the Free Software
// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
//

/* end included stuff */


namespace kc {
bool f_added (ID id);
void v_add (ID id);
void v_freeadded ();
int f_getcount (ID id);
void v_resetcount ();
void v_freecount ();
bool is_uview_var (ID id);
bool f_DvIsDisallowed (dollarvarstatus dvs);
ID f_listelementphylum (ID id);
ID f_listelementconsoperator (ID id);
ID f_emptyId ();
bool f_operatorinphylum (ID oid, ID pid);
bool f_isphylum (ID id);
phylumdeclaration f_phylumdeclofid (ID id);
bool f_ispredefinedphylum (ID id);
alternative f_alternativeofoperator (ID oid);
arguments f_argumentsofoperator (ID oid);
ID f_phylumofoperator (ID oid);
ID f_phylumofpatternID (ID vid);
ID f_phylumofpatternvariable (ID vid);
void v_syn_type_attribute_ID (ID id);
bool f_Nilarguments (arguments a);
ID f_hd_arguments (arguments a);
arguments f_tl_arguments (arguments a);
void v_check_dollarvar_attribute_in_operators (INT i, unpattributes a, operators o);
ID f_check_unpattributes_in_phylum (unpattributes a, ID p);
bool f_attribute_in_phylym (ID a, ID p);
ID f_typeof_attribute_in_phylym (ID a, ID p);
ID f_subphylumofoperator (ID o, INT i);
ID f_subphylum (arguments a, INT i);
argument f_argumentofoperator (ID o, INT i);
argument f_argument (arguments a, INT i);
ID f_phylumofoutmostpattern (outmostpattern p);
ID f_operatorofphylum (ID p, int i);
alternative f_alternative (alternatives a, int i);
void v_reset_phylumdeclaration_marks ();
void v_reset_variables_type (variables v);
void v_add_to_uviewnames (ID v);
void v_add_to_uviewnames_ext (ID v);
void v_add_to_rviewnames (ID v);
void v_add_to_rviewnames_ext (ID v);
void v_add_to_storageclasses (ID v, ID p);
void collect_strings ();
void add_string_to_collection (unparseitem s);
void unparse_string_collection ();
phylumnames f_phylumnames_foreachwith_vars (idCexpressions a_idCexpressions);
phylumnames t_f_phylumnames_foreachwith_vars (idCexpressions a_idCexpressions);
phylumnames f_phylumnames_foreachwith_listvars (idCexpressions a_idCexpressions);
phylumnames t_f_phylumnames_foreachwith_listvars (idCexpressions a_idCexpressions);
void f_collect_members (fndeclarations fns);
ID f_id_of_ctor_dtor_decl (ac_declarator decl);
void prepare_base_classes (baseclass_declarations decls);

} // namespace kc

#endif // !  KC_FUNCTIONS_util_HEADER

