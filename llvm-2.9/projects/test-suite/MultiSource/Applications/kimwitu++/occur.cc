/* translation of file "occur.k" */
/* generated by:
 *  @(#)$Author: criswell $
 */
#define KC_FUNCTIONS_occur_

#include <stdlib.h>
#include "k.h"
#include "occur.h"
namespace kc { }
using namespace kc;
/* included stuff */
//
// The Termprocessor Kimwitu++
//
// Copyright (C) 1991 University of Twente, Dept TIOS.
// Copyright (C) 1998-2003 Humboldt-University of Berlin, Institute of Informatics
// All rights reserved.
//
// Kimwitu++ is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation; either version 2 of the License, or
// (at your option) any later version.
//
// Kimwitu++ is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with Kimwitu++; if not, write to the Free Software
// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
//

static char occur_kAccesSid[] = "@(#)$Id: occur.cc 12720 2004-04-06 20:25:22Z criswell $";

inline static void
NF(ID id, problem prob)
{
    v_report(NonFatal( FileLine( id->file, id->line ), prob));
}

/* end included stuff */


namespace kc {

#ifndef KC_TRACE_PROVIDED
#define KC_TRACE_PROVIDED(COND,FILE,LINE,NODE) COND
#endif

static  void do_v_extendoccur (ID id, IDtype it, bool warn);
static  bool occurlanguagename (ID id);
void v_defoccur(ID id, IDtype it)
{
    uniqID uid;
    {
	ID kc_selvar_0_1 = phylum_cast<ID>( id );
	if ((kc_selvar_0_1->prod_sel() == sel_Id)) {
	    const uniqID _uid = phylum_cast<const impl_ID_Id*>(kc_selvar_0_1)->uniqID_1;
	    uid = _uid; 
	    	} else
	    kc_no_default_in_with( "v_defoccur", __LINE__, __FILE__ );
    }
    id->type = it;

    {
	IDtype kc_selvar_0_1 = phylum_cast<IDtype>( id->type);
	IDtype kc_selvar_0_2 = phylum_cast<IDtype>( uid->type );
	if ((kc_selvar_0_1->prod_sel() == sel_ITUnknown)) {
	    return; 
	    	} else
	    if ((kc_selvar_0_2->prod_sel() == sel_ITUnknown)) {
	    uid->type = it; uid->line = id->line; uid->file = id->file; return; 
	    	} else
	{

	}
    }

    {
	IDtype kc_selvar_0_1 = phylum_cast<IDtype>( id->type);
	IDtype kc_selvar_0_2 = phylum_cast<IDtype>( uid->type );
	if ((kc_selvar_0_1->prod_sel() == sel_ITUserFunction) && (kc_selvar_0_2->prod_sel() == sel_ITUserFunction) && (phylum_cast<const impl_IDtype_ITUserFunction*>(kc_selvar_0_2)->fnclass_1->prod_sel() == sel_DestructorFn)) {

	} else
	    if ((kc_selvar_0_1->prod_sel() == sel_ITUserFunction) && (kc_selvar_0_2->prod_sel() == sel_ITUserFunction) && (phylum_cast<const impl_IDtype_ITUserFunction*>(kc_selvar_0_2)->fnclass_1->prod_sel() == sel_ConstructorFn)) {

	} else
	    if ((kc_selvar_0_1->prod_sel() == sel_ITUserFunction) && (kc_selvar_0_2->prod_sel() == sel_ITUserFunction) && (phylum_cast<const impl_IDtype_ITUserFunction*>(kc_selvar_0_2)->fnclass_1->prod_sel() == sel_MemberFn)) {

	} else
	    if ((kc_selvar_0_1->prod_sel() == sel_ITUserFunction) && (kc_selvar_0_2->prod_sel() == sel_ITUserFunction) && (phylum_cast<const impl_IDtype_ITUserFunction*>(kc_selvar_0_2)->fnclass_1->prod_sel() == sel_StaticFn)) {
	    const fnclass it_fnc = phylum_cast<const impl_IDtype_ITUserFunction*>(kc_selvar_0_1)->fnclass_1;

	    {
		fnclass kc_selvar_1_1 = phylum_cast<fnclass>( it_fnc );
		if ((kc_selvar_1_1->prod_sel() == sel_StaticFn)) {

		    if (uid->file->eq(id->file ))
		    NF(id, Problem1S1ID( "illegal redefinition of local function:", id ));

		} else
		    if ((kc_selvar_1_1->prod_sel() == sel_GlobalFn)) {
		    NF(id, Problem1S1ID( "illegal redefinition of local function:", id )); 
		    	} else
		    kc_no_default_in_with( "v_defoccur", __LINE__, __FILE__ );
	    }

	} else
	    if ((kc_selvar_0_1->prod_sel() == sel_ITUserFunction) && (kc_selvar_0_2->prod_sel() == sel_ITUserFunction) && (phylum_cast<const impl_IDtype_ITUserFunction*>(kc_selvar_0_2)->fnclass_1->prod_sel() == sel_GlobalFn)) {
	    const fnclass it_fnc = phylum_cast<const impl_IDtype_ITUserFunction*>(kc_selvar_0_1)->fnclass_1;





	} else
	    if ((kc_selvar_0_1->prod_sel() == sel_ITPatternVariable) && (kc_selvar_0_2->prod_sel() == sel_ITPatternVariable)) {
	    const integer i_s = phylum_cast<const impl_IDtype_ITPatternVariable*>(kc_selvar_0_1)->integer_1;
	    const integer id_s = phylum_cast<const impl_IDtype_ITPatternVariable*>(kc_selvar_0_2)->integer_1;

	    if (i_s == id_s)
	    NF(id, Problem1S1ID( "illegal redefinition of pattern variable:", id )); 
	    	} else
	    if ((kc_selvar_0_1->prod_sel() == sel_ITUserRView) && (kc_selvar_0_2->prod_sel() == sel_ITUserRView)) {

	    NF(id, Problem1S1ID( "illegal redefinition of rewrite view:", id )); 
	    	} else
	    if ((kc_selvar_0_1->prod_sel() == sel_ITUserRView) && (kc_selvar_0_2->prod_sel() == sel_ITPredefinedRView)) {

	    NF(id, Problem1S1ID( "illegal redefinition of predefined rewrite view:", id )); 
	    	} else
	    if ((kc_selvar_0_1->prod_sel() == sel_ITPredefinedRView) && (kc_selvar_0_2->prod_sel() == sel_ITUserRView)) {

	    NF(id, Problem1S1ID( "illegal predefinition of rewrite view:", id )); 
	    	} else
	    if ((kc_selvar_0_1->prod_sel() == sel_ITPredefinedRView) && (kc_selvar_0_2->prod_sel() == sel_ITPredefinedRView)) {

	    NF(id, Problem1S1ID( "illegal predefinition of predefined rewrite view:", id )); 
	    	} else
	    if ((kc_selvar_0_1->prod_sel() == sel_ITUserUView) && (kc_selvar_0_2->prod_sel() == sel_ITUserUView)) {

	    NF(id, Problem1S1ID( "illegal redefinition of unparse view:", id )); 
	    	} else
	    if ((kc_selvar_0_1->prod_sel() == sel_ITUserUView) && (kc_selvar_0_2->prod_sel() == sel_ITPredefinedUView)) {

	    NF(id, Problem1S1ID( "illegal redefinition of predefined unparse view:", id )); 
	    	} else
	    if ((kc_selvar_0_1->prod_sel() == sel_ITPredefinedUView) && (kc_selvar_0_2->prod_sel() == sel_ITUserUView)) {

	    NF(id, Problem1S1ID( "illegal predefinition of unparse view:", id )); 
	    	} else
	    if ((kc_selvar_0_1->prod_sel() == sel_ITPredefinedUView) && (kc_selvar_0_2->prod_sel() == sel_ITPredefinedUView)) {

	    NF(id, Problem1S1ID( "illegal predefinition of predefined unparse view:", id )); 
	    	} else
	    if ((kc_selvar_0_1->prod_sel() == sel_ITStorageClass) && (kc_selvar_0_2->prod_sel() == sel_ITStorageClass)) {

	    NF(id, Problem1S1ID( "illegal redefinition of storage class:", id )); 
	    	} else
	    if ((kc_selvar_0_1->prod_sel() == sel_ITStorageClass) && (kc_selvar_0_2->prod_sel() == sel_ITPredefinedStorageClass)) {

	    NF(id, Problem1S1ID( "illegal redefinition of predefined storage class:", id )); 
	    	} else
	    if ((kc_selvar_0_1->prod_sel() == sel_ITPredefinedStorageClass) && (kc_selvar_0_2->prod_sel() == sel_ITStorageClass)) {

	    NF(id, Problem1S1ID( "illegal predefinition of storage class:", id )); 
	    	} else
	    if ((kc_selvar_0_1->prod_sel() == sel_ITPredefinedStorageClass) && (kc_selvar_0_2->prod_sel() == sel_ITPredefinedStorageClass)) {

	    NF(id, Problem1S1ID( "illegal predefinition of predefined storage class:", id )); 
	    	} else
	    if ((kc_selvar_0_1->prod_sel() == sel_ITUserOperator) && (kc_selvar_0_2->prod_sel() == sel_ITUserOperator)) {

	    NF(id, Problem1S1ID( "illegal redefinition of operator:", id )); 
	    	} else
	    if ((kc_selvar_0_1->prod_sel() == sel_ITUserOperator) && (kc_selvar_0_2->prod_sel() == sel_ITPredefinedOperator)) {

	    NF(id, Problem1S1ID( "illegal redefinition of predefined operator:", id )); 
	    	} else
	    if ((kc_selvar_0_1->prod_sel() == sel_ITPredefinedOperator) && (kc_selvar_0_2->prod_sel() == sel_ITUserOperator)) {

	    NF(id, Problem1S1ID( "illegal predefinition of operator:", id )); 
	    	} else
	    if ((kc_selvar_0_1->prod_sel() == sel_ITPredefinedOperator) && (kc_selvar_0_2->prod_sel() == sel_ITPredefinedOperator)) {

	    NF(id, Problem1S1ID( "illegal predefinition of predefined operator:", id )); 
	    	} else
	    if ((kc_selvar_0_1->prod_sel() == sel_ITUserPhylum) && (kc_selvar_0_2->prod_sel() == sel_ITUserPhylum)) {

	    NF(id, Problem1S1ID( "illegal redefinition of phylum:", id )); 
	    	} else
	    if ((kc_selvar_0_1->prod_sel() == sel_ITUserPhylum) && (kc_selvar_0_2->prod_sel() == sel_ITPredefinedPhylum)) {

	    NF(id, Problem1S1ID( "illegal redefinition of predefined phylum:", id )); 
	    	} else
	    if ((kc_selvar_0_1->prod_sel() == sel_ITPredefinedPhylum) && (kc_selvar_0_2->prod_sel() == sel_ITUserPhylum)) {

	    NF(id, Problem1S1ID( "illegal predefinition of phylum:", id )); 
	    	} else
	    if ((kc_selvar_0_1->prod_sel() == sel_ITPredefinedPhylum) && (kc_selvar_0_2->prod_sel() == sel_ITPredefinedPhylum)) {

	    NF(id, Problem1S1ID( "illegal predefinition of predefined phylum:", id )); 
	    	} else
	    if ((kc_selvar_0_1->prod_sel() == sel_ITPatternVariable)) {
	    const integer i_s = phylum_cast<const impl_IDtype_ITPatternVariable*>(kc_selvar_0_1)->integer_1;

	    NF(id, Problem1S1t1S1ID( "illegal redefinition of ", uid->type, "as pattern variable", id )); 
	    	} else
	    if ((kc_selvar_0_1->prod_sel() == sel_ITUserRView)) {

	    NF(id, Problem1S1t1S1ID( "illegal redefinition of ", uid->type, "as rewrite view", id )); 
	    	} else
	    if ((kc_selvar_0_1->prod_sel() == sel_ITPredefinedRView)) {

	    NF(id, Problem1S1t1S1ID( "illegal predefinition of ", uid->type, "as rewrite view", id )); 
	    	} else
	    if ((kc_selvar_0_1->prod_sel() == sel_ITUserUView)) {

	    NF(id, Problem1S1t1S1ID( "illegal redefinition of ", uid->type, "as unparse view", id )); 
	    	} else
	    if ((kc_selvar_0_1->prod_sel() == sel_ITPredefinedUView)) {

	    NF(id, Problem1S1t1S1ID( "illegal predefinition of ", uid->type, "as unparse view", id )); 
	    	} else
	    if ((kc_selvar_0_1->prod_sel() == sel_ITUserFunction)) {

	    NF(id, Problem1S1t1S1ID( "illegal redefinition of ", uid->type, "as function", id )); 
	    	} else
	    if ((kc_selvar_0_1->prod_sel() == sel_ITStorageClass)) {

	    NF(id, Problem1S1t1S1ID( "illegal redefinition of ", uid->type, "as storage class", id )); 
	    	} else
	    if ((kc_selvar_0_1->prod_sel() == sel_ITPredefinedStorageClass)) {

	    NF(id, Problem1S1t1S1ID( "illegal predefinition of ", uid->type, "as storage class:", id )); 
	    	} else
	    if ((kc_selvar_0_1->prod_sel() == sel_ITUserOperator)) {

	    NF(id, Problem1S1t1S1ID( "illegal redefinition of ", uid->type, "as operator:", id )); 
	    	} else
	    if ((kc_selvar_0_1->prod_sel() == sel_ITPredefinedOperator)) {

	    NF(id, Problem1S1t1S1ID( "illegal predefinition of ", uid->type, "as operator:", id )); 
	    	} else
	    if ((kc_selvar_0_1->prod_sel() == sel_ITUserPhylum)) {

	    NF(id, Problem1S1t1S1ID( "illegal redefinition of ", uid->type, "as phylum:", id )); 
	    	} else
	    if ((kc_selvar_0_1->prod_sel() == sel_ITPredefinedPhylum)) {

	    NF(id, Problem1S1t1S1ID( "illegal predefinition of ", uid->type, "as phylum:", id )); 
	    	} else
	    kc_no_default_in_with( "v_defoccur", __LINE__, __FILE__ );
    }

}

void v_extendoccur(ID id, IDtype it)
{ do_v_extendoccur( id, it, true); 
}

void v_extendoccur_nowarning(ID id, IDtype it)
{ do_v_extendoccur( id, it, false); 
}

static  void do_v_extendoccur(ID id, IDtype it, bool warn)
{
    uniqID uid;
    {
	ID kc_selvar_0_1 = phylum_cast<ID>( id );
	if ((kc_selvar_0_1->prod_sel() == sel_Id)) {
	    const uniqID _uid = phylum_cast<const impl_ID_Id*>(kc_selvar_0_1)->uniqID_1;
	    uid = _uid; 
	    	} else
	    kc_no_default_in_with( "do_v_extendoccur", __LINE__, __FILE__ );
    }
    id->type = it;

    {
	IDtype kc_selvar_0_1 = phylum_cast<IDtype>( id->type);
	IDtype kc_selvar_0_2 = phylum_cast<IDtype>( uid->type );
	if ((kc_selvar_0_1->prod_sel() == sel_ITUnknown)) {
	    return; 
	    	} else
	    if ((kc_selvar_0_2->prod_sel() == sel_ITUnknown)) {
	    uid->type = it; uid->line = id->line; uid->file = id->file; return; 
	    	} else
	{

	}
    }

    {
	IDtype kc_selvar_0_1 = phylum_cast<IDtype>( id->type);
	IDtype kc_selvar_0_2 = phylum_cast<IDtype>( uid->type );
	if ((kc_selvar_0_1->prod_sel() == sel_ITPatternVariable) && (kc_selvar_0_2->prod_sel() == sel_ITPatternVariable)) {
	    const ID id_id = phylum_cast<const impl_IDtype_ITPatternVariable*>(kc_selvar_0_1)->ID_1;
	    const integer id_scope = phylum_cast<const impl_IDtype_ITPatternVariable*>(kc_selvar_0_1)->integer_1;
	    const ID uid_id = phylum_cast<const impl_IDtype_ITPatternVariable*>(kc_selvar_0_2)->ID_1;
	    const integer uid_scope = phylum_cast<const impl_IDtype_ITPatternVariable*>(kc_selvar_0_2)->integer_1;

	    if (id_scope == uid_scope) {
		if (! id_id->eq( uid_id )) {
		    NF(id, Problem1S1ID1S1ID1S1ID( "type mismatch in redefinition of pattern variable:", id, "old type", uid_id, "new type", id_id ));
		}
	    } else {
		uid->scopeinfo = Consscopetypefilelinestack( ScopeTypeFileLine(id_scope, uid->type, uid->file, mkinteger(uid->line)), uid->scopeinfo );
		uid->type = it;
		uid->line = id->line;
		uid->file = id->file;
	    }   
	    	} else
	    if ((kc_selvar_0_1->prod_sel() == sel_ITUserRView) && (kc_selvar_0_2->prod_sel() == sel_ITUserRView)) {

	    if (warn) NF(id, Problem1S1ID( "superfluous redeclaration of rewrite view:", id )); 
	    	} else
	    if ((kc_selvar_0_1->prod_sel() == sel_ITUserRView) && (kc_selvar_0_2->prod_sel() == sel_ITPredefinedRView)) {

	    if (warn) NF(id, Problem1S1ID( "superfluous redeclaration of predefined rewrite view:", id )); 
	    	} else
	    if ((kc_selvar_0_1->prod_sel() == sel_ITPredefinedRView) && (kc_selvar_0_2->prod_sel() == sel_ITUserRView)) {

	    NF(id, Problem1S1ID( "illegal extension of rewrite view:", id )); 
	    	} else
	    if ((kc_selvar_0_1->prod_sel() == sel_ITPredefinedRView) && (kc_selvar_0_2->prod_sel() == sel_ITPredefinedRView)) {

	    NF(id, Problem1S1ID( "illegal extension of predefined rewrite view:", id )); 
	    	} else
	    if ((kc_selvar_0_1->prod_sel() == sel_ITUserUView) && (kc_selvar_0_2->prod_sel() == sel_ITUserUView)) {

	    if (warn) NF(id, Problem1S1ID( "superfluous redeclaration of unparse view:", id )); 
	    	} else
	    if ((kc_selvar_0_1->prod_sel() == sel_ITUserUView) && (kc_selvar_0_2->prod_sel() == sel_ITPredefinedUView)) {

	    if (warn) NF(id, Problem1S1ID( "superfluous redeclaration of predefined unparse view:", id )); 
	    	} else
	    if ((kc_selvar_0_1->prod_sel() == sel_ITPredefinedUView) && (kc_selvar_0_2->prod_sel() == sel_ITUserUView)) {

	    NF(id, Problem1S1ID( "illegal extension of unparse view:", id )); 
	    	} else
	    if ((kc_selvar_0_1->prod_sel() == sel_ITPredefinedUView) && (kc_selvar_0_2->prod_sel() == sel_ITPredefinedUView)) {

	    NF(id, Problem1S1ID( "illegal extension of predefined unparse view:", id )); 
	    	} else
	    if ((kc_selvar_0_1->prod_sel() == sel_ITUserFunction) && (kc_selvar_0_2->prod_sel() == sel_ITUserFunction)) {

	    NF(id, Problem1S1ID( "illegal extension of function:", id )); 
	    	} else
	    if ((kc_selvar_0_1->prod_sel() == sel_ITStorageClass) && (kc_selvar_0_2->prod_sel() == sel_ITStorageClass)) {
	    /* EMPTY */ 
	    	} else
	    if ((kc_selvar_0_1->prod_sel() == sel_ITStorageClass) && (kc_selvar_0_2->prod_sel() == sel_ITPredefinedStorageClass)) {
	    /* EMPTY */ 
	    	} else
	    if ((kc_selvar_0_1->prod_sel() == sel_ITPredefinedStorageClass) && (kc_selvar_0_2->prod_sel() == sel_ITStorageClass)) {

	    NF(id, Problem1S1ID( "illegal extension of storage class:", id )); 
	    	} else
	    if ((kc_selvar_0_1->prod_sel() == sel_ITPredefinedStorageClass) && (kc_selvar_0_2->prod_sel() == sel_ITPredefinedStorageClass)) {

	    NF(id, Problem1S1ID( "illegal extension of predefined storage class:", id )); 
	    	} else
	    if ((kc_selvar_0_1->prod_sel() == sel_ITUserOperator) && (kc_selvar_0_2->prod_sel() == sel_ITUserOperator)) {

	    NF(id, Problem1S1ID( "illegal redefinition of operator:", id )); 
	    	} else
	    if ((kc_selvar_0_1->prod_sel() == sel_ITUserOperator) && (kc_selvar_0_2->prod_sel() == sel_ITPredefinedOperator)) {

	    NF(id, Problem1S1ID( "illegal extension of predefined operator:", id )); 
	    	} else
	    if ((kc_selvar_0_1->prod_sel() == sel_ITPredefinedOperator) && (kc_selvar_0_2->prod_sel() == sel_ITUserOperator)) {

	    NF(id, Problem1S1ID( "illegal extension of operator:", id )); 
	    	} else
	    if ((kc_selvar_0_1->prod_sel() == sel_ITPredefinedOperator) && (kc_selvar_0_2->prod_sel() == sel_ITPredefinedOperator)) {

	    NF(id, Problem1S1ID( "illegal extension of predefined operator:", id )); 
	    	} else
	    if ((kc_selvar_0_1->prod_sel() == sel_ITUserPhylum) && (kc_selvar_0_2->prod_sel() == sel_ITUserPhylum)) {
	    /* EMPTY */ 
	    	} else
	    if ((kc_selvar_0_1->prod_sel() == sel_ITUserPhylum) && (kc_selvar_0_2->prod_sel() == sel_ITPredefinedPhylum)) {

	    NF(id, Problem1S1ID( "illegal extension of predefined phylum:", id )); 
	    	} else
	    if ((kc_selvar_0_1->prod_sel() == sel_ITPredefinedPhylum) && (kc_selvar_0_2->prod_sel() == sel_ITUserPhylum)) {

	    NF(id, Problem1S1ID( "illegal extension of phylum:", id )); 
	    	} else
	    if ((kc_selvar_0_1->prod_sel() == sel_ITPredefinedPhylum) && (kc_selvar_0_2->prod_sel() == sel_ITPredefinedPhylum)) {
	    /* EMPTY */ 
	    	} else
	    if ((kc_selvar_0_1->prod_sel() == sel_ITPatternVariable)) {
	    const ID t_id = phylum_cast<const impl_IDtype_ITPatternVariable*>(kc_selvar_0_1)->ID_1;
	    const integer t_scope = phylum_cast<const impl_IDtype_ITPatternVariable*>(kc_selvar_0_1)->integer_1;

	    NF(id, Problem1S1t1S1ID( "illegal extension of", uid->type, "as pattern variable:", id )); 
	    	} else
	    if ((kc_selvar_0_1->prod_sel() == sel_ITUserRView)) {

	    NF(id, Problem1S1t1S1ID( "illegal extension of ", uid->type, "as rewrite view", id )); 
	    	} else
	    if ((kc_selvar_0_1->prod_sel() == sel_ITPredefinedRView)) {

	    NF(id, Problem1S1t1S1ID( "illegal extension of ", uid->type, "as rewrite view", id )); 
	    	} else
	    if ((kc_selvar_0_1->prod_sel() == sel_ITUserUView)) {

	    NF(id, Problem1S1t1S1ID( "illegal extension of ", uid->type, "as unparse view", id )); 
	    	} else
	    if ((kc_selvar_0_1->prod_sel() == sel_ITPredefinedUView)) {

	    NF(id, Problem1S1t1S1ID( "illegal extension of ", uid->type, "as unparse view", id )); 
	    	} else
	    if ((kc_selvar_0_1->prod_sel() == sel_ITUserFunction)) {

	    NF(id, Problem1S1t1S1ID( "illegal extension of", uid->type, "as function:", id )); 
	    	} else
	    if ((kc_selvar_0_1->prod_sel() == sel_ITStorageClass)) {

	    NF(id, Problem1S1t1S1ID( "illegal extension of ", uid->type, "as storage class:", id )); 
	    	} else
	    if ((kc_selvar_0_1->prod_sel() == sel_ITPredefinedStorageClass)) {

	    NF(id, Problem1S1t1S1ID( "illegal extension of ", uid->type, "as storage class:", id )); 
	    	} else
	    if ((kc_selvar_0_1->prod_sel() == sel_ITUserOperator)) {

	    NF(id, Problem1S1t1S1ID( "illegal extension of ", uid->type, "as operator:", id )); 
	    	} else
	    if ((kc_selvar_0_1->prod_sel() == sel_ITPredefinedOperator)) {

	    NF(id, Problem1S1t1S1ID( "illegal extension of ", uid->type, "as operator:", id )); 
	    	} else
	    if ((kc_selvar_0_1->prod_sel() == sel_ITUserPhylum)) {

	    NF(id, Problem1S1t1S1ID( "illegal extension of ", uid->type, "as phylum:", id )); 
	    	} else
	    if ((kc_selvar_0_1->prod_sel() == sel_ITPredefinedPhylum)) {

	    NF(id, Problem1S1t1S1ID( "illegal extension of ", uid->type, "as phylum", id )); 
	    	} else
	    kc_no_default_in_with( "do_v_extendoccur", __LINE__, __FILE__ );
    }

}

bool f_useoccuroperator(ID id)
{{
	ID kc_selvar_0_1 = phylum_cast<ID>(id);
	if ((kc_selvar_0_1->prod_sel() == sel_Id)) {
	    const uniqID uid = phylum_cast<const impl_ID_Id*>(kc_selvar_0_1)->uniqID_1;
	    {
		IDtype kc_selvar_1_1 = phylum_cast<IDtype>( uid->type );
		if ((kc_selvar_1_1->prod_sel() == sel_ITUserOperator)) {
		    return true; 
		    	} else
		    if ((kc_selvar_1_1->prod_sel() == sel_ITPredefinedOperator)) {

		    NF(id, Problem1S1ID( "undefined operator (it's predefined, you're not supposed to use those):", id ));
		    return false;
		    	} else
		{
		    NF(id, Problem1S1tID( "undefined operator", id )); return false; 
		}
	    }

	} else
	{ kc_no_default_in_with( "f_useoccuroperator", __LINE__, __FILE__ );
	    return static_cast<bool>(0); }
    }

}

bool f_warnifnotvariable(ID id)
{{
	ID kc_selvar_0_1 = phylum_cast<ID>(id);
	if ((kc_selvar_0_1->prod_sel() == sel_Id)) {
	    const uniqID uid = phylum_cast<const impl_ID_Id*>(kc_selvar_0_1)->uniqID_1;
	    {
		IDtype kc_selvar_1_1 = phylum_cast<IDtype>( uid->type );
		if ((kc_selvar_1_1->prod_sel() == sel_ITUnknown)) {
		    return false; 
		    	} else
		    if ((kc_selvar_1_1->prod_sel() == sel_ITPatternVariable)) {
		    return false; 
		    	} else
		{
		    NF(id, Problem1S1tID( "variable expected:", id )); return true; 
		}
	    }

	} else
	{ kc_no_default_in_with( "f_warnifnotvariable", __LINE__, __FILE__ );
	    return static_cast<bool>(0); }
    }

}

bool f_useoccurphylum(ID id)
{{
	ID kc_selvar_0_1 = phylum_cast<ID>(id);
	if ((kc_selvar_0_1->prod_sel() == sel_Id)) {
	    const uniqID uid = phylum_cast<const impl_ID_Id*>(kc_selvar_0_1)->uniqID_1;
	    {
		IDtype kc_selvar_1_1 = phylum_cast<IDtype>( uid->type );
		if ((kc_selvar_1_1->prod_sel() == sel_ITUserPhylum)) {
		    return true;
		    	} else
		    if ((kc_selvar_1_1->prod_sel() == sel_ITPredefinedPhylum)) {
		    return true;
		    	} else
		{
		    NF(id, Problem1S1tID( "undefined phylum", id )); return false; 
		}
	    }

	} else
	{ kc_no_default_in_with( "f_useoccurphylum", __LINE__, __FILE__ );
	    return static_cast<bool>(0); }
    }

}

bool f_useoccurlistphylum(ID id)
{{
	ID kc_selvar_0_1 = phylum_cast<ID>(id);
	if ((kc_selvar_0_1->prod_sel() == sel_Id)) {
	    const uniqID uid = phylum_cast<const impl_ID_Id*>(kc_selvar_0_1)->uniqID_1;
	    {
		IDtype kc_selvar_1_1 = phylum_cast<IDtype>( uid->type );
		if ((kc_selvar_1_1->prod_sel() == sel_ITUserPhylum)) {
		    const phylumdeclaration pd = phylum_cast<const impl_IDtype_ITUserPhylum*>(kc_selvar_1_1)->phylumdeclaration_1;
		    {
			phylumdeclaration kc_selvar_2_1 = phylum_cast<phylumdeclaration>( pd );
			if ((kc_selvar_2_1->prod_sel() == sel_PhylumDeclaration) && (phylum_cast<const impl_phylumdeclaration_PhylumDeclaration*>(kc_selvar_2_1)->productionblock_1->prod_sel() == sel_PredefinedAlternatives)) {

			    NF(id, Problem1S1ID( "undefined list phylum (it's a predefined phylum):", id ));
			    return false; 
			    	} else
			    if ((kc_selvar_2_1->prod_sel() == sel_PhylumDeclaration) && (phylum_cast<const impl_phylumdeclaration_PhylumDeclaration*>(kc_selvar_2_1)->productionblock_1->prod_sel() == sel_NonlistAlternatives)) {

			    NF(id, Problem1S1ID( "undefined list phylum (it's a non-list phylum):", id ));
			    return false; 
			    	} else
			    if ((kc_selvar_2_1->prod_sel() == sel_PhylumDeclaration) && (phylum_cast<const impl_phylumdeclaration_PhylumDeclaration*>(kc_selvar_2_1)->productionblock_1->prod_sel() == sel_ListAlternatives)) {
			    return true; 
			    	} else
			    if ((kc_selvar_2_1->prod_sel() == sel_PhylumDeclaration) && (phylum_cast<const impl_phylumdeclaration_PhylumDeclaration*>(kc_selvar_2_1)->productionblock_1->prod_sel() == sel_Emptyproductionblock)) {

			    NF(id, Problem1S1ID( "undefined list phylum (the productionblock is empty):", id ));
			    return false; 
			    	} else
			{ kc_no_default_in_with( "f_useoccurlistphylum", __LINE__, __FILE__ );
			    return static_cast<bool>(0); }
		    }

		} else
		{
		    NF(id, Problem1S1tID( "undefined list phylum", id )); return false; 
		}
	    }

	} else
	{ kc_no_default_in_with( "f_useoccurlistphylum", __LINE__, __FILE__ );
	    return static_cast<bool>(0); }
    }

}

bool f_useoccuruviewname(ID id)
{{
	ID kc_selvar_0_1 = phylum_cast<ID>(id);
	if ((kc_selvar_0_1->prod_sel() == sel_Id)) {
	    const uniqID uid = phylum_cast<const impl_ID_Id*>(kc_selvar_0_1)->uniqID_1;
	    {
		IDtype kc_selvar_1_1 = phylum_cast<IDtype>( uid->type );
		if ((kc_selvar_1_1->prod_sel() == sel_ITUserUView)) {
		    return true; 
		    	} else
		    if ((kc_selvar_1_1->prod_sel() == sel_ITPredefinedUView)) {
		    return true; 
		    	} else
		{
		    NF(id, Problem1S1tID( "undefined unparse view:", id )); return false; 
		}
	    }

	} else
	{ kc_no_default_in_with( "f_useoccuruviewname", __LINE__, __FILE__ );
	    return static_cast<bool>(0); }
    }

}

bool f_useoccurrviewname(ID id)
{{
	ID kc_selvar_0_1 = phylum_cast<ID>(id);
	if ((kc_selvar_0_1->prod_sel() == sel_Id)) {
	    const uniqID uid = phylum_cast<const impl_ID_Id*>(kc_selvar_0_1)->uniqID_1;
	    {
		IDtype kc_selvar_1_1 = phylum_cast<IDtype>( uid->type );
		if ((kc_selvar_1_1->prod_sel() == sel_ITUserRView)) {
		    return true; 
		    	} else
		    if ((kc_selvar_1_1->prod_sel() == sel_ITPredefinedRView)) {
		    return true; 
		    	} else
		{
		    NF(id, Problem1S1tID( "undefined rewrite view:", id )); return false; 
		}
	    }

	} else
	{ kc_no_default_in_with( "f_useoccurrviewname", __LINE__, __FILE__ );
	    return static_cast<bool>(0); }
    }

}

bool f_useoccurstorageclass(ID id)
{{
	ID kc_selvar_0_1 = phylum_cast<ID>(id);
	if ((kc_selvar_0_1->prod_sel() == sel_Id)) {
	    const uniqID uid = phylum_cast<const impl_ID_Id*>(kc_selvar_0_1)->uniqID_1;
	    {
		IDtype kc_selvar_1_1 = phylum_cast<IDtype>( uid->type );
		if ((kc_selvar_1_1->prod_sel() == sel_ITStorageClass)) {
		    return true; 
		    	} else
		    if ((kc_selvar_1_1->prod_sel() == sel_ITPredefinedStorageClass)) {
		    return true; 
		    	} else
		{
		    NF(id, Problem1S1tID( "undefined storage class:", id )); return false; 
		}
	    }

	} else
	{ kc_no_default_in_with( "f_useoccurstorageclass", __LINE__, __FILE__ );
	    return static_cast<bool>(0); }
    }

}

static  bool occurlanguagename(ID id)
{
    {
	languagenames kc_fe_selvar_1 =  Thelanguages;

	while(
		kc_fe_selvar_1->prod_sel() == sel_Conslanguagenames
	    ) {
	    ID kc_selvar_0_1 = kc_fe_selvar_1->ID_1;
	    {
		{
		    {
			const ID l_id = kc_selvar_0_1;

			if(id->eq(l_id)) {
			    return true;
			}

		    }
		}

	    }
	    kc_fe_selvar_1 = kc_fe_selvar_1->languagenames_1;

	}
    }
    v_report(Fatal( FileLine( id->file, id->line ),
	    Problem1S1tID( "undefined language name:", id )));
    return false;

}

bool f_useoccurlanguagename(languagenames names)
{{
	languagenames kc_selvar_0_1 = phylum_cast<languagenames>(names);
	if ((kc_selvar_0_1->prod_sel() == sel_Nillanguagenames)) {
	    return true; 
	    	} else
	    if ((kc_selvar_0_1->prod_sel() == sel_Conslanguagenames)) {
	    const ID id = (kc_selvar_0_1)->ID_1;
	    const languagenames tail = (kc_selvar_0_1)->languagenames_1;

	    bool res=f_useoccurlanguagename( tail );
	    return occurlanguagename( id ) && res;

	} else
	{ kc_no_default_in_with( "f_useoccurlanguagename", __LINE__, __FILE__ );
	    return static_cast<bool>(0); }
    }

}

bool f_useoccurpatternvariable(ID id)
{{
	ID kc_selvar_0_1 = phylum_cast<ID>(id);
	if ((kc_selvar_0_1->prod_sel() == sel_Id)) {
	    const uniqID uid = phylum_cast<const impl_ID_Id*>(kc_selvar_0_1)->uniqID_1;
	    {
		IDtype kc_selvar_1_1 = phylum_cast<IDtype>( uid->type );
		if ((kc_selvar_1_1->prod_sel() == sel_ITPatternVariable)) {
		    return true; 
		    	} else
		{
		    NF(id, Problem1S1tID( "undefined pattern variable:", id )); return false; 
		}
	    }

	} else
	{ kc_no_default_in_with( "f_useoccurpatternvariable", __LINE__, __FILE__ );
	    return static_cast<bool>(0); }
    }

}


} // namespace kc
