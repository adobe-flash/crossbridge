/* translation of file(s)
	"abs.k"
	"main.k"
	"parse.k"
	"error.k"
	"occur.k"
	"util.k"
	"gen.k"
	"gutil.k"
	"pat.k"
 */
/* generated by:
 *  @(#)$Author: criswell $
 */
#define KC_UNPARSE

#include <stdio.h>
#include <string>
#include <stdlib.h>
#include "k.h"
#include "unpk.h"


namespace kc {
base_uview_class base_uview;
view_filename_class view_filename;
view_error_class view_error;
view_error_tID_class view_error_tID;
view_check_class view_check;
view_check_count_class view_check_count;
view_check_count1_class view_check_count1;
view_check_outmostopers_in_phylum_class view_check_outmostopers_in_phylum;
view_set_type_class view_set_type;
view_check_is_var_class view_check_is_var;
view_gen_initializephyla_c_class view_gen_initializephyla_c;
view_check_u_class view_check_u;
view_check_r_class view_check_r;
view_check_viewnames_class view_check_viewnames;
view_check_uniq_class view_check_uniq;
view_check_uniq1_class view_check_uniq1;
view_check_uniq2_class view_check_uniq2;
view_make_patternreps_class view_make_patternreps;
view_printer_outputfileline_class view_printer_outputfileline;
view_printer_reset_class view_printer_reset;
view_no_of_printed_string_chars_reset_class view_no_of_printed_string_chars_reset;
view_open_namespace_class view_open_namespace;
view_close_namespace_class view_close_namespace;
view_gen_k_h_class view_gen_k_h;
view_gen_end_k_h_class view_gen_end_k_h;
view_gen_k_c_class view_gen_k_c;
view_gen_alloc_h_class view_gen_alloc_h;
view_gen_alloc_c_class view_gen_alloc_c;
view_gen_deprecated_class view_gen_deprecated;
view_gen_enumphyla_h_class view_gen_enumphyla_h;
view_gen_enumoperators_h_class view_gen_enumoperators_h;
view_gen_operatormap_type_h_class view_gen_operatormap_type_h;
view_gen_phylummap_c_class view_gen_phylummap_c;
view_gen_operatormap_c_class view_gen_operatormap_c;
view_count_args_class view_count_args;
view_count_attrs_class view_count_attrs;
view_count_nonstaticmembers_class view_count_nonstaticmembers;
view_gen_operatormap_subphyla_class view_gen_operatormap_subphyla;
view_gen_operatormap_attributes_class view_gen_operatormap_attributes;
view_gen_uniqmap_c_class view_gen_uniqmap_c;
view_gen_uniqmap_c_1_class view_gen_uniqmap_c_1;
view_gen_uniqmap_c_2_class view_gen_uniqmap_c_2;
view_gen_nodetypedefs_h_class view_gen_nodetypedefs_h;
view_gen_nodetypes_h_class view_gen_nodetypes_h;
view_gen_yaccstacktype_h_class view_gen_yaccstacktype_h;
view_gen_noofoperators_h_class view_gen_noofoperators_h;
view_gen_assertmacros_h_class view_gen_assertmacros_h;
view_gen_assertmacros_c_class view_gen_assertmacros_c;
view_gen_operatordecls_h_class view_gen_operatordecls_h;
view_gen_operatorcast_h_class view_gen_operatorcast_h;
view_gen_operatordefs_c_class view_gen_operatordefs_c;
view_gen_operatordefs_c_0_class view_gen_operatordefs_c_0;
view_gen_operatordefs_c_1_class view_gen_operatordefs_c_1;
view_gen_operatordefs_c_2_class view_gen_operatordefs_c_2;
view_gen_initializephyla_whiletest_c_class view_gen_initializephyla_whiletest_c;
view_gen_initializephyla_init_el_c_class view_gen_initializephyla_init_el_c;
view_gen_initializephyla_update_loop_c_class view_gen_initializephyla_update_loop_c;
view_gen_operatordefs_nonhash_c_class view_gen_operatordefs_nonhash_c;
view_gen_operatordefs_hash_c_class view_gen_operatordefs_hash_c;
view_gen_access_functions_class view_gen_access_functions;
view_gen_create_function_class view_gen_create_function;
view_gen_attributeOf_function_class view_gen_attributeOf_function;
view_gen_argseqnr_class view_gen_argseqnr;
view_gen_fnarg_asserts_class view_gen_fnarg_asserts;
view_gen_fnarg_and_decls_class view_gen_fnarg_and_decls;
view_gen_fnarg_and_decls_predef_class view_gen_fnarg_and_decls_predef;
view_gen_assignments_class view_gen_assignments;
view_gen_assignment_inis_class view_gen_assignment_inis;
view_gen_user_assignment_inis_class view_gen_user_assignment_inis;
view_gen_assignments_predef_class view_gen_assignments_predef;
view_gen_assignments_predef_ini_class view_gen_assignments_predef_ini;
view_gen_test_class view_gen_test;
view_gen_error_decls_h_class view_gen_error_decls_h;
view_gen_error_defs_c_class view_gen_error_defs_c;
view_gen_printdotdecls_h_class view_gen_printdotdecls_h;
view_gen_printdotdefs_c_class view_gen_printdotdefs_c;
view_gen_printdotedges_c_class view_gen_printdotedges_c;
view_gen_listdecls_h_class view_gen_listdecls_h;
view_gen_listdefs_c_class view_gen_listdefs_c;
view_gen_includes_class view_gen_includes;
view_do_gen_includes_class view_do_gen_includes;
view_gen_csgio_start_h_class view_gen_csgio_start_h;
view_gen_csgio_end_h_class view_gen_csgio_end_h;
view_gen_csgio_h_class view_gen_csgio_h;
view_gen_csgio_start_c_class view_gen_csgio_start_c;
view_gen_csgio_c_class view_gen_csgio_c;
view_gen_copy_attributes_c_class view_gen_copy_attributes_c;
view_gen_copydefs_c_class view_gen_copydefs_c;
view_gen_rewritek_h_class view_gen_rewritek_h;
view_gen_end_rewritek_h_class view_gen_end_rewritek_h;
view_gen_rewritek_c_class view_gen_rewritek_c;
view_gen_rewritedefs_c_class view_gen_rewritedefs_c;
view_gen_rewritedefs_default_c_class view_gen_rewritedefs_default_c;
view_gen_rewritedefs_other_c_class view_gen_rewritedefs_other_c;
view_gen_rewritedefs_rewritearg_c_class view_gen_rewritedefs_rewritearg_c;
view_gen_rewritedefs_nl_arg_c_class view_gen_rewritedefs_nl_arg_c;
view_gen_rewritedefs_testarg_c_class view_gen_rewritedefs_testarg_c;
view_gen_rewritedefs_dotestarg_c_class view_gen_rewritedefs_dotestarg_c;
view_gen_rewritedefs_args_c_class view_gen_rewritedefs_args_c;
view_gen_rewritedefs_body_c_class view_gen_rewritedefs_body_c;
view_gen_withcases_and_default_class view_gen_withcases_and_default;
view_rw_predicates_class view_rw_predicates;
view_wc_predicates_class view_wc_predicates;
view_unp_predicates_class view_unp_predicates;
view_wc_bindings_class view_wc_bindings;
view_unp_bindings_class view_unp_bindings;
view_rw_bindings_class view_rw_bindings;
view_gen_fnk_h_class view_gen_fnk_h;
view_gen_fnkdecls_c_class view_gen_fnkdecls_c;
view_gen_fnk_c_class view_gen_fnk_c;
view_gen_fn_pointer_name_class view_gen_fn_pointer_name;
view_gen_fnkargs_class view_gen_fnkargs;
view_gen_fnkdecls_class view_gen_fnkdecls;
view_gen_fns_start_h_class view_gen_fns_start_h;
view_gen_fns_end_h_class view_gen_fns_end_h;
view_gen_fns_start_c_class view_gen_fns_start_c;
view_gen_fns_owninclude_c_class view_gen_fns_owninclude_c;
view_gen_unpk_h_class view_gen_unpk_h;
view_gen_unparsedecls_h_class view_gen_unparsedecls_h;
view_gen_rewritedecls_h_class view_gen_rewritedecls_h;
view_uview_def_class view_uview_def;
view_gen_end_unpk_h_class view_gen_end_unpk_h;
view_gen_unpk_c_class view_gen_unpk_c;
view_gen_default_types_unpk_c_class view_gen_default_types_unpk_c;
view_gen_unparsedefs_c_class view_gen_unparsedefs_c;
view_gen_unparsedefs_other_c_class view_gen_unparsedefs_other_c;
view_gen_unpstr_c_class view_gen_unpstr_c;
view_gen_user_predicates_class view_gen_user_predicates;
view_predicate_bindings_class view_predicate_bindings;
view_checklanguagenames_class view_checklanguagenames;
view_output_collection_class view_output_collection;
view_gen_classdecls1_h_class view_gen_classdecls1_h;
view_gen_classdecls2_h_class view_gen_classdecls2_h;
view_gen_classdefs_c_class view_gen_classdefs_c;
view_gen_subphylumdefs_c_class view_gen_subphylumdefs_c;
view_gen_cast_class view_gen_cast;
view_gen_hashtables_h_class view_gen_hashtables_h;
view_gen_hashtables_c_class view_gen_hashtables_c;
view_gen_yxx_union_h_class view_gen_yxx_union_h;
view_gen_member_dcl_h_class view_gen_member_dcl_h;
view_gen_set_subphylumdefs_c_class view_gen_set_subphylumdefs_c;
view_gen_viewvars_c_class view_gen_viewvars_c;
view_gen_argseqnr_rec_class view_gen_argseqnr_rec;
view_gen_opt_const_class view_gen_opt_const;
view_uview_class_decl_class view_uview_class_decl;
view_uview_class_def_class view_uview_class_def;
view_rview_class_decl_class view_rview_class_decl;
view_rview_class_def_class view_rview_class_def;
view_collect_strings_class view_collect_strings;
view_class_of_op_class view_class_of_op;
view_class_of_phy_class view_class_of_phy;

impl_uviews uviews[] = {
    {"base_uview",&base_uview},
    {"view_error_format", 0},
    {"view_filename",&view_filename},
    {"view_error",&view_error},
    {"view_error_tID",&view_error_tID},
    {"view_check",&view_check},
    {"view_check_count",&view_check_count},
    {"view_check_count1",&view_check_count1},
    {"view_check_outmostopers_in_phylum",&view_check_outmostopers_in_phylum},
    {"view_set_type",&view_set_type},
    {"view_check_is_var",&view_check_is_var},
    {"view_gen_initializephyla_c",&view_gen_initializephyla_c},
    {"view_check_u",&view_check_u},
    {"view_check_r",&view_check_r},
    {"view_check_viewnames",&view_check_viewnames},
    {"view_check_uniq",&view_check_uniq},
    {"view_check_uniq1",&view_check_uniq1},
    {"view_check_uniq2",&view_check_uniq2},
    {"view_make_patternreps",&view_make_patternreps},
    {"view_printer_outputfileline",&view_printer_outputfileline},
    {"view_printer_reset",&view_printer_reset},
    {"view_no_of_printed_string_chars_reset",&view_no_of_printed_string_chars_reset},
    {"view_open_namespace",&view_open_namespace},
    {"view_close_namespace",&view_close_namespace},
    {"view_gen_k_h",&view_gen_k_h},
    {"view_gen_end_k_h",&view_gen_end_k_h},
    {"view_gen_k_c",&view_gen_k_c},
    {"view_gen_alloc_h",&view_gen_alloc_h},
    {"view_gen_alloc_c",&view_gen_alloc_c},
    {"view_gen_deprecated",&view_gen_deprecated},
    {"view_gen_enumphyla_h",&view_gen_enumphyla_h},
    {"view_gen_enumoperators_h",&view_gen_enumoperators_h},
    {"view_gen_operatormap_type_h",&view_gen_operatormap_type_h},
    {"view_gen_phylummap_c",&view_gen_phylummap_c},
    {"view_gen_operatormap_c",&view_gen_operatormap_c},
    {"view_count_args",&view_count_args},
    {"view_count_attrs",&view_count_attrs},
    {"view_count_nonstaticmembers",&view_count_nonstaticmembers},
    {"view_gen_operatormap_subphyla",&view_gen_operatormap_subphyla},
    {"view_gen_operatormap_attributes",&view_gen_operatormap_attributes},
    {"view_gen_uniqmap_c",&view_gen_uniqmap_c},
    {"view_gen_uniqmap_c_1",&view_gen_uniqmap_c_1},
    {"view_gen_uniqmap_c_2",&view_gen_uniqmap_c_2},
    {"view_gen_nodetypedefs_h",&view_gen_nodetypedefs_h},
    {"view_gen_nodetypes_h",&view_gen_nodetypes_h},
    {"view_gen_yaccstacktype_h",&view_gen_yaccstacktype_h},
    {"view_gen_noofoperators_h",&view_gen_noofoperators_h},
    {"view_gen_assertmacros_h",&view_gen_assertmacros_h},
    {"view_gen_assertmacros_c",&view_gen_assertmacros_c},
    {"view_gen_operatordecls_h",&view_gen_operatordecls_h},
    {"view_gen_operatorcast_h",&view_gen_operatorcast_h},
    {"view_gen_operatordefs_c",&view_gen_operatordefs_c},
    {"view_gen_operatordefs_c_0",&view_gen_operatordefs_c_0},
    {"view_gen_operatordefs_c_1",&view_gen_operatordefs_c_1},
    {"view_gen_operatordefs_c_2",&view_gen_operatordefs_c_2},
    {"view_gen_initializephyla_whiletest_c",&view_gen_initializephyla_whiletest_c},
    {"view_gen_initializephyla_init_el_c",&view_gen_initializephyla_init_el_c},
    {"view_gen_initializephyla_update_loop_c",&view_gen_initializephyla_update_loop_c},
    {"view_gen_operatordefs_nonhash_c",&view_gen_operatordefs_nonhash_c},
    {"view_gen_operatordefs_hash_c",&view_gen_operatordefs_hash_c},
    {"view_gen_access_functions",&view_gen_access_functions},
    {"view_gen_create_function",&view_gen_create_function},
    {"view_gen_attributeOf_function",&view_gen_attributeOf_function},
    {"view_gen_argseqnr",&view_gen_argseqnr},
    {"view_gen_fnarg_asserts",&view_gen_fnarg_asserts},
    {"view_gen_fnarg_and_decls",&view_gen_fnarg_and_decls},
    {"view_gen_fnarg_and_decls_predef",&view_gen_fnarg_and_decls_predef},
    {"view_gen_assignments",&view_gen_assignments},
    {"view_gen_assignment_inis",&view_gen_assignment_inis},
    {"view_gen_user_assignment_inis",&view_gen_user_assignment_inis},
    {"view_gen_assignments_predef",&view_gen_assignments_predef},
    {"view_gen_assignments_predef_ini",&view_gen_assignments_predef_ini},
    {"view_gen_test",&view_gen_test},
    {"view_gen_error_decls_h",&view_gen_error_decls_h},
    {"view_gen_error_defs_c",&view_gen_error_defs_c},
    {"view_gen_printdotdecls_h",&view_gen_printdotdecls_h},
    {"view_gen_printdotdefs_c",&view_gen_printdotdefs_c},
    {"view_gen_printdotedges_c",&view_gen_printdotedges_c},
    {"view_gen_listdecls_h",&view_gen_listdecls_h},
    {"view_gen_listdefs_c",&view_gen_listdefs_c},
    {"view_gen_includes",&view_gen_includes},
    {"view_do_gen_includes",&view_do_gen_includes},
    {"view_gen_csgio_start_h",&view_gen_csgio_start_h},
    {"view_gen_csgio_end_h",&view_gen_csgio_end_h},
    {"view_gen_csgio_h",&view_gen_csgio_h},
    {"view_gen_csgio_start_c",&view_gen_csgio_start_c},
    {"view_gen_csgio_c",&view_gen_csgio_c},
    {"view_gen_copy_attributes_c",&view_gen_copy_attributes_c},
    {"view_gen_copydefs_c",&view_gen_copydefs_c},
    {"view_gen_rewritek_h",&view_gen_rewritek_h},
    {"view_gen_end_rewritek_h",&view_gen_end_rewritek_h},
    {"view_gen_rewritek_c",&view_gen_rewritek_c},
    {"view_gen_rewritedefs_c",&view_gen_rewritedefs_c},
    {"view_gen_rewritedefs_default_c",&view_gen_rewritedefs_default_c},
    {"view_gen_rewritedefs_other_c",&view_gen_rewritedefs_other_c},
    {"view_gen_rewritedefs_rewritearg_c",&view_gen_rewritedefs_rewritearg_c},
    {"view_gen_rewritedefs_nl_arg_c",&view_gen_rewritedefs_nl_arg_c},
    {"view_gen_rewritedefs_testarg_c",&view_gen_rewritedefs_testarg_c},
    {"view_gen_rewritedefs_dotestarg_c",&view_gen_rewritedefs_dotestarg_c},
    {"view_gen_rewritedefs_args_c",&view_gen_rewritedefs_args_c},
    {"view_gen_rewritedefs_body_c",&view_gen_rewritedefs_body_c},
    {"view_gen_withcases_and_default",&view_gen_withcases_and_default},
    {"view_rw_predicates",&view_rw_predicates},
    {"view_wc_predicates",&view_wc_predicates},
    {"view_unp_predicates",&view_unp_predicates},
    {"view_wc_bindings",&view_wc_bindings},
    {"view_unp_bindings",&view_unp_bindings},
    {"view_rw_bindings",&view_rw_bindings},
    {"view_gen_fnk_h",&view_gen_fnk_h},
    {"view_gen_fnkdecls_c",&view_gen_fnkdecls_c},
    {"view_gen_fnk_c",&view_gen_fnk_c},
    {"view_gen_fn_pointer_name",&view_gen_fn_pointer_name},
    {"view_gen_fnkargs",&view_gen_fnkargs},
    {"view_gen_fnkdecls",&view_gen_fnkdecls},
    {"view_gen_fns_start_h",&view_gen_fns_start_h},
    {"view_gen_fns_end_h",&view_gen_fns_end_h},
    {"view_gen_fns_start_c",&view_gen_fns_start_c},
    {"view_gen_fns_owninclude_c",&view_gen_fns_owninclude_c},
    {"view_gen_unpk_h",&view_gen_unpk_h},
    {"view_gen_unparsedecls_h",&view_gen_unparsedecls_h},
    {"view_gen_rewritedecls_h",&view_gen_rewritedecls_h},
    {"view_uview_def",&view_uview_def},
    {"view_gen_end_unpk_h",&view_gen_end_unpk_h},
    {"view_gen_unpk_c",&view_gen_unpk_c},
    {"view_gen_default_types_unpk_c",&view_gen_default_types_unpk_c},
    {"view_gen_unparsedefs_c",&view_gen_unparsedefs_c},
    {"view_gen_unparsedefs_default_c", 0},
    {"view_gen_unparsedefs_other_c",&view_gen_unparsedefs_other_c},
    {"view_gen_unpstr_c",&view_gen_unpstr_c},
    {"view_gen_user_predicates",&view_gen_user_predicates},
    {"view_predicate_bindings",&view_predicate_bindings},
    {"view_checklanguagenames",&view_checklanguagenames},
    {"view_output_collection",&view_output_collection},
    {"view_gen_classdecls1_h",&view_gen_classdecls1_h},
    {"view_gen_classdecls2_h",&view_gen_classdecls2_h},
    {"view_gen_classdefs_c",&view_gen_classdefs_c},
    {"view_gen_subphylumdefs_c",&view_gen_subphylumdefs_c},
    {"view_gen_cast",&view_gen_cast},
    {"view_gen_hashtables_h",&view_gen_hashtables_h},
    {"view_gen_hashtables_c",&view_gen_hashtables_c},
    {"view_gen_yxx_union_h",&view_gen_yxx_union_h},
    {"view_gen_member_dcl_h",&view_gen_member_dcl_h},
    {"view_gen_set_subphylumdefs_c",&view_gen_set_subphylumdefs_c},
    {"view_gen_viewvars_c",&view_gen_viewvars_c},
    {"view_gen_argseqnr_rec",&view_gen_argseqnr_rec},
    {"view_gen_opt_const",&view_gen_opt_const},
    {"view_uview_class_decl",&view_uview_class_decl},
    {"view_uview_class_def",&view_uview_class_def},
    {"view_rview_class_decl",&view_rview_class_decl},
    {"view_rview_class_def",&view_rview_class_def},
    {"view_collect_strings",&view_collect_strings},
    {"view_class_of_op",&view_class_of_op},
    {"view_class_of_phy",&view_class_of_phy},
    {0,0}
};

} // namespace kc
namespace kc { }
using namespace kc;
/* included stuff */
//
// The Termprocessor Kimwitu++
//
// Copyright (C) 1991 University of Twente, Dept TIOS.
// Copyright (C) 1998-2003 Humboldt-University of Berlin, Institute of Informatics
// All rights reserved.
//
// Kimwitu++ is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation; either version 2 of the License, or
// (at your option) any later version.
//
// Kimwitu++ is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with Kimwitu++; if not, write to the Free Software
// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
//

#include "util.h"
#include "occur.h"

static int cl_scope = 0;

#include <stack>
static std::stack<operators> outmostoperators;

static std::stack<dollarvarstatus> dollarvarsallowed;

static std::stack<int> inforeachcontext;

static std::stack<arguments> argumentsstack;

static std::stack<ID> phylumstack;

static std::stack<phylumnames> phylumnamesstack;

static std::stack<withexpressions> withexpressionsstack;

static std::stack<ID> operatorstack;

static std::stack<variables> variablesstack;

#include "parse.h"
static ID cl_uniqueID = 0;
static ID cl_storageID = 0;

#include "pat.h"	/* for syn_outmostpatterns and v_resetbindingidmarks */

extern unparseitems The_current_unparseitems;

#include "defs.h"

#define FMOP 38
#define FMSZ 3
#define FMNCR 8
#define FMNCRD 8
#define FMEXIST 8
#define FMFRNC 8
#define FMFRRC 8
#define FMFREED 8
#define FMREM 8
#define FMTOT 9

const char* preDefTypeAndName[][2] = { {"", ""}, {"kc_char_t const*", "name"}, {"kc_char_t const*", "name"},
    {"REAL", "value"}, {"INTEGER", "value"}, {"void*", "pointer"}};

#include "gen.h"

// Definition of the view class for view_gen_unparsedefs_default_c;
// it contains an additional var to indicate whether we are unparsing a list pylum
// and another to show whether the user has supplied rules for the base view
struct view_gen_unparsedefs_default_c_class :view_gen_unparsedefs_default_c_baseclass
{
    bool isList;
    bool isOnlyDefault;
    view_gen_unparsedefs_default_c_class(bool LonL, bool oD):
    isList(LonL), isOnlyDefault(oD) { }
};
view_gen_unparsedefs_default_c_class view_gen_unparsedefs_default_c(false, false);

// To avoid covariant return types for broken compilers, we want to have three choices:
// Use them, don't use them, generate both and decide with preprocessor macros

// extended version: typename also in function name
void
covariant_choice(ID yest, const char* yess1, const char* yess2, const char *no1, const char *no2,
    printer_functor kc_printer, uview kc_current_view)
{
    kc_printer("\n", kc_current_view);
    if (g_options.covariant == 'p') kc_printer("#ifndef NO_COVARIANT_RETURN\n", kc_current_view);
    if (g_options.covariant != 'n') {
	yest->unparse(kc_printer, kc_current_view);
	kc_printer(yess1, kc_current_view);
	if (yess2!=0) {
	    yest->unparse(kc_printer, kc_current_view);
	    kc_printer(yess2, kc_current_view);
	}
    }
    if (g_options.covariant == 'p') kc_printer("\n#else\n", kc_current_view);
    if (g_options.covariant != 'y') {
	kc_printer(no1, kc_current_view);
	if (no2!=0) {
	    yest->unparse(kc_printer, kc_current_view);
	    kc_printer(no2, kc_current_view);
	}
    }
    if (g_options.covariant == 'p') kc_printer("\n#endif // NO_COVARIANT_RETURN\n", kc_current_view);
}

// short version: typename exactly once
inline void
covariant_choice(ID yest, const char* yess, const char *no, printer_functor kc_printer, uview kc_current_view)
{ covariant_choice(yest, yess, 0, no, 0, kc_printer, kc_current_view); }

// This printer functor doesn't print, but instead counts each of
// its invocations. Handy to find out whether a future unparsing
// will produce any output at all.
class count_printer: public printer_functor_class {
    int count;
    public:
    count_printer(): count(0) { }
    virtual void operator()(const char* s, uview v) { count++;}
    int operator()() { return count;}
};


#include "gutil.h"

#include <map>
#include <string>
#include <stack>
namespace { // everything here is local to unpk.cc
    int g_no_of_phyla;
    int g_no_of_operators;
    int gl_no_of_args;
    int gl_generic_counter;
    bool gl_isnotlist;

    std::map<string, path> gl_bindings;

    const int PHYLUMNUMBEROFFSET=0; /* should be >= 0; == the index of the last dummy element */
    const int OPERATORNUMBEROFFSET=0; /* should be >= 0; == the index of the last dummy element */

    std::stack<ID> selvarstack;
#define cf_pushselvar(o) do { selvarstack.push(o); \
	g_ctext_level++; \
    } while(0)
#define cf_topselvar() selvarstack.top()
#define cf_popselvar() do { selvarstack.pop();\
	g_ctext_level--; \
    } while(0)

	std::stack<ID> dollarvarstack;
    std::stack<ID> dollarvarextstack;

    ID gl_phylum = 0;
    phylumdeclaration gl_phydecl = 0;
    ID gl_view = 0;
    ID gl_operator = 0;
    alternative gl_alternative = 0;
    Ccode_option gl_cco = 0;
    storageoption gl_storageoption = 0;
    bool gl_atomicity;
    arguments gl_args = 0;
    ac_identifier_list gl_idents = 0;
    fndeclarations gl_members = 0;
    rewriterulesinfo gl_rewrite_rewriteinfo = 0;
    const char *g_emptystring = "";
    int g_ctext_level = 0;
    int g_withexpr_nr = 0;
    int g_fe_selvar_nr = 0;
    const char *gl_return_type = "";
    ID gl_return_ID = 0;
    int gl_star_count = 0;
    const char *gl_function = "";
    ID gl_sto = 0;
    bool gl_rewrite_goto_used = false;
    bool gl_unparse_goto_used = false;
    ID gl_type = 0;
    int gl_j = 0;
    bool gl_print_line_directive = false;
    uview_enum gl_outer_view;
}


/* end included stuff */


namespace kc {

#ifndef KC_TRACE_PROVIDED
#define KC_TRACE_PROVIDED(COND,FILE,LINE,NODE) COND
#endif

void
impl_abstract_phylum::unparse(printer_function opf, uview uv)
{
    printer_functor_function_wrapper pf(opf);
    do_unparse(pf, uv);
}

// Everything given as a pointer is expected to have an unparse-method (we
// believe it's a phylum), unless there's a specialisation for it

void
unparse(abstract_phylum kc_p, printer_functor kc_printer, uview kc_current_view)
{
    kc_p->unparse(kc_printer, kc_current_view);
}

void
unparse(void *kc_p, printer_functor kc_printer, uview kc_current_view)
{
    // MPi: 20020628 there shouldn't be any left
    assertionFailed("Unparse called for untyped pointer");
    // MPi: cast should be unnecessary, but there are still void*
    reinterpret_cast<impl_abstract_phylum*>(kc_p)->unparse(kc_printer, kc_current_view);
}

void
unparse(int kc_v, printer_functor kc_printer, uview kc_current_view)
{
    kc_char kc_string[200];
    kc_print_integer(kc_string,kc_v);
    kc_printer(kc_string, kc_current_view);
}

void
unparse(double kc_v, printer_functor kc_printer, uview kc_current_view)
{
    kc_char kc_string[200];
    kc_print_real(kc_string,kc_v);
    kc_printer(kc_string, kc_current_view);
}

void
unparse(kc_char *kc_v, printer_functor kc_printer, uview kc_current_view)
{
    kc_printer(kc_v, kc_current_view);
}

void
unparse(kc_string_t kc_v, printer_functor kc_printer, uview kc_current_view)
{
    kc_printer(kc_v.c_str(), kc_current_view);
}

void
impl_abstract_phylum::default_unparse(printer_functor kc_printer, uview kc_current_view)
{
    register int no_sons = operator_info[prod_sel()].no_sons;
    for (int i=0; i < no_sons; i++)
    subphylum(i)->unparse(kc_printer, kc_current_view);
}

void
impl_casestring__Str::do_unparse(printer_functor kc_printer, uview kc_current_view)
{
    kc::unparse(name, kc_printer, kc_current_view);
}

void
impl_nocasestring_NoCaseStr::do_unparse(printer_functor kc_printer, uview kc_current_view)
{
    kc::unparse(name, kc_printer, kc_current_view);
}

void
impl_integer__Int::do_unparse(printer_functor kc_printer, uview kc_current_view)
{
    kc::unparse(value, kc_printer, kc_current_view);
}

void
impl_real__Real::do_unparse(printer_functor kc_printer, uview kc_current_view)
{
    kc::unparse(value, kc_printer, kc_current_view);
}

void
impl_voidptr__VoidPtr::do_unparse(printer_functor kc_printer, uview kc_current_view)
{
    kc::unparse(pointer, kc_printer, kc_current_view);
}


void
impl_uniqID_Str::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case view_error_enum: {
	    view_error_class& kc_current_view=static_cast<view_error_class&>(kc_current_view_base);
	    {
		const casestring cs = this->casestring_1;
		kc::unparse(cs, kc_printer, kc_current_view);
	    }
	    break;
	}

	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    { /* Alternative( *, args ) -> [view_gen_unparsedefs_default_c: */
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


void
impl_ID_Id::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case view_class_of_phy_enum: {
	    view_class_of_phy_class& kc_current_view=static_cast<view_class_of_phy_class&>(kc_current_view_base);
	    {
		const uniqID pid = this->uniqID_1;
		{ kc_printer(kc_t("impl_"), kc_current_view); }
		kc::unparse(pid, kc_printer, kc_current_view);
	    }
	    break;
	}
	case view_class_of_op_enum: {
	    view_class_of_op_class& kc_current_view=static_cast<view_class_of_op_class&>(kc_current_view_base);
	    {
		const uniqID oid = this->uniqID_1;
		ID pid=f_phylumofoperator(this);
		if (f_listelementphylum(pid)->eq(f_emptyId())) 
		{
		    kc::unparse(pid, kc_printer, view_class_of_phy);
		    { kc_printer(kc_t("_"), kc_current_view); }
		    kc::unparse(oid, kc_printer, kc_current_view);
		}
		else 
		{
		    kc::unparse(pid, kc_printer, view_class_of_phy);
		}
	    }
	    break;
	}
	case view_output_collection_enum: {
	    view_output_collection_class& kc_current_view=static_cast<view_output_collection_class&>(kc_current_view_base);
	    {
		const ID id = this/**/;
		{ kc_printer(kc_t("char* kc_language_"), kc_current_view); }
		kc::unparse(id, kc_printer, base_uview);
		{ kc_printer(kc_t(" [] = {\n"), kc_current_view); }
	    }
	    break;
	}
	case view_gen_fn_pointer_name_enum: {
	    view_gen_fn_pointer_name_class& kc_current_view=static_cast<view_gen_fn_pointer_name_class&>(kc_current_view_base);
	    if ((this->uniqID_1->prod_sel() == sel_Str)) {
		const ID id = this/**/;
		const uniqID uniqId = this->uniqID_1;
		const casestring s = phylum_cast<const impl_uniqID_Str*>(this->uniqID_1)->casestring_1;
		if(f_ispredefinedphylum(id) && strncmp(s->name, "abstract_", 9)!=0) 
		{
		    { kc_printer(kc_t("impl_"), kc_current_view); }
		    kc::unparse(uniqId, kc_printer, kc_current_view);
		    { kc_printer(kc_t("_"), kc_current_view); }
		    UNPARSE(f_operatorofphylum(id, 1)); 
		     }
		else if(f_isphylum(id)) 
		{
		    { kc_printer(kc_t("impl_"), kc_current_view); }
		    kc::unparse(uniqId, kc_printer, kc_current_view);
		}
		else if(f_alternativeofoperator(id)) 
		{
		    UNPARSE(f_phylumofoperator(id)); 
		    	{ kc_printer(kc_t("_"), kc_current_view); }
		    kc::unparse(uniqId, kc_printer, kc_current_view);
		}
		else 
		{
		    kc::unparse(uniqId, kc_printer, kc_current_view);
		}
	    } else
		    goto kc_unparsing_default;
	    break;
	}
	case view_error_tID_enum: {
	    view_error_tID_class& kc_current_view=static_cast<view_error_tID_class&>(kc_current_view_base);
	    {
		const uniqID uid = this->uniqID_1;
		kc::unparse(uid->type, kc_printer, kc_current_view);
		{ kc_printer(kc_t(" "), kc_current_view); }
		kc::unparse(uid, kc_printer, kc_current_view);
		if (uid->line != 0) 
		{
		    { kc_printer(kc_t(" (introduced at "), kc_current_view); }
		    kc::unparse(uid->file, kc_printer, kc_current_view);
		    { kc_printer(kc_t(":"), kc_current_view); }
		    kc::unparse(uid->line, kc_printer, kc_current_view);
		    { kc_printer(kc_t(")"), kc_current_view); }
		}
	    }
	    break;
	}
	case view_error_enum: {
	    view_error_class& kc_current_view=static_cast<view_error_class&>(kc_current_view_base);
	    {
		const uniqID uid = this->uniqID_1;
		kc::unparse(uid, kc_printer, kc_current_view);
		if (uid->line != 0) 
		{
		    { kc_printer(kc_t(" (introduced at "), kc_current_view); }
		    kc::unparse(uid->file, kc_printer, kc_current_view);
		    { kc_printer(kc_t(":"), kc_current_view); }
		    kc::unparse(uid->line, kc_printer, kc_current_view);
		    { kc_printer(kc_t(")"), kc_current_view); }
		}
	    }
	    break;
	}

	default:
	kc_unparsing_default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    { /* Alternative( *, args ) -> [view_gen_unparsedefs_default_c: */
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


void
impl_INT_Int::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case view_error_enum: {
	    view_error_class& kc_current_view=static_cast<view_error_class&>(kc_current_view_base);
	    {
		const integer i = this->integer_1;
		kc::unparse(i, kc_printer, kc_current_view);
	    }
	    break;
	}

	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    { /* Alternative( *, args ) -> [view_gen_unparsedefs_default_c: */
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


void
impl_STRING_String::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    { /* Alternative( *, args ) -> [view_gen_unparsedefs_default_c: */
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


void
impl_phylumdeclarationsroot_PhylumDeclarations::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case view_rview_class_decl_enum: {
	    view_rview_class_decl_class& kc_current_view=static_cast<view_rview_class_decl_class&>(kc_current_view_base);
	    {
		{ kc_printer(kc_t("\
\ntypedef enum {\
\n"), kc_current_view); }
		kc::unparse(Therviewnames, kc_printer, view_gen_rewritek_h);
		{ kc_printer(kc_t("last_rview\
\n} rview_enum;\
\n\
\nstruct impl_rviews {\
\n    const char *name;\
\n    rview_class *view;\
\n};\
\nextern struct impl_rviews rviews[];\
\nclass "), kc_current_view); }
		if(g_options.dllexports!="") {
		    PRINT(g_options.dllexports.c_str());
		    PRINT(" ");
		} 
			{ kc_printer(kc_t("rview_class {\
\n\rprotected:\v\
\n    // only used in derivations\
\n    rview_class(rview_enum v): m_view(v) { }\
\n    rview_class(const rview_class&): m_view(base_rview_enum)\
\n	\v{ /* do not copy"), kc_current_view );
		  kc_printer(kc_t(" m_view */ }\r\
\n\rpublic:\v\
\n    const char* name() const\
\n	\v{ return rviews[m_view].name; }\r\
\n    operator rview_enum() const\
\n	\v{ return m_view; }\r\
\n    bool operator==(const rview_cl"), kc_current_view );
		  kc_printer(kc_t("ass& other) const\
\n	\v{ return m_view == other.m_view; }\r\
\n"), kc_current_view); }
		if(g_options.rw_loop) 
		{
		    { kc_printer(kc_t("    // Called when the rewrite_loop enters a node (just before the call\
\n    //   to do_rewrite and before entering its sons).\
\n    // The result of this function is used instead of current in the "), kc_current_view );
		  kc_printer(kc_t("rewrite process.\
\n    // If skip_current is set to true (default is false), the result is not rewritten\
\n    //   any further (neither do_rewrite() nor post_rewrite() are called).\
\n    virtual ab"), kc_current_view );
		  kc_printer(kc_t("stract_phylum pre_rewrite(abstract_phylum current, bool& /* skip_current */)\
\n	\v{ return current; }\r\
\n    // Called when the rewrite_loop leaves current node (after the call to do_rewrite).\
\n  "), kc_current_view );
		  kc_printer(kc_t("  // Current is the finally rewritten node.\
\n    // The result is used instead of the argument to build the final tree.\
\n    // If again is set to true (default is false) the result node is rewritt"), kc_current_view );
		  kc_printer(kc_t("en again.\
\n    virtual abstract_phylum post_rewrite(abstract_phylum current, bool& /* again */)\
\n	\v{ return current; }\r\
\n"), kc_current_view); }
		}
		{ kc_printer(kc_t("\rprivate:\v\
\n    rview_enum m_view;\
\n};\
\n"), kc_current_view); }
	    }
	    break;
	}
	case view_uview_class_decl_enum: {
	    view_uview_class_decl_class& kc_current_view=static_cast<view_uview_class_decl_class&>(kc_current_view_base);
	    {
		{ kc_printer(kc_t("\
\ntypedef enum {\
\n"), kc_current_view); }
		kc::unparse(Theuviewnames, kc_printer, view_uview_def);
		{ kc_printer(kc_t(" last_uview\
\n} uview_enum;\
\n\
\nstruct impl_uviews {\
\n    const char *name;\
\n    uview_class *view;\
\n};\
\nextern impl_uviews uviews[];\
\nclass "), kc_current_view); }
		if(g_options.dllexports!="") {
		    PRINT(g_options.dllexports.c_str());
		    PRINT(" ");
		} 
			{ kc_printer(kc_t("uview_class {\
\n\rprotected:\v\
\n    // only used in derivations\
\n    uview_class(uview_enum v): m_view(v) { }\
\n    uview_class(c_uview): m_view(base_uview_enum)\
\n	\v{ /* do not copy m_view */ "), kc_current_view );
		  kc_printer(kc_t("}\r\
\n\rpublic:\v\
\n    const char* name() const\
\n	\v{ return uviews[m_view].name; }\r\
\n    operator uview_enum() const\
\n	\v{ return m_view; }\r\
\n    bool operator==(const uview_class& other)"), kc_current_view );
		  kc_printer(kc_t(" const\
\n	\v{ return m_view == other.m_view; }\r\
\n\rprivate:\v\
\n    uview_enum m_view;\
\n};\
\n\
\nclass "), kc_current_view); }
		if(g_options.dllexports!="") {
		    PRINT(g_options.dllexports.c_str());
		    PRINT(" ");
		} 
			{ kc_printer(kc_t("printer_functor_class {\
\n\rpublic:\v\
\n    virtual void operator()(const kc_char_t*, uview) { }\
\n    virtual ~printer_functor_class() { }\
\n};\
\n\
\nclass "), kc_current_view); }
		if(g_options.dllexports!="") {
		    PRINT(g_options.dllexports.c_str());
		    PRINT(" ");
		} 
			{ kc_printer(kc_t("printer_functor_function_wrapper : public printer_functor_class {\
\n\rpublic:\v\
\n    printer_functor_function_wrapper(const printer_function opf =0): m_old_printer(opf) { }\
\n    virtual ~printer_f"), kc_current_view );
		  kc_printer(kc_t("unctor_function_wrapper() { }\
\n    virtual void operator()(const kc_char_t* s, uview v)\
\n	\v{ if(m_old_printer) m_old_printer(s, v); }\r\
\n\rprivate:\v\
\n    printer_function m_old_printer;\
\n};"), kc_current_view );
		  kc_printer(kc_t("\
\n"), kc_current_view); }
	    }
	    break;
	}
	case view_gen_yxx_union_h_enum: {
	    view_gen_yxx_union_h_class& kc_current_view=static_cast<view_gen_yxx_union_h_class&>(kc_current_view_base);
	    {
		const phylumdeclarations d = this->phylumdeclarations_1;
		{ kc_printer(kc_t("union {\
\n"), kc_current_view); }
		kc::unparse(d, kc_printer, kc_current_view);
		{ kc_printer(kc_t("};\
\n"), kc_current_view); }
	    }
	    break;
	}
	case view_gen_hashtables_c_enum: {
	    view_gen_hashtables_c_class& kc_current_view=static_cast<view_gen_hashtables_c_class&>(kc_current_view_base);
	    {
		{ kc_printer(kc_t("\
\nextern const char* kc_storageclassnames[];\
\n\
\n#ifdef KC_STATISTICS\
\nvoid do_print_operator_statistics(FILE * kc_f)\
\n{\
\n    unsigned int kc_i;\
\n    assertNonNull( kc_f );\
\n    fprintf("), kc_current_view );
		  kc_printer(kc_t("kc_f, \"%-*s| %-*s| %-*s| %-*s| %-*s| %-*s| %-*s| %-*s| %-*s| %-*s\\n\", 38 , \"Operator\", 3, \"Sz\", 8, \"#oper\", 8, \"#new\", 8, \"#exist\", 8, \"#frnrec\", 8, \"#frrec\", 8, \"#freed\", 8, \"#rem\""), kc_current_view );
		  kc_printer(kc_t(", 9, \"total (bytes)\");\
\n    fprintf(kc_f, \"%-*s|%*s |%*d |%*d |%*d |%*d |%*d |%*d |%*d |%*d\\n\", 38, \"case sensitive strings\", 3, \"-\", 8, operator_statistics[sel__Str].created, 8, operator_st"), kc_current_view );
		  kc_printer(kc_t("atistics[sel__Str].existing_not_found, 8, operator_statistics[sel__Str].created-operator_statistics[sel__Str].existing_not_found, 8, 0, 8, 0, 8, 0, 8, 0, 9, kc_casestring_strlen);\
\n    fprintf(kc_f, "), kc_current_view );
		  kc_printer(kc_t("\"%-*s|%*s |%*d |%*d |%*d |%*d |%*d |%*d |%*d |%*d\\n\", 38, \"case insensitive strings\", 3, \"-\", 8, operator_statistics[sel_NoCaseStr].created, 8, operator_statistics[sel_NoCaseStr].existing_not_fo"), kc_current_view );
		  kc_printer(kc_t("und, 8, operator_statistics[sel_NoCaseStr].created-operator_statistics[sel_NoCaseStr].existing_not_found, 8, 0, 8, 0, 8, 0, 8, 0, 9, kc_nocasestring_strlen);\
\n    for (kc_i = one_before_first_operato"), kc_current_view );
		  kc_printer(kc_t("r+1; kc_i < last_operator; kc_i++) {\
\n	fprintf(kc_f, \"%-*s|%*d |%*d |%*d |%*d |%*d |%*d |%*d |%*d |%*d\\n\", 38, operator_info[kc_i].name, 3, operator_info[kc_i].size, 8, operator_statistics[kc_i].c"), kc_current_view );
		  kc_printer(kc_t("reated, 8, operator_statistics[kc_i].existing_not_found, 8, operator_statistics[kc_i].created-operator_statistics[kc_i].existing_not_found, 8, operator_statistics[kc_i].free_called[false], 8, operator_"), kc_current_view );
		  kc_printer(kc_t("statistics[kc_i].free_called[true], 8, operator_statistics[kc_i].freed[false]+operator_statistics[kc_i].freed[true], 8, operator_statistics[kc_i].existing_not_found-(operator_statistics[kc_i].freed[fal"), kc_current_view );
		  kc_printer(kc_t("se]+operator_statistics[kc_i].freed[true]), 9, operator_info[kc_i].size*(operator_statistics[kc_i].existing_not_found-(operator_statistics[kc_i].freed[false]+operator_statistics[kc_i].freed[true])));\
\n"), kc_current_view );
		  kc_printer(kc_t("    }\
\n}\
\n#endif // KC_STATISTICS\
\n\
\n"), kc_current_view); }
		if(!g_options.no_hashtables) 
		{
		    { kc_printer(kc_t("\
\nvoid\
\nht_static(kc_storageclass_t kc_a_storageclass_t)\
\n{\
\n    hashtables[kc_a_storageclass_t]->ht_static();\
\n}\
\n\
\nvoid\
\nht_dynamic(kc_storageclass_t kc_a_storageclass_t)\
\n{\
\n    "), kc_current_view );
		  kc_printer(kc_t("hashtables[kc_a_storageclass_t]->ht_dynamic();\
\n}\
\n\
\nvoid\
\nht_inc_level(kc_storageclass_t kc_a_storageclass_t)\
\n{\
\n    hashtables[kc_a_storageclass_t]->ht_inc_level();\
\n}\
\n\
\nvoid\
\nh"), kc_current_view );
		  kc_printer(kc_t("t_dec_level(kc_storageclass_t kc_a_storageclass_t)\
\n{\
\n    hashtables[kc_a_storageclass_t]->ht_dec_level();\
\n}\
\n\
\nvoid\
\nht_free_level(kc_storageclass_t kc_a_storageclass_t)\
\n{\
\n    hash"), kc_current_view );
		  kc_printer(kc_t("tables[kc_a_storageclass_t]->ht_free_level();\
\n}\
\n\
\nhashtable_t\
\nht_create_simple()\
\n{\
\n    hashtable_t kc_ht=new hashtable_struct_t;\
\n    kc_ht->set_to_be_freed();\
\n    return kc_ht;\
\n"), kc_current_view );
		  kc_printer(kc_t("}\
\n\
\nhashtable_t\
\nht_assign(hashtable_t kc_a_hashtable_t, kc_storageclass_t kc_a_storageclass_t, bool still_unique)\
\n{\
\n    hashtable_t kc_tmp = hashtables[kc_a_storageclass_t];\
\n    hashta"), kc_current_view );
		  kc_printer(kc_t("bles[kc_a_storageclass_t] = kc_a_hashtable_t;\
\n    kc_storageclass_still_uniq[kc_a_storageclass_t] = still_unique;\
\n    return kc_tmp;\
\n}\
\n\
\nhashtable_t\
\nht_assigned(kc_storageclass_t kc_a_"), kc_current_view );
		  kc_printer(kc_t("storageclass_t)\
\n{\
\n    return hashtables[kc_a_storageclass_t];\
\n}\
\n\
\nvoid\
\nht_clear(hashtable_t kc_a_hashtable_t)\
\n{\
\n    kc_a_hashtable_t->ht_clear();\
\n}\
\n\
\nvoid\
\nht_delete(ha"), kc_current_view );
		  kc_printer(kc_t("shtable_t kc_a_hashtable_t)\
\n{\
\n    if(kc_a_hashtable_t->to_be_freed())\
\n	delete kc_a_hashtable_t;\
\n}\
\n"), kc_current_view); }
		}
	    }
	    break;
	}
	case view_gen_hashtables_h_enum: {
	    view_gen_hashtables_h_class& kc_current_view=static_cast<view_gen_hashtables_h_class&>(kc_current_view_base);
	    {
		{ kc_printer(kc_t("\
\ntypedef struct {\
\n    int created;\
\n    int existing_not_found;\
\n    int free_called[2];\
\n    int freed[2];\
\n} KC_OPERATOR_STATISTICS;\
\n\
\n#ifdef KC_STATISTICS\
\n# define print_operat"), kc_current_view );
		  kc_printer(kc_t("or_statistics(kc_f) do_print_operator_statistics(kc_f)\
\n  void	do_print_operator_statistics(FILE*);\
\n#else\
\n# define print_operator_statistics(kc_f)\
\n#endif\
\n\
\ntypedef class hashtable_struc"), kc_current_view );
		  kc_printer(kc_t("t_t* hashtable_t;\
\n"), kc_current_view); }
		if(!g_options.no_hashtables) 
		{
		    { kc_printer(kc_t("void	ht_static (kc_storageclass_t);\
\nvoid	ht_dynamic (kc_storageclass_t);\
\nvoid	ht_inc_level (kc_storageclass_t);\
\nvoid	ht_dec_level (kc_storageclass_t);\
\nvoid	ht_free_level (kc_storageclass_t)"), kc_current_view );
		  kc_printer(kc_t(";\
\nhashtable_t	ht_create_simple ();\
\nhashtable_t	ht_assign (hashtable_t, kc_storageclass_t, bool still_unique=false);\
\nhashtable_t	ht_assigned (kc_storageclass_t);\
\nvoid	ht_clear (hashtable_t);"), kc_current_view );
		  kc_printer(kc_t("\
\nvoid	ht_delete (hashtable_t);\
\n"), kc_current_view); }
		}
	    }
	    break;
	}
	case view_gen_classdecls2_h_enum: {
	    view_gen_classdecls2_h_class& kc_current_view=static_cast<view_gen_classdecls2_h_class&>(kc_current_view_base);
	    {
		const phylumdeclarations pds = this->phylumdeclarations_1;
		{ kc_printer(kc_t("\
\n//namespace Phylum {\r\
\n"), kc_current_view); }
		{ kc_printer(kc_t("\
\nclass "), kc_current_view); }
		if(g_options.dllexports!="") {
		    PRINT(g_options.dllexports.c_str());
		    PRINT(" ");
		} 
			{ kc_printer(kc_t("impl_abstract_phylum"), kc_current_view); }

		{
		    baseclass_list kc_selvar_0_1 = phylum_cast<baseclass_list>(The_abstract_phylum_decl->base_classes);
		    if ((kc_selvar_0_1->prod_sel() == sel_Consbaseclass_list)) {

			PRINT("\b :\b ");
			UNPARSE(The_abstract_phylum_decl->base_classes);

		    } else
		    {

		    }
		}

		{ kc_printer(kc_t(" {\
\n\rpublic:\v\
\n    virtual enum_operators prod_sel() const =0;\
\n    static const enum_phyla phylum_sel_;\
\n    enum_phyla phylum() const;\
\n    const char* phylum_name() const;\
\n    const c"), kc_current_view );
		  kc_printer(kc_t("har* op_name() const;\
\n    virtual abstract_phylum subphylum(int) const;\
\n    virtual void set_subphylum(int, abstract_phylum);\
\n    void free(bool recursive=true);\
\n    bool eq(c_abstract_phyl"), kc_current_view );
		  kc_printer(kc_t("um) const;\
\n    void print();\
\n    void fprint(FILE *);\
\n    abstract_phylum copy(bool kc_copy_attributes) const;\n"), kc_current_view); }
		if(!g_options.no_unparse) 
		{
		    { kc_printer(kc_t("	void unparse(printer_functor pf, uview uv)\
\n	    \v{ do_unparse(pf, uv); }\r\
\n        void unparse(printer_function opf, uview uv);\n"), kc_current_view); }
		}
		if(!g_options.no_printdot) 
		{
		    { kc_printer(kc_t("\
\n	void printdot_add_edge (c_abstract_phylum, int, int*, kc_dotedgenode_t*, const char*) const;\
\n	void do_printdot_id (FILE*, bool, c_abstract_phylum, int) const;\
\n	void do_printdot (FILE*, bool,"), kc_current_view );
		  kc_printer(kc_t(" int*, kc_dotedgenode_t*, const char*, bool, bool, c_abstract_phylum, int) const;\
\n\
\n	virtual void fprintdot(FILE *,\
\n	const char *root_label_prefix, const char *edge_label_prefix, const char *ed"), kc_current_view );
		  kc_printer(kc_t("ge_attributes,\
\n	bool print_node_labels, bool use_context_when_sharing_leaves, bool print_prologue_and_epilogue) const =0;\
\n"), kc_current_view); }
		}
		if(!g_options.no_csgio) 
		{
		    { kc_printer(kc_t("	void CSGIOwrite(FILE *) const;\
\n"), kc_current_view); }
		}
		if(!g_options.no_rewrite) 
		{
		    if(!g_options.rw_loop) 
		    {
			{ kc_printer(kc_t("	virtual abstract_phylum rewrite(rview v) { return do_rewrite(v); }\
\n"), kc_current_view); }
		    }
		    else 
		    {
			{ kc_printer(kc_t("	abstract_phylum rewrite(rview v) {\
\n	    return rewrite_loop(v); }\
\n	abstract_phylum rewrite_loop(rview v);\
\n"), kc_current_view); }
		    }
		    { kc_printer(kc_t("	virtual abstract_phylum do_rewrite(rview) { return this;}\
\n	// called if a subphylum of an op is rewritten and a new op is created by default rule\
\n	virtual void rewrite_members(abstract_phylum fr"), kc_current_view );
		  kc_printer(kc_t("om) {} \
\n"), kc_current_view); }
		}
		if(!f_post_create_in_phylumdecl(The_abstract_phylum_decl)) 
		{
		    { kc_printer(kc_t("	virtual void post_create(){}\
\n"), kc_current_view); }
		}
		fndeclarations tapam = The_abstract_phylum_decl->additional_members; 
		kc::unparse(tapam, kc_printer, view_gen_member_dcl_h);
		kc::unparse(tapam, kc_printer, view_count_nonstaticmembers);
		if(g_options.smart_pointer) 
		{
		    if(!f_constructors_in_phylumdecl(The_abstract_phylum_decl)) 
		    {
			{ kc_printer(kc_t("	impl_abstract_phylum()"), kc_current_view); }
			if(gl_no_of_args!=0) 
			{
			    { kc_printer(kc_t(": "), kc_current_view); }
			    kc::unparse(gl_members, kc_printer, view_gen_user_assignment_inis);
			}
			{ kc_printer(kc_t("\v\
\n		{ _ref=0; }\r\
\n	    "), kc_current_view); }
		    }
		    if(!f_destructors_in_phylumdecl(The_abstract_phylum_decl)) 
		    {
			{ kc_printer(kc_t("	virtual ~impl_abstract_phylum() {\
\n	    if(_ref)\
\n		_ref->reset_phylum();\
\n	}\
\n"), kc_current_view); }
		    }
		    { kc_printer(kc_t("	impl_abstract_phylum(const impl_abstract_phylum&) {\
\n	    _ref=0;\
\n	}\
\n	abstract_phylum_ref* get_ref() const {\
\n	    return _ref;\
\n	}\
\n	abstract_phylum_ref* add_ref() {\
\n	    if(!_ref)\
\n"), kc_current_view );
		  kc_printer(kc_t("		_ref=new_phylum_ref();\
\n	    return _ref;\
\n	}\
\n	void set_ref(abstract_phylum_ref* r) {\
\n	    _ref=r;\
\n	}\
\n	virtual abstract_phylum_ref* new_phylum_ref()=0;\
\n	abstract_phylum return_ptr("), kc_current_view );
		  kc_printer(kc_t(") { if(get_ref()) get_ref()->lock(); return this; }\
\n\rprivate:\v\
\n	abstract_phylum_ref*_ref;\
\n"), kc_current_view); }
		}
		else 
		{
		    if (!f_constructors_in_phylumdecl(The_abstract_phylum_decl) && gl_no_of_args!=0) 
		    {
			{ kc_printer(kc_t("explicit impl_abstract_phylum()\v\n: "), kc_current_view); }
			kc::unparse(gl_members, kc_printer, view_gen_user_assignment_inis);
			{ kc_printer(kc_t(" { }\r\n"), kc_current_view); }
		    }
		    if(!f_destructors_in_phylumdecl(The_abstract_phylum_decl)) 
		    {
			{ kc_printer(kc_t("	virtual ~impl_abstract_phylum() { }\
\n"), kc_current_view); }
		    }
		}
		if(!g_options.no_unparse) 
		{
		    { kc_printer(kc_t("\rprivate:\v\
\n	virtual void do_unparse(printer_functor, uview) =0;\
\n\rprotected:\v\
\n	virtual void default_unparse(printer_functor, uview);\n"), kc_current_view); }
		}
		{ kc_printer(kc_t("};\n\n"), kc_current_view); }
		if(g_options.smart_pointer) 
		{
		    { kc_printer(kc_t("template <>\
\nclass phylum_ptr<impl_abstract_phylum> {\
\n\rpublic:\v\
\n"), kc_current_view); }
		    if(g_options.weak_pointer) 
		    {
			{ kc_printer(kc_t("   phylum_ptr(bool weak=false) { _ref=0; _weak=weak; }\
\n    phylum_ptr(impl_abstract_phylum* t,bool weak=false) {\
\n	_ref=0; _weak=weak;\
\n	if(t) set_ref(t->add_ref());\
\n    }\
\n    phylum_ptr(c"), kc_current_view );
		  kc_printer(kc_t("onst phylum_ptr<impl_abstract_phylum>& p, bool weak=false) {\
\n	_ref=0; _weak=weak;\
\n	set_ref(p.get_ref());\
\n    }\
\n"), kc_current_view); }
		    }
		    else 
		    {
			{ kc_printer(kc_t("   phylum_ptr() { _ref=0; }\
\n    phylum_ptr(impl_abstract_phylum* t) {\
\n	_ref=0;\
\n	if(t) set_ref(t->add_ref());\
\n    }\
\n    phylum_ptr(const phylum_ptr<impl_abstract_phylum>& p) {\
\n	_ref=0;"), kc_current_view );
		  kc_printer(kc_t("\
\n	set_ref(p.get_ref());\
\n    }\
\n"), kc_current_view); }
		    }
		    { kc_printer(kc_t("\
\n    ~phylum_ptr() { set_ref(0); }\
\n\
\n    template <typename T>\
\n    phylum_ptr<impl_abstract_phylum>& operator=(T* t) {\
\n	if(t)\
\n	    set_ref(t->add_ref());\
\n	else\
\n	    set_ref(0);\
\n"), kc_current_view );
		  kc_printer(kc_t("	return *this;\
\n    }\
\n\
\n    template <typename T>\
\n    phylum_ptr<impl_abstract_phylum>& operator=(const phylum_ptr<T>& p) {\
\n	set_ref(p.get_ref());\
\n	return *this;\
\n    }\
\n\
\n    imp"), kc_current_view );
		  kc_printer(kc_t("l_abstract_phylum* get_phylum() const {\
\n	return _ref?_ref->get_abstract_phylum():0;\
\n    }\
\n\
\n    operator impl_abstract_phylum*() const { return get_phylum(); }\
\n    impl_abstract_phylum* o"), kc_current_view );
		  kc_printer(kc_t("perator()() const { return get_phylum(); }\
\n    impl_abstract_phylum* operator->() const { return get_phylum(); }\
\n    operator bool() const { return get_phylum()!=0; }\
\n    bool operator!() cons"), kc_current_view );
		  kc_printer(kc_t("t { return get_phylum()==0; }\
\n\
\n    abstract_phylum return_ptr() { if(_ref) _ref->lock(); return get_phylum(); }\
\n\
\n    bool operator==(int null) const { return null?false:(get_phylum()==0); }"), kc_current_view );
		  kc_printer(kc_t("\
\n    template <typename T>\
\n    bool operator==(const T* t) const { return get_phylum()==t; }\
\n    template <typename T>\
\n    bool operator==(const phylum_ptr<T>& t) const { return get_phylum("), kc_current_view );
		  kc_printer(kc_t(")==t.get_phylum(); }\
\n\
\n    bool operator!=(int null) const { return null?true:(get_phylum()!=0); }\
\n    template <typename T>\
\n    bool operator!=(const T* t) const { return get_phylum()!=t; }"), kc_current_view );
		  kc_printer(kc_t("\
\n    template <typename T>\
\n    bool operator!=(const phylum_ptr<T>& t) const { return get_phylum()!=t.get_phylum(); }\
\n\
\n    abstract_phylum_ref* get_ref() const { return _ref; }\
\n\
\n\rpro"), kc_current_view );
		  kc_printer(kc_t("tected:\v\
\n"), kc_current_view); }
		    if(g_options.weak_pointer) 
		    {
			{ kc_printer(kc_t("   void set_ref(abstract_phylum_ref* r) {\
\n	if(_ref!=r) {\
\n	    if(_weak) {\
\n		if(r) r->weak_ref();\
\n		if(_ref) _ref->weak_unref();\
\n	    }\
\n	    else {\
\n		if(r) r->ref();\
\n		if(_ref) _"), kc_current_view );
		  kc_printer(kc_t("ref->unref();\
\n	    }\
\n	    _ref=r;\
\n	}\
\n    }\
\n"), kc_current_view); }
		    }
		    else 
		    {
			{ kc_printer(kc_t("   void set_ref(abstract_phylum_ref* r) {\
\n	if(_ref!=r) {\
\n	    if(r) r->ref();\
\n	    if(_ref) _ref->unref();\
\n	    _ref=r;\
\n	}\
\n    }\
\n"), kc_current_view); }
		    }
		    { kc_printer(kc_t("\
\n\rprivate:\v\
\n    abstract_phylum_ref* _ref;\
\n"), kc_current_view); }
		    if(g_options.weak_pointer) 
		    {
			{ kc_printer(kc_t("   bool _weak;\n"), kc_current_view); }
		    }
		    { kc_printer(kc_t("};\n"), kc_current_view); }
		}
		{ kc_printer(kc_t("\
\nclass "), kc_current_view); }
		if(g_options.dllexports!="") {
		    PRINT(g_options.dllexports.c_str());
		    PRINT(" ");
		} 
			{ kc_printer(kc_t("impl_abstract_list: "), kc_current_view); }

		{
		    baseclass_list kc_selvar_0_1 = phylum_cast<baseclass_list>(The_abstract_list_decl->base_classes);
		    if ((kc_selvar_0_1->prod_sel() == sel_Consbaseclass_list)) {

			UNPARSE(The_abstract_list_decl->base_classes);

		    } else
		    {
			PRINT("public impl_abstract_phylum"); 
		    }
		}

		{ kc_printer(kc_t("{\
\n\rprivate:\v\
\n    void fprint_list(FILE *);\
\n    friend class impl_abstract_phylum;\
\n\rprotected:\v\
\n    abstract_phylum do_concat(c_abstract_phylum other, enum_operators) const;\
\n    ab"), kc_current_view );
		  kc_printer(kc_t("stract_phylum do_reverse(c_abstract_phylum tail, enum_operators) const;\
\n    abstract_phylum do_map(abstract_phylum (*kc_fp)(abstract_phylum), enum_operators);\
\n    abstract_phylum do_filter(bool ("), kc_current_view );
		  kc_printer(kc_t("*kc_fp)(abstract_phylum), enum_operators);\
\n    abstract_list   do_append(abstract_phylum, abstract_list);\
\n    abstract_phylum do_merge(abstract_list,abstract_phylum (*kc_fp)(abstract_phylum,abstr"), kc_current_view );
		  kc_printer(kc_t("act_phylum), enum_operators);\
\n    abstract_phylum do_reduce(abstract_phylum neutral, abstract_phylum (*kc_fp)(abstract_phylum,abstract_phylum));\
\n\rpublic:\v\n"), kc_current_view); }
		tapam = The_abstract_list_decl->additional_members; 
		kc::unparse(tapam, kc_printer, view_count_nonstaticmembers);
		if (!f_constructors_in_phylumdecl(The_abstract_list_decl) && gl_no_of_args!=0) 
		{
		    { kc_printer(kc_t("explicit impl_abstract_list()\v\n: "), kc_current_view); }
		    kc::unparse(gl_members, kc_printer, view_gen_user_assignment_inis);
		    { kc_printer(kc_t(" { }\r\n"), kc_current_view); }
		}
		{ kc_printer(kc_t("    virtual bool is_nil() const =0;\
\n    virtual abstract_list reverse() const =0;\
\n    int length() const;\
\n    abstract_phylum last() const;\
\n    // Non-virtual, non-existing... Type must be "), kc_current_view );
		  kc_printer(kc_t("known exactly anyway because\
\n    // of the function given as a parameter\
\n    //virtual abstract_list map( abstract_phylum (*)( abstract_phylum )) =0;\
\n    //virtual abstract_list filter(bool (*"), kc_current_view );
		  kc_printer(kc_t(")(abstract_phylum)) =0;\
\n    void freelist();\
\n"), kc_current_view); }
		if(g_options.smart_pointer) 
		{
		    { kc_printer(kc_t("   impl_abstract_list* return_ptr() { if(get_ref()) get_ref()->lock(); return this; }\n"), kc_current_view); }
		}
		The_abstract_list_decl->additional_members->unparse(
		    kc_printer,view_gen_member_dcl_h); 
			{ kc_printer(kc_t("};\
\n"), kc_current_view); }
		kc::unparse(pds, kc_printer, kc_current_view);
		{ kc_printer(kc_t("\
\n//} // namespace Phylum\
\n\
\n"), kc_current_view); }
	    }
	    break;
	}
	case view_gen_classdecls1_h_enum: {
	    view_gen_classdecls1_h_class& kc_current_view=static_cast<view_gen_classdecls1_h_class&>(kc_current_view_base);
	    {
		const phylumdeclarations pds = this->phylumdeclarations_1;
		{ kc_printer(kc_t("\
\nclass impl_abstract_phylum;\
\ntypedef impl_abstract_phylum * abstract_phylum;\
\ntypedef const impl_abstract_phylum * c_abstract_phylum;\
\nclass impl_abstract_list;\
\ntypedef impl_abstract_list "), kc_current_view );
		  kc_printer(kc_t("* abstract_list;\
\ntypedef const impl_abstract_list * c_abstract_list;\
\n"), kc_current_view); }
		if(g_options.smart_pointer) 
		{
		    { kc_printer(kc_t("\
\n// Reference to a phylum (abstract base class)\
\nclass abstract_phylum_ref {\
\n\rprotected:\v\
\n    abstract_phylum_ref() {\
\n	_locked=false;\
\n	_ref_count=0;\
\n"), kc_current_view); }
		    if(g_options.weak_pointer) 
		    {
			{ kc_printer(kc_t("	_weak_ref_count=0;\
\n"), kc_current_view); }
		    }
		    { kc_printer(kc_t("   }\
\n\
\n\rpublic:\v\
\n    void lock() {\
\n	_locked=true;\
\n    }\
\n    void unlock() {\
\n	if(_locked) {\
\n	    _locked=false;\
\n	    if(_ref_count==0 "), kc_current_view); }
		    if(g_options.weak_pointer) 
		    {
			{ kc_printer(kc_t("&& _weak_ref_count==0"), kc_current_view); }
		    }
		    { kc_printer(kc_t(") {\
\n		reset_ref();\
\n		reset_phylum();\
\n		delete this;\
\n	    }\
\n	}\
\n    }\
\n    int get_ref_count() const {\
\n	return _ref_count;\
\n    }\
\n    void ref() {\
\n	_locked=false;\
\n	++_re"), kc_current_view );
		  kc_printer(kc_t("f_count;\
\n    }\
\n    void unref() {\
\n	if(_ref_count)\
\n	    --_ref_count;\
\n	if(_ref_count==0 && !_locked) {\
\n	    clear();\
\n"), kc_current_view); }
		    if(g_options.weak_pointer) 
		    {
			{ kc_printer(kc_t("	     if(_weak_ref_count==0)\
\n"), kc_current_view); }
		    }
		    { kc_printer(kc_t("		delete this;\
\n	}\
\n    }\
\n"), kc_current_view); }
		    if(g_options.weak_pointer) 
		    {
			{ kc_printer(kc_t("   int get_weak_ref_count() const {\
\n	return _weak_ref_count;\
\n    }\
\n    void weak_ref()  {\
\n	_locked=false;\
\n	++_weak_ref_count;\
\n    }\
\n    void weak_unref() {\
\n	if(_weak_ref_count)\
\n"), kc_current_view );
		  kc_printer(kc_t("	    --_weak_ref_count;\
\n	if(_weak_ref_count==0 && _ref_count==0 && !_locked) {\
\n	    reset_ref();\
\n	    delete this;\
\n	}\
\n    }\
\n"), kc_current_view); }
		    }
		    { kc_printer(kc_t("\
\n    virtual impl_abstract_phylum* get_abstract_phylum() const=0;\
\n    virtual void reset_phylum()=0;\
\n"), kc_current_view); }
		    The_abstract_phylum_ref_decl->additional_members->unparse(
			kc_printer,view_gen_member_dcl_h); 
		    	{ kc_printer(kc_t("\rprotected:\v\
\n    virtual void clear()=0;\
\n    virtual void reset_ref()=0;\
\n\rprivate:\v\
\n    int _ref_count;\
\n"), kc_current_view); }
		    if(g_options.weak_pointer) 
		    {
			{ kc_printer(kc_t("   int _weak_ref_count;\
\n"), kc_current_view); }
		    }
		    { kc_printer(kc_t("   bool _locked;\
\n};\n"), kc_current_view); }
		    { kc_printer(kc_t("// Template reference for each phylum\
\ntemplate <typename T>\
\nclass phylum_ref: public abstract_phylum_ref {\
\n\rpublic:\v\
\n    phylum_ref(T* t) { _phylum=t; }\
\n\
\n    T* get_phylum() const {"), kc_current_view );
		  kc_printer(kc_t(" return _phylum; }\
\n    impl_abstract_phylum* get_abstract_phylum() const { return _phylum; }\
\n\
\n    phylum_ref<T>& operator=(const T& t) {\
\n	abstract_phylum_ref* ref=t.get_ref();\
\n	if(ref)\
\n"), kc_current_view );
		  kc_printer(kc_t("	    set_phylum(static_cast<T*>(t.copy(true)));\
\n	else\
\n	    set_phylum(const_cast<T*>(&t));\
\n	return *this;\
\n    }\
\n    phylum_ref<T>& operator=(const phylum_ref<T>& r) {\
\n	T* t=r.get_phyl"), kc_current_view );
		  kc_printer(kc_t("um();\
\n	if(t) return operator=(*t);\
\n	set_phylum(0);\
\n	return *this;\
\n    }\
\n\
\n    void reset_phylum() { _phylum=0; }\
\n    void set_phylum(T* t) {\
\n	if(_phylum!=t) {\
\n	    _phylum->se"), kc_current_view );
		  kc_printer(kc_t("t_ref(0);\
\n	    _phylum->free();\
\n	    _phylum=t;\
\n	    if(_phylum)\
\n		_phylum->set_ref(this);\
\n	}\
\n    }\
\n\rprotected:\v\
\n    void clear() { if(_phylum) { reset_ref(); _phylum->free();"), kc_current_view );
		  kc_printer(kc_t(" _phylum=0; } }\
\n    void reset_ref() { if(_phylum) _phylum->set_ref(0); }\
\n\rprivate:\v\
\n    T* _phylum;\
\n};\n"), kc_current_view); }
		    { kc_printer(kc_t("// Smart pointer containing a reference\
\ntemplate <typename T>\
\nclass phylum_ptr {\
\n\rpublic:\v\
\n"), kc_current_view); }
		    if(g_options.weak_pointer) 
		    {
			{ kc_printer(kc_t("   phylum_ptr(bool weak=false) { _ref=0; _weak=weak; }\
\n    phylum_ptr(T* t,bool weak=false) {\
\n	_ref=0; _weak=weak;\
\n	if(t) set_ref(static_cast<phylum_ref<T>*>(t->add_ref()));\
\n    }\
\n    ph"), kc_current_view );
		  kc_printer(kc_t("ylum_ptr(const phylum_ptr<T>& p, bool weak=false) {\
\n	_ref=0; _weak=weak;\
\n	set_ref(p.get_ref());\
\n    }\
\n"), kc_current_view); }
		    }
		    else 
		    {
			{ kc_printer(kc_t("   phylum_ptr() { _ref=0; }\
\n    phylum_ptr(T* t) {\
\n	_ref=0;\
\n	if(t) set_ref(static_cast<phylum_ref<T>*>(t->add_ref()));\
\n    }\
\n    phylum_ptr(const phylum_ptr<T>& p) {\
\n	_ref=0;\
\n	set_"), kc_current_view );
		  kc_printer(kc_t("ref(p.get_ref());\
\n    }\
\n"), kc_current_view); }
		    }
		    { kc_printer(kc_t("   ~phylum_ptr() { set_ref(0); }\
\n\
\n    phylum_ptr<T>& operator=(T* t) {\
\n	if(t)\
\n	    set_ref(static_cast<phylum_ref<T>*>(t->add_ref()));\
\n	else\
\n	    set_ref(0);\
\n	return *this;\
\n    "), kc_current_view );
		  kc_printer(kc_t("}\
\n\
\n    phylum_ptr<T>& operator=(const phylum_ptr<T>& p) {\
\n	set_ref(p.get_ref());\
\n	return *this;\
\n    }\
\n\
\n    T* get_phylum() const { return _ref?_ref->get_phylum():0; }\
\n\
\n    op"), kc_current_view );
		  kc_printer(kc_t("erator T*() const { return get_phylum(); }\
\n    T* operator()() const { return get_phylum(); }\
\n    T* operator->() const { return get_phylum(); }\
\n    operator bool() const { return get_phylum()"), kc_current_view );
		  kc_printer(kc_t("!=0; }\
\n    bool operator!() const { return get_phylum()==0; }\
\n\
\n    T* return_ptr() const { if(_ref) _ref->lock(); return get_phylum(); }\
\n\
\n    bool operator==(int null) const { return nul"), kc_current_view );
		  kc_printer(kc_t("l?false:(get_phylum()==0); }\
\n    bool operator==(const T* t) const { return get_phylum()==t; }\
\n    bool operator==(const phylum_ptr<T>& t) const { return get_phylum()==t.get_phylum(); }\
\n    bo"), kc_current_view );
		  kc_printer(kc_t("ol operator!=(int null) const { return null?true:(get_phylum()!=0); }\
\n    bool operator!=(const T* t) const { return get_phylum()!=t; }\
\n    bool operator!=(const phylum_ptr<T>& t) const { return "), kc_current_view );
		  kc_printer(kc_t("get_phylum()!=t.get_phylum(); }\
\n\
\n    phylum_ref<T>& operator*(){ return *add_ref(); }\
\n    const phylum_ref<T>& operator*() const {\
\n	return *const_cast<phylum_ptr<T>*>(this)->add_ref();\
\n "), kc_current_view );
		  kc_printer(kc_t("   }\
\n\
\n    phylum_ref<T>* get_ref() const { return _ref; }\
\n\
\n    phylum_ref<T>* add_ref() {\
\n	if(!_ref) set_ref(new phylum_ref<T>(0));\
\n	return _ref;\
\n    }\
\n\rprotected:\v\
\n"), kc_current_view); }
		    if(g_options.weak_pointer) 
		    {
			{ kc_printer(kc_t("   void set_ref(phylum_ref<T>* r) {\
\n	if(_ref!=r) {\
\n	    if(_weak) {\
\n		if(r) r->weak_ref();\
\n		if(_ref) _ref->weak_unref();\
\n	    }\
\n	    else {\
\n		if(r) r->ref();\
\n		if(_ref) _ref->u"), kc_current_view );
		  kc_printer(kc_t("nref();\
\n	    }\
\n	    _ref=r;\
\n	}\
\n    }\
\n"), kc_current_view); }
		    }
		    else 
		    {
			{ kc_printer(kc_t("   void set_ref(phylum_ref<T>* r) {\
\n	if(_ref!=r) {\
\n	    if(r) r->ref();\
\n	    if(_ref) _ref->unref();\
\n	    _ref=r;\
\n	}\
\n    }\
\n"), kc_current_view); }
		    }
		    { kc_printer(kc_t("\
\n\rprivate:\v\
\n    phylum_ref<T>* _ref;\
\n"), kc_current_view); }
		    if(g_options.weak_pointer) 
		    {
			{ kc_printer(kc_t("   bool _weak;\
\n"), kc_current_view); }
		    }
		    { kc_printer(kc_t("};\
\ntypedef phylum_ptr<impl_abstract_phylum> abstract_phylum_ptr;\
\n"), kc_current_view); }
		    if(g_options.weak_pointer) 
		    {
			{ kc_printer(kc_t("\
\ntemplate <typename T>\
\nclass weak_phylum_ptr: public phylum_ptr<T> {\
\n\rpublic:\v\
\n    weak_phylum_ptr(): phylum_ptr<T>(true){}\
\n    weak_phylum_ptr(T* t):phylum_ptr<T>(t,true){}\
\n    wea"), kc_current_view );
		  kc_printer(kc_t("k_phylum_ptr(const weak_phylum_ptr<T>& p):phylum_ptr<T>(p,true){}\
\n    weak_phylum_ptr(const phylum_ptr<T>& p):phylum_ptr<T>(p,true){}\
\n\
\n    weak_phylum_ptr<T>& operator=(T* t) {\
\n	if(t)\
\n	 "), kc_current_view );
		  kc_printer(kc_t("   set_ref(static_cast<phylum_ref<T>*>(t->add_ref()));\
\n	else\
\n	    set_ref(0);\
\n	return *this;\
\n    }\
\n\
\n    weak_phylum_ptr<T>& operator=(const phylum_ptr<T>& p) {\
\n	set_ref(p.get_ref()"), kc_current_view );
		  kc_printer(kc_t(");\
\n	return *this;\
\n    }\
\n};\
\ntypedef weak_phylum_ptr<impl_abstract_phylum> weak_abstract_phylum_ptr;\
\n"), kc_current_view); }
		    }
		    { kc_printer(kc_t("\
\ntemplate <typename P, typename T>\
\nP phylum_cast(phylum_ptr<T>& t) {\
\n    return static_cast<P>(t());\
\n}\
\ntemplate <typename P, typename T>\
\nconst P phylum_cast(const phylum_ptr<T>& t) {\
\n"), kc_current_view );
		  kc_printer(kc_t("    return static_cast<const P>(t());\
\n}\
\n"), kc_current_view); }
		}
		{ kc_printer(kc_t("\
\ntemplate <typename P, typename T>\
\nP phylum_cast(T* t) {\
\n    return static_cast<P>(t);\
\n}\
\ntemplate <typename P, typename T>\
\nconst P phylum_cast(const T* t) {\
\n    return static_cast<"), kc_current_view );
		  kc_printer(kc_t("const P>(t);\
\n}\
\n"), kc_current_view); }
		kc::unparse(pds, kc_printer, kc_current_view);
		{ kc_printer(kc_t("\
\n\
\nvoid kc_invalid_operator( const char *kc_func_prefix, enum_phyla kc_phy, int kc_line,\
\n	const char *kc_file, enum_operators kc_oper ) __attribute__ ((noreturn));\
\n\
\ntypedef enum_phyla *en"), kc_current_view );
		  kc_printer(kc_t("um_phyla_list;\
\n\
\n/*\
\n * make sure that the first 'real' storage class _always_ gets a value > 0\
\n * and kc_not_uniq gets a value == 0\
\n * (because then we can use it as a C boolean)\
\n */\
\n"), kc_current_view );
		  kc_printer(kc_t("enum kc_storageclass_t {\
\n	"), kc_current_view); }
		kc::unparse(Thestorageclasses, kc_printer, view_gen_operatormap_type_h);
		{ kc_printer(kc_t(",\
\nlast_storageclass\
\n};\
\n\
\ntypedef struct {\
\n    const char *name;			// name of the phylum\
\n    enum_operators first_operator;	// index in operator_info[]\
\n    enum_operators last_operat"), kc_current_view );
		  kc_printer(kc_t("or;	// index in operator_info[]\
\n    kc_storageclass_t uniq_stored;	// storage class\
\n} KC_PHYLUM_INFO;\
\n\
\ntypedef struct {\
\n    const char *name;			// name of the operator\
\n    size_t no_s"), kc_current_view );
		  kc_printer(kc_t("ons;			// number of sons\
\n    bool atomicity;			// atomic type or not\
\n    enum_phyla phylum;			// index in phylum_info[]\
\n    enum_phyla_list subphylum;		// indexes in phylum_info[]\
\n    int n"), kc_current_view );
		  kc_printer(kc_t("o_attrs;			// number of attributes\
\n    enum_phyla_list attribute;		// indexes in phylum_info[]\
\n    size_t size;			// size of operator (for statistics)\
\n} KC_OPERATOR_INFO;\
\n\
\ntypedef enum_p"), kc_current_view );
		  kc_printer(kc_t("hyla_list KC_UNIQ_INFO;\
\n\
\nextern KC_OPERATOR_INFO operator_info[];\
\nextern KC_PHYLUM_INFO phylum_info[];\
\nextern KC_UNIQ_INFO kc_UniqInfo[];\
\n\
\n#define KC_OP_NAME(op) (operator_info[op].na"), kc_current_view );
		  kc_printer(kc_t("me)\
\n#define KC_NO_SONS(prod) (operator_info[prod].no_sons)\
\n#define KC_ATOMICITY(prod) (operator_info[prod].atomicity)\
\n\
\n"), kc_current_view); }
	    }
	    break;
	}
	case view_gen_unparsedefs_c_enum: {
	    view_gen_unparsedefs_c_class& kc_current_view=static_cast<view_gen_unparsedefs_c_class&>(kc_current_view_base);
	    {
		const phylumdeclarations pds = this->phylumdeclarations_1;
		kc::unparse(pds, kc_printer, kc_current_view);
	    }
	    break;
	}
	case view_gen_default_types_unpk_c_enum: {
	    view_gen_default_types_unpk_c_class& kc_current_view=static_cast<view_gen_default_types_unpk_c_class&>(kc_current_view_base);
	    {
		{ kc_printer(kc_t("\
\n#ifndef KC_TRACE_PROVIDED\
\n#define KC_TRACE_PROVIDED(COND,FILE,LINE,NODE) COND\
\n#endif\
\n\
\nvoid\
\nimpl_abstract_phylum::unparse(printer_function opf, uview uv)\
\n{\
\n    printer_functor_f"), kc_current_view );
		  kc_printer(kc_t("unction_wrapper pf(opf);\
\n    do_unparse(pf, uv);\
\n}\
\n\
\n// Everything given as a pointer is expected to have an unparse-method (we\
\n// believe it's a phylum), unless there's a specialisation "), kc_current_view );
		  kc_printer(kc_t("for it\
\n\
\nvoid\
\nunparse(abstract_phylum kc_p, printer_functor kc_printer, uview kc_current_view)\
\n{\
\n    kc_p->unparse(kc_printer, kc_current_view);\
\n}\
\n\
\nvoid\
\nunparse(void *kc_p, pr"), kc_current_view );
		  kc_printer(kc_t("inter_functor kc_printer, uview kc_current_view)\
\n{\
\n    // MPi: 20020628 there shouldn't be any left\
\n    assertionFailed(\"Unparse called for untyped pointer\");\
\n    // MPi: cast should be u"), kc_current_view );
		  kc_printer(kc_t("nnecessary, but there are still void*\
\n    reinterpret_cast<impl_abstract_phylum*>(kc_p)->unparse(kc_printer, kc_current_view);\
\n}\
\n\
\nvoid\
\nunparse(int kc_v, printer_functor kc_printer, uview"), kc_current_view );
		  kc_printer(kc_t(" kc_current_view)\
\n{\
\n    kc_char_t kc_string[200];\
\n    kc_print_integer(kc_string, kc_v);\
\n    kc_printer(kc_string, kc_current_view);\
\n}\
\n\
\nvoid\
\nunparse(double kc_v, printer_functor"), kc_current_view );
		  kc_printer(kc_t(" kc_printer, uview kc_current_view)\
\n{\
\n    kc_char_t kc_string[200];\
\n    kc_print_real(kc_string, kc_v);\
\n    kc_printer(kc_string, kc_current_view);\
\n}\
\n\
\nvoid\
\nunparse(kc_char_t *kc"), kc_current_view );
		  kc_printer(kc_t("_v, printer_functor kc_printer, uview kc_current_view)\
\n{\
\n    kc_printer(kc_v, kc_current_view);\
\n}\
\n\
\nvoid\
\nunparse(kc_string_t kc_v, printer_functor kc_printer, uview kc_current_view)\
\n"), kc_current_view );
		  kc_printer(kc_t("{\
\n    kc_printer(kc_v.c_str(), kc_current_view);\
\n}\
\n"), kc_current_view); }
		kc::unparse(g_emptystring, kc_printer, view_printer_outputfileline);
		assertReason(!g_options.no_unparse, "shouldn't create unpk.cc when not even generating unparse stuff");  
		 if (!g_options.no_unparse) 
		{
		    { kc_printer(kc_t("void\
\nimpl_abstract_phylum::default_unparse(printer_functor kc_printer, uview kc_current_view)\
\n{\
\n    register int no_sons = operator_info[prod_sel()].no_sons;\
\n    for (int i=0; i < no_sons; "), kc_current_view );
		  kc_printer(kc_t("i++)\
\n	subphylum(i)->unparse(kc_printer, kc_current_view);\
\n}\
\n\
\nvoid\
\nimpl_casestring__Str::do_unparse(printer_functor kc_printer, uview kc_current_view)\
\n{\
\n    kc::unparse(name, kc_pri"), kc_current_view );
		  kc_printer(kc_t("nter, kc_current_view);\
\n}\
\n\
\nvoid\
\nimpl_nocasestring_NoCaseStr::do_unparse(printer_functor kc_printer, uview kc_current_view)\
\n{\
\n    kc::unparse(name, kc_printer, kc_current_view);\
\n}\
\n"), kc_current_view );
		  kc_printer(kc_t("\
\nvoid\
\nimpl_integer__Int::do_unparse(printer_functor kc_printer, uview kc_current_view)\
\n{\
\n    kc::unparse(value, kc_printer, kc_current_view);\
\n}\
\n\
\nvoid\
\nimpl_real__Real::do_unparse"), kc_current_view );
		  kc_printer(kc_t("(printer_functor kc_printer, uview kc_current_view)\
\n{\
\n    kc::unparse(value, kc_printer, kc_current_view);\
\n}\
\n\
\nvoid\
\nimpl_voidptr__VoidPtr::do_unparse(printer_functor kc_printer, uview "), kc_current_view );
		  kc_printer(kc_t("kc_current_view)\
\n{\
\n    kc::unparse(pointer, kc_printer, kc_current_view);\
\n}\
\n\
\n"), kc_current_view); }
		}
	    }
	    break;
	}
	case view_gen_unpk_c_enum: {
	    view_gen_unpk_c_class& kc_current_view=static_cast<view_gen_unpk_c_class&>(kc_current_view_base);
	    {
		{ kc_printer(kc_t("/* translation of file(s)\n"), kc_current_view); }
		kc::unparse(Thefnfiles, kc_printer, kc_current_view);
		{ kc_printer(kc_t(" */\
\n/* generated by:\
\n *  "), kc_current_view); }
		kc::unparse(kimwitu_copyright, kc_printer, kc_current_view);
		{ kc_printer(kc_t("\
\n */\
\n#define KC_UNPARSE\
\n"), kc_current_view); }
		if(g_options.stdafx!="") {
		    PRINT("#include \"");
		    PRINT(g_options.stdafx.c_str());
		    PRINT("\"\n");
		}	
			{ kc_printer(kc_t("\
\n#include <stdio.h>\
\n#include <string>\
\n#include <stdlib.h>\
\n#include \""), kc_current_view); }
		PRINT(g_options.prefix.c_str()); 
			{ kc_printer(kc_t("k.h\"\
\n#include \""), kc_current_view); }
		PRINT(g_options.prefix.c_str()); 
			{ kc_printer(kc_t("unpk.h\"\
\n\
\n"), kc_current_view); }
		kc::unparse(this, kc_printer, view_open_namespace);
		kc::unparse(Theuviewnames, kc_printer, view_gen_viewvars_c);
		{ kc_printer(kc_t("\
\nimpl_uviews uviews[] = {\
\n"), kc_current_view); }
		kc::unparse(Theuviewnames, kc_printer, kc_current_view);
		{ kc_printer(kc_t("	{0,0}\
\n};\
\n"), kc_current_view); }
		if(pg_languageshavebeendefined) 
		{
		    { kc_printer(kc_t("\n"), kc_current_view); }
		    { kc_printer(kc_t("#ifndef LANG_TEXT\n"), kc_current_view); }
		    { kc_printer(kc_t("#define LANG_TEXT(i) kc_language[i]\n"), kc_current_view); }
		    { kc_printer(kc_t("#endif\n\n"), kc_current_view); }
		}
	    }
	    break;
	}
	case view_gen_end_unpk_h_enum: {
	    view_gen_end_unpk_h_class& kc_current_view=static_cast<view_gen_end_unpk_h_class&>(kc_current_view_base);
	    {
		{ kc_printer(kc_t("#endif // KC_UNPARSE_HEADER\
\n"), kc_current_view); }
	    }
	    break;
	}
	case view_gen_rewritedecls_h_enum: {
	    view_gen_rewritedecls_h_class& kc_current_view=static_cast<view_gen_rewritedecls_h_class&>(kc_current_view_base);
	    {
		const phylumdeclarations pds = this->phylumdeclarations_1;
		{ kc_printer(kc_t("\
\n/* Use rviews instead\
\nextern char *kc_rview_names[];\
\n*/\
\n"), kc_current_view); }
		kc::unparse(Therviewnames, kc_printer, view_rview_class_def);
	    }
	    break;
	}
	case view_gen_unparsedecls_h_enum: {
	    view_gen_unparsedecls_h_class& kc_current_view=static_cast<view_gen_unparsedecls_h_class&>(kc_current_view_base);
	    {
		const phylumdeclarations pds = this->phylumdeclarations_1;
		if(pg_languageshavebeendefined) 
		{
		    { kc_printer(kc_t("\n"), kc_current_view); }
		    { kc_printer(kc_t("#ifndef is_language\n"), kc_current_view); }
		    { kc_printer(kc_t("#define is_language(L) kc_language==kc_language_##L\n"), kc_current_view); }
		    { kc_printer(kc_t("#endif\n\n"), kc_current_view); }
		    { kc_printer(kc_t("#ifndef set_language\n"), kc_current_view); }
		    { kc_printer(kc_t("#define set_language(L) kc_language=kc_language_##L\n"), kc_current_view); }
		    { kc_printer(kc_t("#endif\n\n"), kc_current_view); }
		    { kc_printer(kc_t("extern char** kc_language;\n"), kc_current_view); }
		    kc::unparse(Thelanguages, kc_printer, kc_current_view);
		}
		{ kc_printer(kc_t("\
\n/* Use uviews instead\
\nextern char *kc_view_names[];\
\n*/\
\n"), kc_current_view); }
		kc::unparse(Theuviewnames, kc_printer, view_uview_class_def);
		{ kc_printer(kc_t("\
\nvoid unparse(abstract_phylum kc_p, printer_functor kc_printer, uview kc_current_view);\
\nvoid unparse(void *kc_p, printer_functor kc_printer, uview kc_current_view);\
\nvoid unparse(int kc_v, prin"), kc_current_view );
		  kc_printer(kc_t("ter_functor kc_printer, uview kc_current_view);\
\nvoid unparse(double kc_v, printer_functor kc_printer, uview kc_current_view);\
\nvoid unparse(kc_char_t *kc_v, printer_functor kc_printer, uview kc_cu"), kc_current_view );
		  kc_printer(kc_t("rrent_view);\
\nvoid unparse(kc_string_t kc_v, printer_functor kc_printer, uview kc_current_view);\
\n#define PRINT(string) kc_printer(string,kc_current_view)\
\n#define UNPARSE(node) node->unparse(kc_"), kc_current_view );
		  kc_printer(kc_t("printer,kc_current_view)\
\n"), kc_current_view); }
	    }
	    break;
	}
	case view_gen_unpk_h_enum: {
	    view_gen_unpk_h_class& kc_current_view=static_cast<view_gen_unpk_h_class&>(kc_current_view_base);
	    {
		{ kc_printer(kc_t("/* translation of file(s)\n"), kc_current_view); }
		kc::unparse(Thefnfiles, kc_printer, kc_current_view);
		{ kc_printer(kc_t(" */\
\n/* generated by:\
\n *  "), kc_current_view); }
		kc::unparse(kimwitu_copyright, kc_printer, kc_current_view);
		{ kc_printer(kc_t("\
\n */\
\n#ifndef KC_UNPARSE_HEADER\
\n#define KC_UNPARSE_HEADER\
\n\
\n"), kc_current_view); }
	    }
	    break;
	}
	case view_gen_fns_owninclude_c_enum: {
	    view_gen_fns_owninclude_c_class& kc_current_view=static_cast<view_gen_fns_owninclude_c_class&>(kc_current_view_base);
	    {
		{ kc_printer(kc_t("#include \""), kc_current_view); }
		PRINT(g_options.hfilename.c_str()); 
			{ kc_printer(kc_t("\"\
\n"), kc_current_view); }
	    }
	    break;
	}
	case view_gen_fns_start_c_enum: {
	    view_gen_fns_start_c_class& kc_current_view=static_cast<view_gen_fns_start_c_class&>(kc_current_view_base);
	    {
		char *printablefilename = f_make_identifier_basename( g_options.ccfilename.c_str() ); 
			{ kc_printer(kc_t("/* translation of file \""), kc_current_view); }
		kc::unparse(pg_filename, kc_printer, kc_current_view);
		{ kc_printer(kc_t("\" */\
\n/* generated by:\
\n *  "), kc_current_view); }
		kc::unparse(kimwitu_copyright, kc_printer, kc_current_view);
		{ kc_printer(kc_t("\
\n */\
\n#define KC_FUNCTIONS_"), kc_current_view); }
		kc::unparse(printablefilename, kc_printer, kc_current_view);
		{ kc_printer(kc_t("\
\n"), kc_current_view); }
		if(g_options.stdafx!="") {
		    PRINT("#include \"");
		    PRINT(g_options.stdafx.c_str());
		    PRINT("\"\n");
		}	
			{ kc_printer(kc_t("\
\n#include <stdlib.h>\
\n#include \""), kc_current_view); }
		PRINT(g_options.prefix.c_str()); 
			{ kc_printer(kc_t("k.h\"\
\n"), kc_current_view); }
		delete[] printablefilename; 
	    }
	    break;
	}
	case view_gen_fns_end_h_enum: {
	    view_gen_fns_end_h_class& kc_current_view=static_cast<view_gen_fns_end_h_class&>(kc_current_view_base);
	    {
		char *printablefilename = f_make_identifier_basename( g_options.hfilename.c_str() ); 
			{ kc_printer(kc_t("\
\n#endif // !  KC_FUNCTIONS_"), kc_current_view); }
		kc::unparse(printablefilename, kc_printer, kc_current_view);
		{ kc_printer(kc_t("_HEADER\
\n\
\n"), kc_current_view); }
		delete[] printablefilename; 
	    }
	    break;
	}
	case view_gen_fns_start_h_enum: {
	    view_gen_fns_start_h_class& kc_current_view=static_cast<view_gen_fns_start_h_class&>(kc_current_view_base);
	    {
		char *printablefilename = f_make_identifier_basename( g_options.hfilename.c_str() ); 
			{ kc_printer(kc_t("/* translation of file \""), kc_current_view); }
		kc::unparse(pg_filename, kc_printer, kc_current_view);
		{ kc_printer(kc_t("\" */\
\n/* generated by:\
\n *  "), kc_current_view); }
		kc::unparse(kimwitu_copyright, kc_printer, kc_current_view);
		{ kc_printer(kc_t("\
\n */\
\n#ifndef KC_FUNCTIONS_"), kc_current_view); }
		kc::unparse(printablefilename, kc_printer, kc_current_view);
		{ kc_printer(kc_t("_HEADER\
\n#define KC_FUNCTIONS_"), kc_current_view); }
		kc::unparse(printablefilename, kc_printer, kc_current_view);
		{ kc_printer(kc_t("_HEADER\
\n#include \""), kc_current_view); }
		PRINT(g_options.prefix.c_str()); 
			{ kc_printer(kc_t("k.h\"    // in case a user forgets\
\n\
\n"), kc_current_view); }
		delete[] printablefilename; 
	    }
	    break;
	}
	case view_gen_rewritedefs_c_enum: {
	    view_gen_rewritedefs_c_class& kc_current_view=static_cast<view_gen_rewritedefs_c_class&>(kc_current_view_base);
	    {
		const phylumdeclarations pds = this->phylumdeclarations_1;
		{ kc_printer(kc_t("\
\n#ifndef KC_TRACE_PROVIDED\
\n#define KC_TRACE_PROVIDED(COND,FILE,LINE,NODE) COND\
\n#endif\
\n#ifndef KC_TRACE_REWRITE_MATCH\
\n#define KC_TRACE_REWRITE_MATCH(VIEW,FILE,LINE,NODE)\
\n#endif\
\n#ifn"), kc_current_view );
		  kc_printer(kc_t("def KC_TRACE_REWRITE_RESULT\
\n#define KC_TRACE_REWRITE_RESULT(VIEW,FILE,LINE,NODE)\
\n#endif\
\n	"), kc_current_view); }
		kc::unparse(pds, kc_printer, kc_current_view);
	    }
	    break;
	}
	case view_gen_rewritek_c_enum: {
	    view_gen_rewritek_c_class& kc_current_view=static_cast<view_gen_rewritek_c_class&>(kc_current_view_base);
	    {
		{ kc_printer(kc_t("/* translation of file(s)\n"), kc_current_view); }
		kc::unparse(Thefnfiles, kc_printer, kc_current_view);
		{ kc_printer(kc_t(" */\
\n/* generated by:\
\n *  "), kc_current_view); }
		kc::unparse(kimwitu_copyright, kc_printer, kc_current_view);
		{ kc_printer(kc_t("\
\n */\
\n#define KC_REWRITE\
\n"), kc_current_view); }
		if(g_options.stdafx!="") {
		    PRINT("#include \"");
		    PRINT(g_options.stdafx.c_str());
		    PRINT("\"\n");
		}   
			{ kc_printer(kc_t("\
\n#include <stdio.h>\
\n#include <sys/types.h>\
\n#include <stdlib.h>\
\n#include \""), kc_current_view); }
		PRINT(g_options.prefix.c_str()); 
			{ kc_printer(kc_t("k.h\"\
\n#include \""), kc_current_view); }
		PRINT(g_options.prefix.c_str()); 
			{ kc_printer(kc_t("rk.h\"\
\n\
\n"), kc_current_view); }
		if(g_options.rw_loop) 
		{
		    { kc_printer(kc_t("#include <deque>\
\n#include <stack>\
\n#include <vector>\
\n"), kc_current_view); }
		}
		kc::unparse(this, kc_printer, view_open_namespace);
		kc::unparse(Therviewnames, kc_printer, view_gen_viewvars_c);
		{ kc_printer(kc_t("\
\nimpl_rviews rviews[] = {\
\n"), kc_current_view); }
		kc::unparse(Therviewnames, kc_printer, kc_current_view);
		{ kc_printer(kc_t("	{0,0}\
\n};\
\n"), kc_current_view); }
		if(g_options.rw_loop) 
		{
		    string how_smart = "";
		    if(g_options.smart_pointer) how_smart="_ptr"; 
		    	{ kc_printer(kc_t("\
\n\
\nstatic inline int\
\nkc_sons(abstract_phylum ph) {\
\n    return KC_NO_SONS(ph->prod_sel());\
\n}\
\n\
\nstatic abstract_phylum\
\nkc_create_op(enum_operators kc_op, std::vector<abstract_phylum"), kc_current_view); }
		    kc::unparse(how_smart, kc_printer, kc_current_view);
		    { kc_printer(kc_t(">& sons, size_t no_of_sons) {\
\n    size_t son_offset = sons.size()-no_of_sons;\
\n    switch(no_of_sons) {\n"), kc_current_view); }
		    kc::unparse(Theargsnumbers, kc_printer, kc_current_view);
		    { kc_printer(kc_t("   default:\v\
\n	assertionFailed(\"unexpected number of sub-phyla\");\r\
\n    }\r\
\n}\
\n\
\nstatic void\
\ninitialize_sons_stack(abstract_phylum"), kc_current_view); }
		    kc::unparse(how_smart, kc_printer, kc_current_view);
		    { kc_printer(kc_t("& kc_p, bool& skip,\
\n	std::stack<abstract_phylum"), kc_current_view); }
		    kc::unparse(how_smart, kc_printer, kc_current_view);
		    { kc_printer(kc_t(">& node_stack, std::stack<int>& sons_todo,\
\n	rview kc_current_view_base)\
\n{\
\n    // Initialize stack for depth first rewrite\
\n    assertCond(kc_p);\
\n    size_t no_of_sons=kc_sons(kc_p);\
\n "), kc_current_view );
		  kc_printer(kc_t("   while(!skip && (no_of_sons>0)) {\
\n	sons_todo.push(no_of_sons);\
\n	abstract_phylum parent = kc_p;\
\n	for(int i = no_of_sons-1; i>=0; --i) {\
\n	    node_stack.push(kc_p);\
\n	    kc_p = parent->s"), kc_current_view );
		  kc_printer(kc_t("ubphylum(i);\
\n	}\
\n	kc_p = kc_current_view_base.pre_rewrite(kc_p, skip);\
\n	assertCond(kc_p);\
\n	no_of_sons = kc_sons(kc_p);\
\n    }\
\n    // The deepest first son is now in kc_p.\
\n    // On t"), kc_current_view );
		  kc_printer(kc_t("he node_stack are the siblings and then the parent.\
\n}\
\n\
\nstatic bool\
\nsons_changed(abstract_phylum"), kc_current_view); }
		    kc::unparse(how_smart, kc_printer, kc_current_view);
		    { kc_printer(kc_t(" current_son, const std::vector<abstract_phylum"), kc_current_view); }
		    kc::unparse(how_smart, kc_printer, kc_current_view);
		    { kc_printer(kc_t(">& sons_done, size_t no_of_sons)\
\n{\
\n    bool changed = false;\
\n    for(int i=no_of_sons-1; i>=0; --i) {\
\n	if(sons_done[sons_done.size()-no_of_sons+i] != current_son->subphylum(i)) {\
\n	    ch"), kc_current_view );
		  kc_printer(kc_t("anged=true;\
\n	    break;\
\n	}\
\n    }\
\n    return changed;\
\n}\
\n\
\nabstract_phylum impl_abstract_phylum::rewrite_loop(rview kc_current_view_base) {\
\n    std::stack<abstract_phylum"), kc_current_view); }
		    kc::unparse(how_smart, kc_printer, kc_current_view);
		    { kc_printer(kc_t("> node_stack;\
\n    std::stack<int> sons_todo;\
\n    std::vector<abstract_phylum"), kc_current_view); }
		    kc::unparse(how_smart, kc_printer, kc_current_view);
		    { kc_printer(kc_t("> sons_done;\
\n\
\n    abstract_phylum"), kc_current_view); }
		    kc::unparse(how_smart, kc_printer, kc_current_view);
		    { kc_printer(kc_t(" current_son=this;\
\n\
\n    do {\
\n	bool skip=false;\
\n	current_son = kc_current_view_base.pre_rewrite(current_son, skip);\
\n	initialize_sons_stack(current_son, skip, node_stack, sons_todo, kc_cur"), kc_current_view );
		  kc_printer(kc_t("rent_view_base);\
\n	\
\n	bool changed=true;\
\n	do {\
\n	    assertCond(current_son);\
\n\
\n	    abstract_phylum"), kc_current_view); }
		    kc::unparse(how_smart, kc_printer, kc_current_view);
		    { kc_printer(kc_t(" res=current_son;\
\n	    if(!skip)\
\n		res=current_son->do_rewrite(kc_current_view_base);\
\n\
\n	    assertCond(res);\
\n	    changed=true;\
\n\
\n	    if(res==current_son) { // nothing has been cha"), kc_current_view );
		  kc_printer(kc_t("nged, current_son is completely rewritten\
\n		if(!skip) { // call post_rewrite if this node is not skipped\
\n		    bool again=false;\
\n		    current_son=kc_current_view_base.post_rewrite(current_son"), kc_current_view );
		  kc_printer(kc_t(", again);\
\n		    assertCond(current_son);\
\n		    if(again)\
\n			\vbreak;\r // starts the whole rewrite_loop for the post_rewritten node again\
\n		}\
\n		else\
\n		    skip=false;\
\n\
\n		sons_do"), kc_current_view );
		  kc_printer(kc_t("ne.push_back(current_son); // move this son to sons_done\
\n\
\n		if(!node_stack.empty()) { // else all is done\
\n		    assertCond(!sons_todo.empty());\
\n		    assertCond(sons_todo.top()>0);\
\n		   "), kc_current_view );
		  kc_printer(kc_t(" --sons_todo.top(); // one less to todo\
\n\
\n		    if(sons_todo.top()==0) { // all sons done\
\n			sons_todo.pop(); // forget it\
\n\
\n			current_son=node_stack.top(); // the parent of the original "), kc_current_view );
		  kc_printer(kc_t("last done sons\
\n			node_stack.pop();\
\n			// the last (rewritten) son of this parent is\
\n			// on top of sons_done (sons_done[sons_done.size()-1])\
\n\
\n			size_t no_of_sons=kc_sons(current_son);"), kc_current_view );
		  kc_printer(kc_t("\
\n			assertCond(sons_done.size() >= no_of_sons);\
\n			changed = sons_changed(current_son, sons_done, no_of_sons);\
\n			if(changed) {	// some sons are different ->\
\n					\v\v// create a new operat"), kc_current_view );
		  kc_printer(kc_t("or and make it the current\
\n			    \r\rabstract_phylum"), kc_current_view); }
		    kc::unparse(how_smart, kc_printer, kc_current_view);
		    { kc_printer(kc_t(" new_son =\
\n				\vkc_create_op(current_son->prod_sel(), sons_done, no_of_sons);\r\
\n			    new_son->rewrite_members(current_son);\
\n			    current_son = new_son;\
\n			    // the sons do not need t"), kc_current_view );
		  kc_printer(kc_t("o be rewritten again\
\n			    changed=false;\
\n			}\
\n			// The current node must still be rewritten,\
\n			// but not its sons anymore (changed == false).\
\n			// Those sons are in the current nod"), kc_current_view );
		  kc_printer(kc_t("e, so no-one needs\
\n			// them anymore and they are popped off the stack.\
\n			sons_done.resize(sons_done.size() - no_of_sons);\
\n		    }\
\n		    else { // make the complete loop with the next son"), kc_current_view );
		  kc_printer(kc_t(" (changed == true)\
\n			current_son = node_stack.top();\
\n			node_stack.pop();\
\n		    }\
\n		}\
\n		else {\
\n		    current_son = 0; // terminates the loop\
\n		}\
\n	    }\
\n	    else // somethin"), kc_current_view );
		  kc_printer(kc_t("g has been changed -> start rewrite with the changed node again\
\n		current_son=res;\
\n	} while(!changed);\
\n    } while(current_son);\
\n\
\n    assertCond(sons_todo.size()==0);\
\n    assertCond(s"), kc_current_view );
		  kc_printer(kc_t("ons_done.size()==1);\
\n    return sons_done[0]"), kc_current_view); }
		    if(g_options.smart_pointer) 
		    {
			{ kc_printer(kc_t(".return_ptr()"), kc_current_view); }
		    }
		    { kc_printer(kc_t("; // done.top()\
\n}\
\n"), kc_current_view); }
		}
	    }
	    break;
	}
	case view_gen_end_rewritek_h_enum: {
	    view_gen_end_rewritek_h_class& kc_current_view=static_cast<view_gen_end_rewritek_h_class&>(kc_current_view_base);
	    {
		{ kc_printer(kc_t("#endif // KC_REWRITE_HEADER\n"), kc_current_view); }
	    }
	    break;
	}
	case view_gen_rewritek_h_enum: {
	    view_gen_rewritek_h_class& kc_current_view=static_cast<view_gen_rewritek_h_class&>(kc_current_view_base);
	    {
		{ kc_printer(kc_t("/* translation of file(s)\n"), kc_current_view); }
		kc::unparse(Thefnfiles, kc_printer, kc_current_view);
		{ kc_printer(kc_t(" */\
\n/* generated by:\
\n *  "), kc_current_view); }
		kc::unparse(kimwitu_copyright, kc_printer, kc_current_view);
		{ kc_printer(kc_t("\
\n */\
\n#ifndef KC_REWRITE_HEADER\
\n#define KC_REWRITE_HEADER\
\n\
\n"), kc_current_view); }
	    }
	    break;
	}
	case view_gen_copydefs_c_enum: {
	    view_gen_copydefs_c_class& kc_current_view=static_cast<view_gen_copydefs_c_class&>(kc_current_view_base);
	    {
		const phylumdeclarations pds = this->phylumdeclarations_1;
		{ kc_printer(kc_t("abstract_phylum\
\nimpl_abstract_phylum::copy(bool kc_copy_attributes) const\
\n{\
\n    enum_phyla kc_phy = phylum(); // XXX - implement special cases in subclasses - MvL\
\n    KC_OPERATOR_INFO *kc_o"), kc_current_view );
		  kc_printer(kc_t("p_info = &operator_info[prod_sel()];\
\n    kc_storageclass_t kc_st = phylum_info[kc_op_info->phylum].uniq_stored;\
\n    if (kc_st && kc_storageclass_still_uniq[kc_st])\
\n	return const_cast<abstract_"), kc_current_view );
		  kc_printer(kc_t("phylum>(this);\
\n    abstract_phylum kc_answer=0;\
\n    if (kc_phy == phylum_casestring) {\
\n	kc_answer=mkcasestring((dynamic_cast<c_casestring>(this))->name);\
\n    } else if (kc_phy == phylum_noc"), kc_current_view );
		  kc_printer(kc_t("asestring) {\
\n	kc_answer=mknocasestring((dynamic_cast<c_nocasestring>(this))->name);\
\n    } else if (kc_phy == phylum_voidptr) {\
\n	kc_answer=mkvoidptr((dynamic_cast<c_voidptr>(this))->pointer);\
\n"), kc_current_view );
		  kc_printer(kc_t("    } else if (kc_phy == phylum_integer) {\
\n	kc_answer=mkinteger((dynamic_cast<c_integer>(this))->value);\
\n    } else if (kc_phy == phylum_real) {\
\n	kc_answer=mkreal((dynamic_cast<c_real>(this))-"), kc_current_view );
		  kc_printer(kc_t(">value);\
\n    } else {\
\n	abstract_phylum kc_subtmp["), kc_current_view); }
		int i = Theargsnumbers->last()->value; if (i<=0) i = 1; 
		kc::unparse(i, kc_printer, kc_current_view);
		{ kc_printer(kc_t("], child;\
\n	for (int kc_i = 0; (child = subphylum(kc_i)); kc_i++) {\
\n	    kc_subtmp[kc_i] = child->copy(kc_copy_attributes);\
\n	}\
\n	switch(kc_op_info->no_sons) {\
\n"), kc_current_view); }
		kc::unparse(Theargsnumbers, kc_printer, kc_current_view);
		{ kc_printer(kc_t("	default: assertionFailed(\"unexpected number of sub-phyla\");\
\n	}\
\n    }\
\n    if (kc_copy_attributes)\
\n	copy_attributes(kc_phy, this, kc_answer);\
\n    return kc_answer;\
\n}\
\n\
\n"), kc_current_view); }
	    }
	    break;
	}
	case view_gen_copy_attributes_c_enum: {
	    view_gen_copy_attributes_c_class& kc_current_view=static_cast<view_gen_copy_attributes_c_class&>(kc_current_view_base);
	    {
		const phylumdeclarations pds = this->phylumdeclarations_1;
		{ kc_printer(kc_t("\
\nvoid\
\ncopy_attributes(enum_phyla copyPhy, c_abstract_phylum kc_p1, abstract_phylum kc_p2)\
\n{\
\n    switch(copyPhy) {\r\
\n"), kc_current_view); }
		kc::unparse(pds, kc_printer, kc_current_view);
		{ kc_printer(kc_t("   case one_before_first_phylum: // just to avoid a warning about missing case if empty\
\n    default:\
\n	\vbreak; // it's alright, no attributes to copy\r\
\n    }\
\n    enum_operators copyOp=kc_p1"), kc_current_view );
		  kc_printer(kc_t("->prod_sel();\
\n    for (int i=operator_info[copyOp].no_attrs-1; i>=0; --i)\v\
\n	attributeOf(kc_p2, i)=attributeOf(const_cast<abstract_phylum>(kc_p1), i);\r\
\n}\
\n\
\n"), kc_current_view); }
	    }
	    break;
	}
	case view_gen_csgio_c_enum: {
	    view_gen_csgio_c_class& kc_current_view=static_cast<view_gen_csgio_c_class&>(kc_current_view_base);
	    {
		const phylumdeclarations pds = this->phylumdeclarations_1;
		{ kc_printer(kc_t("\
\n\
\nnamespace { // all local to this file\
\n\r\
\n/* macro that does the string concatenation */\
\n#define kc_str_conc2(a,b) strcat(strcpy(new char[strlen(a) + strlen(b) +1], a), b)\
\n\
\n/* fun"), kc_current_view );
		  kc_printer(kc_t("ction that reads the integers */\
\ninline void\
\nkc_do_get_int(int &c, int c_init, int &i, FILE *f)\
\n{\
\n    c = c_init;\
\n    i = 0;\
\n    while (isdigit(c)){\
\n	i = (i*10) + (c-'0');\
\n	c = "), kc_current_view );
		  kc_printer(kc_t("getc(f);\
\n    }\
\n}\
\n\
\nchar *kc_malloc_area = 0;\
\nsize_t kc_sizeof_malloc_area = 0;\
\nint kc_node_count;\
\nint kc_node_count_base;\
\n\
\nchar*\
\nkc_grow_malloc_area(size_t kc_s)\
\n{\
\n  "), kc_current_view );
		  kc_printer(kc_t("  delete kc_malloc_area;\
\n    kc_malloc_area = new char[kc_s];\
\n    kc_sizeof_malloc_area = kc_s;\
\n    return kc_malloc_area;\
\n}\
\n\
\ninline char*\
\nKC_GETMALLOCAREA(size_t kc_s)\
\n{\
\n   "), kc_current_view );
		  kc_printer(kc_t(" return kc_s > kc_sizeof_malloc_area ?\
\n	kc_grow_malloc_area(kc_s) : kc_malloc_area;\
\n}\
\n\
\n/* global variables */\
\nint kc_no_external_ops;\
\nconst int KC_NOT_FOUND_OPERATOR = -1;\
\nint kc_f"), kc_current_view );
		  kc_printer(kc_t("ile_offset_base;\
\nint kc_file_offset;\
\n\
\n/* Magic File descriptor(s) */\
\n/* Magic descriptors of length up to KC_MAGIC_LENGTH-1 are supported.  When changing\
\n * KC_MAGIC_LENGTH. change const"), kc_current_view );
		  kc_printer(kc_t("ant in MAGIC_READ_FORMAT to be one less than\
\n * KC_MAGIC_LENGTH. */\
\n/* Every file is assumed to start with the magic file descriptor for asc_csg_v3 */\
\n\
\nchar kc_ascii_prefix_magic_v3[] = \"A"), kc_current_view );
		  kc_printer(kc_t("#S#C#S#S#L#V#3\";\
\nchar kc_ascii_prefix_magic_hu[] = \"A#S#C#S#S#L#HUB\";\
\nconst int KC_MAGIC_LENGTH = 25;\
\nconst char *KC_MAGIC_READ_FORMAT = \"%24s\\n\";\
\n\
\n/* Operators with names of lengt"), kc_current_view );
		  kc_printer(kc_t("h upto OP_LENGTH-1 are supported. */\
\n/* When changing OP_LENGTH, change constant in OP_READ_FOMAT to be one less */\
\nconst int KC_OP_LENGTH = 256;\
\nconst char *KC_OP_READ_FORMAT = \"%255s\\n\";\
\n"), kc_current_view );
		  kc_printer(kc_t("\
\n//**********************\
\n// Error-string Routine\
\nconst char*\
\nkc_CSGIOerrorstring(KC_IO_STATUS kc_io_status)\
\n{\
\n    switch( kc_io_status ) {\
\n	case KC_CSGIOSTATUS_NO_ERR: return( \"N"), kc_current_view );
		  kc_printer(kc_t("o errors\" );\
\n	case KC_CSGIOSTATUS_SCAN_ERR_1: return( \"Scan error(1)\" );\
\n	case KC_CSGIOSTATUS_SCAN_ERR_2: return( \"Scan error(2)\" );\
\n	case KC_CSGIOSTATUS_SCAN_ERR_3: return( \"Scan error("), kc_current_view );
		  kc_printer(kc_t("3)\" );\
\n	case KC_CSGIOSTATUS_SCAN_ERR_4: return( \"Scan error(4)\" );\
\n	case KC_CSGIOSTATUS_SCAN_ERR_5: return( \"Scan error(5)\" );\
\n	case KC_CSGIOSTATUS_GRAM_INCONSISTENT: return( \"Grammar is"), kc_current_view );
		  kc_printer(kc_t(" inconsistent\" );\
\n	case KC_CSGIOSTATUS_ROK: return( \"Read OK structure file\" );\
\n	case KC_CSGIOSTATUS_ILLEGAL_OPTION: return( \"Illegal option in write command\" );\
\n	case KC_CSGIOSTATUS_TOO_"), kc_current_view );
		  kc_printer(kc_t("MANY_OPERATORS: return( \"Too many operators for binary format\" );\
\n	case KC_CSGIOSTATUS_WOK: return( \"Written OK\" );\
\n	case KC_CSGIOSTATUS_TXT_FILE_INPUT: return( \"Read OK Text-file\" );\
\n	c"), kc_current_view );
		  kc_printer(kc_t("ase KC_CSGIOSTATUS_SYNTAX_ERROR: return( \"Syntax error\" );\
\n	case KC_CSGIOSTATUS_ILLEGAL_CONTEXT: return( \"Illegal context for operator\" );\
\n	case KC_CSGIOSTATUS_PREMATURE_EOF: return( \"Premat"), kc_current_view );
		  kc_printer(kc_t("ure eof in file\" );\
\n	case KC_CSGIOSTATUS_UNEXP_FATHER_MARK: return( \"Unexpected FATHER MARKER\" );\
\n	default: return( \"Unknown error code\" );\
\n    }\
\n}\
\n\
\nstruct csgio_info {\
\n  int "), kc_current_view );
		  kc_printer(kc_t("number;      // number of node, or -1 if no number\
\n  bool created;    // whether the node is already written\
\n  csgio_info():number(-1),created(false){}\
\n};\
\ntypedef std::map<const void*,csgio"), kc_current_view );
		  kc_printer(kc_t("_info> csgio_map;\
\ncsgio_map kc_CSGIOhashtable;\
\n\
\n/* Maps */\
\ntypedef struct {\
\n    int left;\
\n    int right;\
\n} kc_OpToOpMap_tuple_t;\
\n\
\nkc_OpToOpMap_tuple_t kc_OpToOpMap[KC_NO_OF_O"), kc_current_view );
		  kc_printer(kc_t("PERATORS];\
\nconst int KC_NOT_USED = -1;\
\n\
\nint\
\nkc_op_search(char *kc_s)\
\n{\
\n    int kc_i;\
\n    for ( kc_i=0; kc_i < KC_NO_OF_OPERATORS; kc_i++ ) {\
\n	if ( strcmp( kc_s, operator_info[kc"), kc_current_view );
		  kc_printer(kc_t("_i].name ) == 0 ) return( kc_i );\
\n    }\
\n    return( KC_NOT_FOUND_OPERATOR );\
\n}\
\n\
\nvoid\
\nkc_initializeOpToOpMap(int kc_v)\
\n{\
\n    int kc_i;\
\n    for ( kc_i=0; kc_i < KC_NO_OF_OPERAT"), kc_current_view );
		  kc_printer(kc_t("ORS; kc_i++ ) {\
\n	kc_OpToOpMap[kc_i].left = kc_i;\
\n	kc_OpToOpMap[kc_i].right = kc_v;\
\n}   }\
\n\
\nbool\
\nOpToOpMap_cmp_right(kc_OpToOpMap_tuple_t t1, kc_OpToOpMap_tuple_t t2)\
\n{\
\n    // sor"), kc_current_view );
		  kc_printer(kc_t("t in DECREASING order\
\n    return t1.right > t2.right;\
\n}\
\n\
\nbool\
\nOpToOpMap_cmp_left(kc_OpToOpMap_tuple_t t1, kc_OpToOpMap_tuple_t t2)\
\n{\
\n    // sort in INCREASING order\
\n    return t"), kc_current_view );
		  kc_printer(kc_t("1.left < t2.left;\
\n}\
\n\
\nvoid\
\nkc_renumberOpToOpMap()\
\n{\
\n    int kc_i, kc_j = 0;\
\n    for ( kc_i=0; kc_i < KC_NO_OF_OPERATORS; kc_i++ ) {\
\n	if (kc_OpToOpMap[kc_i].right > 0) {\
\n	    k"), kc_current_view );
		  kc_printer(kc_t("c_OpToOpMap[kc_i].right = kc_j++;\
\n	} else {\
\n	    kc_OpToOpMap[kc_i].right = KC_NOT_USED;\
\n}   }	}\
\n\
\n\
\n#define KC_MAKE_NEW_MAPPING(ext_op,int_op) kc_OpToOpMap[ext_op].right = int_op\
\n#d"), kc_current_view );
		  kc_printer(kc_t("efine KC_MAKE_NEW_SCAN_MAPPING(ext_op) kc_OpToOpMap[ext_op].right++\
\n#define KC_MAP(op) (kc_OpToOpMap[op].right)\
\n#define KC_IS_MAPPED(op) (kc_OpToOpMap[op].right != KC_NOT_USED)\
\n\
\nvoid\
\nkc_"), kc_current_view );
		  kc_printer(kc_t("error_operator_not_in_phylum(int kc_op, int kc_phy)\
\n{\
\n    const char *kc_error_message1 = \"operator not defined in phylum \";\
\n    const char *kc_error_message2 = \": \";\
\n    if ((kc_op <= "), kc_current_view );
		  kc_printer(kc_t("one_before_first_operator) || (kc_op >= last_operator)) {\
\n	char kc_value[30];\
\n	sprintf(kc_value, \"%d\",kc_op);\
\n	kc_csgio_err_reason = kc_str_conc2(\"unknown operator number: \", kc_value);\
\n"), kc_current_view );
		  kc_printer(kc_t("    } else {\
\n	kc_csgio_err_reason = (char*)strcat(strcat(strcat(strcpy(new char[(size_t)(strlen(kc_error_message1)+strlen(phylum_info[kc_phy].name)+strlen(kc_error_message2)+strlen(operator_info[kc_"), kc_current_view );
		  kc_printer(kc_t("op].name)+1)], kc_error_message1), phylum_info[kc_phy].name), kc_error_message2), operator_info[kc_op].name);\
\n    }\
\n    throw IO_exception(KC_CSGIOSTATUS_ILLEGAL_CONTEXT); /*NOTREACHED*/\
\n}\
\n"), kc_current_view );
		  kc_printer(kc_t("\
\n} // anonymous namespace\
\n\
\nchar*\
\nIO_exception2char(IO_exception kc_p)\
\n{\
\n    char *kc_err_ret = 0;\
\n    const char *kc_err_sep = \": \";\
\n    if (kc_p.io_status != KC_CSGIOSTATUS_R"), kc_current_view );
		  kc_printer(kc_t("OK && kc_p.io_status != KC_CSGIOSTATUS_WOK) {\
\n	const char *kc_io_err = kc_CSGIOerrorstring(kc_p.io_status);\
\n	kc_err_ret = new char[strlen(kc_io_err)+strlen(kc_err_sep)+strlen(kc_p.err_reason)+1];"), kc_current_view );
		  kc_printer(kc_t("\
\n	strcpy(kc_err_ret, kc_io_err);\
\n	strcat(kc_err_ret, kc_err_sep);\
\n	strcat(kc_err_ret, kc_p.err_reason);\
\n    }\
\n    return kc_err_ret;\
\n}\
\n\
\nconst char *kc_csgio_err_reason = \"\";\
\n"), kc_current_view );
		  kc_printer(kc_t("\
\n#ifndef KC_NO_CSGIO_READ\
\nnamespace { // all local to this file\
\n\r\
\n/* Base 64 numbers are written with the digits:\
\n   : ; < = > ? @ A-Z [ \\ ] ^ _ ` a-y\
\n   Base 10 numbers are written"), kc_current_view );
		  kc_printer(kc_t(" with the ordinary digits 0-9.\
\n   Other characters are used in special circumstances:\
\n    ! Indicates switch between reading attribute and unattributed nodes.\
\n    # Indicates that the father i"), kc_current_view );
		  kc_printer(kc_t("s the next PROD_INSTANCE in the file.\
\n    + Indicates that the following bytes are not a base 64 number\
\n    * Indicates a line containing a (decimal) count of attributes.\
\n*/\
\nconst char KC_B"), kc_current_view );
		  kc_printer(kc_t("64_ZERO_CHAR =	':';\
\nconst char KC_ASCII_ZERO =	'0';\
\nconst char KC_SWITCH_ATTR =	'!';\
\nconst char KC_FATHER_MARKER =	'#';\
\nconst char KC_NON_B64_CHAR =	'+';\
\nconst char KC_ATTR_COUNT =	'*';\
\n"), kc_current_view );
		  kc_printer(kc_t("const char KC_NULL_POINTER =    '.';\
\n\
\ninline bool\
\nKC_IS_B64(int c)\
\n{\
\n    return c>=KC_B64_ZERO_CHAR && c<KC_B64_ZERO_CHAR+64;\
\n}\
\n\
\n/* read and compute the base 64 integer in strea"), kc_current_view );
		  kc_printer(kc_t("m */\
\nunsigned\
\nget_rest_of_b64(FILE *kc_stream, register int kc_read_char, char kc_trailing_char)\
\n{\
\n    int kc_next_char;\
\n    int kc_offset;\
\n    int kc_i = 0;\
\n\
\n    if (!KC_IS_B64"), kc_current_view );
		  kc_printer(kc_t("(kc_read_char))\
\n	throw IO_exception(KC_CSGIOSTATUS_SCAN_ERR_1);\
\n    kc_offset = kc_read_char - KC_B64_ZERO_CHAR;\
\n\
\n    kc_next_char = getc(kc_stream);\
\n    while(KC_IS_B64(kc_next_char)) {"), kc_current_view );
		  kc_printer(kc_t("\
\n	kc_offset += (kc_next_char - KC_B64_ZERO_CHAR) << (6 * (++kc_i));\
\n	kc_next_char = getc(kc_stream);\
\n	}\
\n\
\n    if (kc_next_char == '-') {\
\n	kc_offset *= -1;\
\n	kc_next_char = getc(kc_st"), kc_current_view );
		  kc_printer(kc_t("ream);\
\n    }\
\n\
\n    if (kc_next_char != kc_trailing_char)\
\n	throw IO_exception(KC_CSGIOSTATUS_SCAN_ERR_1);\
\n    return kc_offset;\
\n}\
\n\
\n/* read shared functions */\
\ntypedef enum { KC"), kc_current_view );
		  kc_printer(kc_t("_NOT_READ_YET, KC_READ_EARLIER } KC_READ_STATUS;\
\n/* variable used by the sharing routines during a read */\
\n/* stores pointers to value_ptr fields */\
\nabstract_phylum *kc_offset_to_address_map;\
\n"), kc_current_view );
		  kc_printer(kc_t("char const* *kc_offset_to_address_map_base;\
\n\
\nvoid\
\nkc_init_read_sharing()\
\n{\
\n  kc_offset_to_address_map = new abstract_phylum[kc_node_count];\
\n  for(int i=0; i<kc_node_count; ++i) kc_off"), kc_current_view );
		  kc_printer(kc_t("set_to_address_map[i]=0;\
\n  kc_file_offset = 0;\
\n  kc_offset_to_address_map_base = new char const* [kc_node_count_base];\
\n  for(int j=0; j<kc_node_count_base; ++j) kc_offset_to_address_map_base[j"), kc_current_view );
		  kc_printer(kc_t("]=0;\
\n  kc_file_offset_base = 0;\
\n}\
\n\
\nKC_READ_STATUS\
\nkc_read_sharing_find(FILE *kc_stream, abstract_phylum &kc_valptr)\
\n{\
\n    char kc_first_char;\
\n    unsigned kc_offset;\
\n\
\n    "), kc_current_view );
		  kc_printer(kc_t("kc_first_char = getc(kc_stream);\
\n    if (KC_IS_B64(kc_first_char)) {\
\n	kc_offset = get_rest_of_b64(kc_stream, kc_first_char, '\\n');\
\n	int off=kc_file_offset - kc_offset;\
\n	assertReason(off>=0"), kc_current_view );
		  kc_printer(kc_t(" && off<=kc_node_count, \"base 64 offset out of range\");\
\n	kc_valptr = kc_offset_to_address_map[off];\
\n	return(KC_READ_EARLIER);\
\n    } else {\
\n	ungetc(kc_first_char, kc_stream);\
\n	return(KC"), kc_current_view );
		  kc_printer(kc_t("_NOT_READ_YET);\
\n    }\
\n}\
\n\
\nKC_READ_STATUS\
\nkc_read_sharing_find_base(FILE *kc_stream, char const* &kc_valptr)\
\n{\
\n    char kc_first_char;\
\n    unsigned kc_offset;\
\n\
\n    kc_first_"), kc_current_view );
		  kc_printer(kc_t("char = getc(kc_stream);\
\n    if (KC_IS_B64(kc_first_char)) {\
\n	kc_offset = get_rest_of_b64(kc_stream, kc_first_char, '\\n');\
\n	int off=kc_file_offset_base - kc_offset;\
\n	assertReason(off>=0 && "), kc_current_view );
		  kc_printer(kc_t("off<=kc_node_count_base, \"base 64 offset out of range\");\
\n	kc_valptr = kc_offset_to_address_map_base[off];\
\n	return(KC_READ_EARLIER);\
\n    } else {\
\n	return(KC_NOT_READ_YET);\
\n    }\
\n}\
\n"), kc_current_view );
		  kc_printer(kc_t("\
\n#define kc_read_sharing_store(kc_ptr, kc_loc) \\\
\n    kc_offset_to_address_map[kc_loc] = kc_ptr\
\n#define kc_read_sharing_store_base(kc_ptr) \\\
\n    kc_offset_to_address_map_base[kc_file_offse"), kc_current_view );
		  kc_printer(kc_t("t_base++] = kc_ptr\
\n\
\n\
\nvoid\
\nkc_end_read_sharing()\
\n{\
\n  delete kc_offset_to_address_map;\
\n  delete kc_offset_to_address_map_base;\
\n}\
\n\
\nvoid\
\nkc_CSGIOdo_read_atom_denotation(FIL"), kc_current_view );
		  kc_printer(kc_t("E *kc_stream, char *kc_sbase, int kc_len)\
\n{\
\n    char * kc_sptr = kc_sbase;\
\n    register int kc_ch, kc_ch1;\
\n    register char kc_test;\
\n    register int kc_i;\
\n\
\n    for (kc_i=0; kc_i<"), kc_current_view );
		  kc_printer(kc_t("kc_len; kc_i++, kc_sptr++) {\
\n	kc_ch = getc(kc_stream);\
\n	if (kc_ch == '\\n') {\
\n	    ungetc(kc_ch, kc_stream);\
\n	    break;\
\n	}\
\n	*kc_sptr = (char) kc_ch;\
\n	if ( kc_ch == '\\\\' ) {\
\n	"), kc_current_view );
		  kc_printer(kc_t("    if ( ( kc_test = getc( kc_stream ) ) != '\\\\' ) { /* Must be escaped hex */\
\n		if (isdigit(kc_test)) kc_ch1 = kc_test - '0'; else kc_ch1 =kc_test + 10 - 'a';\
\n		kc_ch1 = 16 * kc_ch1;\
\n		kc_t"), kc_current_view );
		  kc_printer(kc_t("est = getc(kc_stream);\
\n		if (isdigit(kc_test)) kc_test= kc_test - '0'; else kc_test=kc_test + 10 - 'a';\
\n		kc_ch1 = kc_ch1 + kc_test;\
\n		*kc_sptr = (char)kc_ch1; /* cast is for explicit narrowin"), kc_current_view );
		  kc_printer(kc_t("g from int to char */\
\n	    }\
\n	}\
\n    }\
\n\
\n    kc_ch = getc(kc_stream);\
\n    if ( kc_ch == EOF ) throw IO_exception(KC_CSGIOSTATUS_PREMATURE_EOF);\
\n    else if (kc_ch != '\\n') throw IO_"), kc_current_view );
		  kc_printer(kc_t("exception(KC_CSGIOSTATUS_SCAN_ERR_1);\
\n\
\n    *kc_sptr = '\\0';\
\n}\
\n\
\nabstract_phylum\
\nCSGIOread2dft(FILE *kc_stream, enum_phyla kc_phy)\
\n{\
\n    char *kc_sbase;\
\n    char const* c_kc_s"), kc_current_view );
		  kc_printer(kc_t("base;\
\n    int kc_len;\
\n    int kc_delim;\
\n    abstract_phylum kc_answer;\
\n    int kc_location;\
\n    bool kc_not_read_yet = false;\
\n\
\n/* get operator */\
\n    int kc_ext_op;\
\n    int k"), kc_current_view );
		  kc_printer(kc_t("c_testing;\
\n\
\n    /* XXX MPi: misleading comment? scan for optional unparsing version number */\
\n    if (kc_read_sharing_find( kc_stream, kc_answer ) == KC_READ_EARLIER ) {\
\n	// MPi: I believe "), kc_current_view );
		  kc_printer(kc_t("this is unnecessary or wrong - sharing is only done\
\n	// when phyla are the _same_, so they should remain the same.\
\n        // kc_answer = kc_answer->copy(false);\
\n	return kc_answer;\
\n    }\
\n"), kc_current_view );
		  kc_printer(kc_t("    kc_do_get_int(kc_testing,getc(kc_stream),kc_ext_op,kc_stream);\
\n    if ( kc_testing == EOF )\
\n	throw IO_exception(KC_CSGIOSTATUS_SCAN_ERR_1);\
\n    if ( kc_testing == KC_NULL_POINTER )\
\n    "), kc_current_view );
		  kc_printer(kc_t("{\
\n	kc_do_get_int(kc_testing,getc(kc_stream),kc_ext_op,kc_stream);\
\n	if ( kc_testing != '\\n' )\
\n	    throw IO_exception(KC_CSGIOSTATUS_SCAN_ERR_1);\
\n	return 0;\
\n    }\
\n    if ( kc_testing "), kc_current_view );
		  kc_printer(kc_t("== KC_FATHER_MARKER )\
\n	throw IO_exception(KC_CSGIOSTATUS_UNEXP_FATHER_MARK);\
\n    if ( kc_testing != '\\n' )\
\n	throw IO_exception(KC_CSGIOSTATUS_SCAN_ERR_1);\
\n    enum_operators kc_op(static_c"), kc_current_view );
		  kc_printer(kc_t("ast<enum_operators>(KC_MAP( kc_ext_op )));\
\n/* end get operator */\
\n\
\n    if (kc_op<phylum_info[kc_phy].first_operator || kc_op>phylum_info[kc_phy].last_operator)\
\n	    kc_error_operator_not_in"), kc_current_view );
		  kc_printer(kc_t("_phylum(kc_op,kc_phy);\
\n\
\n    kc_location = kc_file_offset++;\
\n    switch( kc_op ) {\r\
\n    case sel__VoidPtr:\v\
\n	// FATAL ERROR\
\n	kc_do_get_int(kc_delim,getc(kc_stream),kc_len,kc_stream);"), kc_current_view );
		  kc_printer(kc_t("\
\n	if ( kc_delim == EOF )\
\n	    throw IO_exception(KC_CSGIOSTATUS_SCAN_ERR_1);\
\n	kc_sbase = KC_GETMALLOCAREA(kc_len + 1); // +1 for '\\0'\
\n	kc_CSGIOdo_read_atom_denotation(kc_stream, kc_sbase, "), kc_current_view );
		  kc_printer(kc_t("kc_len);\
\n	kc_answer = 0;\
\n	break;\r\
\n    case sel__Int:\v\
\n	kc_do_get_int(kc_delim,getc(kc_stream),kc_len,kc_stream);\
\n	if ( kc_delim == EOF )\
\n	    throw IO_exception(KC_CSGIOSTATUS_SCAN_"), kc_current_view );
		  kc_printer(kc_t("ERR_1);\
\n	kc_sbase = KC_GETMALLOCAREA(kc_len + 1); // +1 for '\\0'\
\n	kc_CSGIOdo_read_atom_denotation(kc_stream, kc_sbase, kc_len);\
\n	kc_answer = mkinteger(::atoi(kc_sbase));\
\n	break;\r\
\n    c"), kc_current_view );
		  kc_printer(kc_t("ase sel__Real:\v\
\n	kc_do_get_int(kc_delim,getc(kc_stream),kc_len,kc_stream);\
\n	if ( kc_delim == EOF )\
\n	    throw IO_exception(KC_CSGIOSTATUS_SCAN_ERR_1);\
\n	kc_sbase = KC_GETMALLOCAREA(kc_len +"), kc_current_view );
		  kc_printer(kc_t(" 1); // +1 for '\\0'\
\n	kc_CSGIOdo_read_atom_denotation(kc_stream, kc_sbase, kc_len);\
\n	kc_answer = mkreal(::atof(kc_sbase));\
\n	break;\r\
\n    case sel__Str:\v\
\n	if (kc_read_sharing_find_base( "), kc_current_view );
		  kc_printer(kc_t("kc_stream, c_kc_sbase ) == KC_NOT_READ_YET) {\
\n	    kc_not_read_yet = true;\
\n	    kc_do_get_int(kc_delim,getc(kc_stream),kc_len,kc_stream);\
\n	    if ( kc_delim == EOF )\
\n		throw IO_exception(KC"), kc_current_view );
		  kc_printer(kc_t("_CSGIOSTATUS_SCAN_ERR_1);\
\n	    kc_sbase = KC_GETMALLOCAREA(kc_len + 1); /* +1 for '\\0' */\
\n	    kc_CSGIOdo_read_atom_denotation(kc_stream, kc_sbase, kc_len);\
\n	    c_kc_sbase=kc_sbase;\
\n	}\
\n"), kc_current_view );
		  kc_printer(kc_t("	kc_answer = mkcasestring( c_kc_sbase );\
\n	if (kc_not_read_yet) {\
\n	    kc_read_sharing_store_base( phylum_cast<casestring>(kc_answer)->name );\
\n	}\
\n	break;\r\
\n    case sel_NoCaseStr:\v\
\n	i"), kc_current_view );
		  kc_printer(kc_t("f (kc_read_sharing_find_base( kc_stream, c_kc_sbase ) == KC_NOT_READ_YET) {\
\n	    kc_not_read_yet = true;\
\n	    kc_do_get_int(kc_delim,getc(kc_stream),kc_len,kc_stream);\
\n	    if ( kc_delim == EO"), kc_current_view );
		  kc_printer(kc_t("F )\
\n		throw IO_exception(KC_CSGIOSTATUS_SCAN_ERR_1);\
\n	    kc_sbase = KC_GETMALLOCAREA(kc_len + 1); /* +1 for '\\0' */\
\n	    kc_CSGIOdo_read_atom_denotation(kc_stream, kc_sbase, kc_len);\
\n	   "), kc_current_view );
		  kc_printer(kc_t(" c_kc_sbase=kc_sbase;\
\n	}\
\n	kc_answer = mknocasestring( c_kc_sbase );\
\n	if (kc_not_read_yet) {\
\n	    kc_read_sharing_store_base( phylum_cast<nocasestring>(kc_answer)->name );\
\n	}\
\n	break;\
\n"), kc_current_view );
		  kc_printer(kc_t("    default:\v\
\n	abstract_phylum kc_subtmp["), kc_current_view); }
		int i = Theargsnumbers->last()->value; if (i<=0) i = 1; 
		kc::unparse(i, kc_printer, kc_current_view);
		{ kc_printer(kc_t("];\
\n	for (int kc_i = 0; kc_i < operator_info[kc_op].no_sons; ++kc_i) {\
\n	    kc_subtmp[kc_i] = CSGIOread2dft(kc_stream, operator_info[kc_op].subphylum[kc_i] );\
\n	    assertReason(kc_subtmp[kc_i]!"), kc_current_view );
		  kc_printer(kc_t("=0, \"shared phylum is not contained in file (reference is wrong)\");\
\n	}\
\n"), kc_current_view); }
		{ kc_printer(kc_t("	switch(operator_info[kc_op].no_sons) {\
\n"), kc_current_view); }
		kc::unparse(Theargsnumbers, kc_printer, kc_current_view);
		{ kc_printer(kc_t("	default:\v\
\n	    assertionFailed(\"unexpected number of sub-phyla\"); break;\r\
\n	}\r\
\n	// Read attributes\
\n	for (int kc_i=0; kc_i<operator_info[kc_op].no_attrs; ++kc_i)\v\
\n	    attributeOf(k"), kc_current_view );
		  kc_printer(kc_t("c_answer, kc_i)=\v\
\n		CSGIOread2dft(kc_stream, operator_info[kc_op].attribute[kc_i]);\r\r\
\n    }\
\n \
\n    kc_read_sharing_store( kc_answer, kc_location );\
\n    return kc_answer;\
\n}\
\n\
\n} "), kc_current_view );
		  kc_printer(kc_t("// anonymous namespace\
\n\
\nvoid\
\nCSGIOreadphylum(FILE *kc_stream, abstract_phylum &kc_ptr, enum_phyla kc_phy)\
\n{\
\n    int kc_scan_return_code;\
\n    char kc_magic_no[KC_MAGIC_LENGTH];\
\n    "), kc_current_view );
		  kc_printer(kc_t("char kc_dollarcode[KC_OP_LENGTH];\
\n    char kc_ext_name[KC_OP_LENGTH];\
\n    int kc_operator;\
\n\
\n    kc_csgio_err_reason = \"\";\
\n    kc_scan_return_code = fscanf( kc_stream, KC_MAGIC_READ_FOR"), kc_current_view );
		  kc_printer(kc_t("MAT, kc_magic_no );\
\n    if ( kc_scan_return_code != 1 )\
\n	throw IO_exception(KC_CSGIOSTATUS_GRAM_INCONSISTENT, \"magic string not scanned\") ;\
\n    if ( strcmp( kc_magic_no, kc_ascii_prefix_magi"), kc_current_view );
		  kc_printer(kc_t("c_v3 ) != 0 &&\
\n	    strcmp( kc_magic_no, kc_ascii_prefix_magic_hu ) != 0 )\
\n	throw IO_exception(KC_CSGIOSTATUS_GRAM_INCONSISTENT,\"scanned magic string is not asc_ssl_v3 (or HUB specific) magic st"), kc_current_view );
		  kc_printer(kc_t("ring\") ;\
\n    if ( fscanf( kc_stream, \"$%[^ ] \\n\", kc_dollarcode ) != 1 )\
\n	throw IO_exception(KC_CSGIOSTATUS_GRAM_INCONSISTENT,\"problems finding $ before operators\") ;\
\n    while ( strcmp("), kc_current_view );
		  kc_printer(kc_t(" kc_dollarcode, \"operators\" ) != 0 ) {\
\n	if ( fscanf( kc_stream, \"%*[^$]$%[^ ] \\n\", kc_dollarcode) != 1 )\
\n	    throw IO_exception(KC_CSGIOSTATUS_GRAM_INCONSISTENT,\"problems finding operators"), kc_current_view );
		  kc_printer(kc_t(" keyword\") ;\
\n    }\
\n    /* read all external operator definitions and initialize map */\
\n    kc_no_external_ops = 0;\
\n    kc_initializeOpToOpMap(KC_NOT_FOUND_OPERATOR);\
\n    while (true) {\
\n"), kc_current_view );
		  kc_printer(kc_t("	int kc_ext_arity, kc_ext_attr_arity, kc_ext_atomicity;\
\n\
\n	if ( fscanf( kc_stream, \"%[^ ] \", kc_ext_name ) != 1 )\
\n	    throw IO_exception(KC_CSGIOSTATUS_SCAN_ERR_3, \"no operator name at star"), kc_current_view );
		  kc_printer(kc_t("t of line\") ;\
\n	else if ( kc_ext_name[0] == '$' )\
\n	    break;\
\n	else if ( fscanf( kc_stream, \"%d %d %d\\n\", &kc_ext_arity, &kc_ext_attr_arity, &kc_ext_atomicity ) != 3 )\
\n	    throw IO_exce"), kc_current_view );
		  kc_printer(kc_t("ption(KC_CSGIOSTATUS_SCAN_ERR_4, \"no arity, attr_arity or atomicity\") ;\
\n	else {\
\n	    kc_operator = kc_op_search( kc_ext_name );\
\n	    if ( ( kc_operator == KC_NOT_FOUND_OPERATOR ) ||\
\n		 ( "), kc_current_view );
		  kc_printer(kc_t("KC_NO_SONS( kc_operator ) != kc_ext_arity ) ||\
\n		 ( KC_ATOMICITY( kc_operator) != (kc_ext_atomicity!=0) )\
\n	       )\
\n		throw IO_exception(KC_CSGIOSTATUS_GRAM_INCONSISTENT, kc_str_conc2(\"proble"), kc_current_view );
		  kc_printer(kc_t("ms with operator: \",kc_ext_name)) ;\
\n	    else {\
\n		KC_MAKE_NEW_MAPPING( kc_no_external_ops, kc_operator );\
\n		kc_no_external_ops++;\
\n    }	}   }\
\n    /* ascertain that we are at the $object"), kc_current_view );
		  kc_printer(kc_t(" section, or get to that point */\
\n    if ( strcmp( kc_ext_name, \"$object\" ) != 0 ) /* if not at $object */\
\n	while ( strcmp( kc_ext_name, \"object\" ) != 0 ) {\
\n	    if ( fscanf( kc_stream, \""), kc_current_view );
		  kc_printer(kc_t("%*[^$]$%[^ ]\", kc_ext_name ) != 1 )\
\n		throw IO_exception(KC_CSGIOSTATUS_GRAM_INCONSISTENT, kc_str_conc2(\"problems finding start of object section\",\"\")) ;\
\n	}\
\n\
\n    /* read node_count; se"), kc_current_view );
		  kc_printer(kc_t("t up address map */\
\n    if (fscanf(kc_stream, \"%d %d\\n\", &kc_node_count, &kc_node_count_base) != 2)\
\n	throw IO_exception(KC_CSGIOSTATUS_SCAN_ERR_1);\
\n    kc_init_read_sharing(); /* for shared"), kc_current_view );
		  kc_printer(kc_t(" values */\
\n\
\n    /* read the tree (actually a graph) */\
\n    kc_ptr = CSGIOread2dft( kc_stream, kc_phy );\
\n    kc_end_read_sharing(); /* for atomic values */\
\n}\
\n#endif // ! KC_NO_CSGIO_RE"), kc_current_view );
		  kc_printer(kc_t("AD\
\n\
\n#ifndef KC_NO_CSGIO_WRITE\
\nnamespace { // all local to this file\
\n\r\
\n\
\n// print a string to a file, escaping backslashes and non-printables\
\nvoid\
\nkc_print_to_file(FILE *kc_f, ch"), kc_current_view );
		  kc_printer(kc_t("ar const* kc_value)\
\n{\
\n    unsigned char const* kc_vptr = (unsigned char const*)kc_value;\
\n    int kc_len = strlen(kc_value);\
\n    int kc_i;\
\n\
\n    fprintf(kc_f, \"%d \", kc_len);\
\n    f"), kc_current_view );
		  kc_printer(kc_t("or (kc_i=0; kc_i<kc_len; kc_i++, kc_vptr++) {\
\n	if (*kc_vptr == '\\\\') {\
\n	    fprintf(kc_f, \"\\\\\\\\\");\
\n	} else if (isprint(*kc_vptr)) {\
\n	    putc((char)*kc_vptr, kc_f);\
\n	} else {\
\n"), kc_current_view );
		  kc_printer(kc_t("	    fprintf(kc_f, \"\\\\%.2x\", *kc_vptr);\
\n	}\
\n    }\
\n    putc('\\n', kc_f);\
\n}\
\n\
\nvoid\
\nkc_print_b64_to_file(FILE *kc_f, int kc_value)\
\n{\
\n    unsigned int kc_pos_value;\
\n\
\n   "), kc_current_view );
		  kc_printer(kc_t(" if (kc_value == 0) {\
\n	putc(KC_B64_ZERO_CHAR, kc_f);\
\n    } else {\
\n	kc_pos_value = abs(kc_value);\
\n	while (kc_pos_value != 0) {\
\n	    putc((kc_pos_value & ((1 << 6) - 1) ) + KC_B64_ZERO_CHA"), kc_current_view );
		  kc_printer(kc_t("R, kc_f);\
\n	    kc_pos_value >>= 6;\
\n	}\
\n	if (kc_value < 0) {\
\n	    putc('-', kc_f);\
\n	}\
\n    }\
\n    putc('\\n', kc_f);\
\n}\
\n\
\n// realize sharing of strings in ouput file\
\nvoid\
\n"), kc_current_view );
		  kc_printer(kc_t("kc_CSGIOscan(c_abstract_phylum kc_p)\
\n{\
\n    if (kc_p==0) return;\
\n    enum_operators kc_op = kc_p->prod_sel();\
\n    if (kc_CSGIOhashtable[kc_p].number == -1) {\
\n	kc_CSGIOhashtable[kc_p].numb"), kc_current_view );
		  kc_printer(kc_t("er = kc_node_count++;\
\n	KC_MAKE_NEW_SCAN_MAPPING( kc_op );\
\n	switch(kc_op) {\
\n	case sel__Str:\
\n	case sel_NoCaseStr: {\
\n	    char const* s = static_cast<c_casestring>(kc_p)->name;\
\n	    if ("), kc_current_view );
		  kc_printer(kc_t("kc_CSGIOhashtable[s].number == -1)\v\
\n		kc_CSGIOhashtable[s].number = kc_node_count_base++;\r\
\n	    break;\
\n	}\
\n        default: {\
\n	    abstract_phylum child;\
\n            for (int i=0; (c"), kc_current_view );
		  kc_printer(kc_t("hild = kc_p->subphylum(i)); ++i)\v\
\n		kc_CSGIOscan(child);\r\
\n	}\
\n	}\
\n	for (int i=0; i<operator_info[kc_op].no_attrs; ++i)\v\
\n	    kc_CSGIOscan(attributeOf(const_cast<abstract_phylum>(kc_p), "), kc_current_view );
		  kc_printer(kc_t("i));\r\
\n    }\
\n}\
\n\
\nvoid\
\nkc_CSGIOwrite2structure(FILE *kc_stream, c_abstract_phylum kc_p)\
\n{\
\n    if (kc_p==0) {\
\n	fprintf( kc_stream, \"%c\\n\", KC_NULL_POINTER );\
\n	return;\
\n    "), kc_current_view );
		  kc_printer(kc_t("}\
\n    char _kc_value[30];\
\n    char *kc_value = _kc_value;\
\n    enum_operators kc_op = kc_p->prod_sel();\
\n    csgio_info &kc_hn = kc_CSGIOhashtable[kc_p];\
\n    if (kc_hn.created) {\
\n	kc_pr"), kc_current_view );
		  kc_printer(kc_t("int_b64_to_file( kc_stream, kc_file_offset - kc_hn.number );\
\n    } else {\
\n	kc_hn.created = true;\
\n	fprintf( kc_stream, \"%d\\n\", KC_MAP( kc_op ) );\
\n	kc_file_offset++;\
\n	switch(kc_op) {\r\
\n"), kc_current_view );
		  kc_printer(kc_t("	case sel__VoidPtr:\v\
\n	    /* FATAL ERROR */\
\n	    sprintf( kc_value, \"%p\", static_cast<c_voidptr>(kc_p)->pointer);\
\n	    kc_print_to_file( kc_stream, kc_value );\
\n	    kc_file_offset_base++"), kc_current_view );
		  kc_printer(kc_t(";\
\n	    break;\r\
\n	case sel__Str:\
\n	case sel_NoCaseStr:\v\
\n	    fprintf( kc_stream, \"%c\", KC_NON_B64_CHAR );\
\n	    kc_print_to_file( kc_stream, static_cast<c_casestring>(kc_p)->name);\
\n	 "), kc_current_view );
		  kc_printer(kc_t("   kc_file_offset_base++;\
\n	    break;\r\
\n	case sel__Int:\v\
\n	    sprintf( kc_value, \"%d\", static_cast<c_integer>(kc_p)->value);\
\n	    kc_print_to_file( kc_stream, kc_value );\
\n	    kc_file"), kc_current_view );
		  kc_printer(kc_t("_offset_base++;\
\n	    break;\r\
\n	case sel__Real:\v\
\n	    sprintf( kc_value, \"%.20f\", static_cast<c_real>(kc_p)->value);\
\n	    kc_print_to_file( kc_stream, kc_value );\
\n	    kc_file_offset_b"), kc_current_view );
		  kc_printer(kc_t("ase++;\
\n	    break;\r\
\n	default:\
\n            abstract_phylum child;\
\n            for (int kc_i=0; (child = kc_p->subphylum(kc_i)); ++kc_i)\v\
\n		kc_CSGIOwrite2structure(kc_stream, child);\r\
\n"), kc_current_view );
		  kc_printer(kc_t("	    // Write attributes\
\n	    for (int kc_i=0; kc_i<operator_info[kc_op].no_attrs; ++kc_i)\v\
\n		kc_CSGIOwrite2structure(kc_stream, attributeOf(const_cast<abstract_phylum>(kc_p), kc_i));\r\
\n	}\
\n"), kc_current_view );
		  kc_printer(kc_t("    }\
\n}\
\n\
\nvoid\
\nCSGIOwrite(FILE *kc_stream, c_abstract_phylum kc_p)\
\n{\
\n    int kc_i;\
\n    kc_csgio_err_reason = \"\";\
\n\
\n    /* write out the magic string and $operators string */\
\n"), kc_current_view );
		  kc_printer(kc_t("    fprintf( kc_stream, \"%s\\n$operators \\n\", kc_ascii_prefix_magic_hu );\
\n\
\n    /* Initialize map from internal operators to external operators, */\
\n    /* initially empty */\
\n    kc_no_ext"), kc_current_view );
		  kc_printer(kc_t("ernal_ops = 0;\
\n    kc_node_count = 0;\
\n    kc_node_count_base = 0;\
\n    kc_initializeOpToOpMap(0); /* initialize to 0, not any other value */\
\n\
\n    // realize sharing\
\n    kc_CSGIOscan(kc"), kc_current_view );
		  kc_printer(kc_t("_p);\
\n    /* sort the optoopmap on decreasing operator usage */\
\n    std::sort(&kc_OpToOpMap[0], &kc_OpToOpMap[KC_NO_OF_OPERATORS], OpToOpMap_cmp_right);\
\n    kc_renumberOpToOpMap();\
\n\
\n    /"), kc_current_view );
		  kc_printer(kc_t("* write out the _sorted_ operator table */\
\n    for(kc_i = 0; kc_i < KC_NO_OF_OPERATORS; kc_i++) {\
\n	if (kc_OpToOpMap[kc_i].right != KC_NOT_USED) {\
\n	    fprintf( kc_stream, \"%s %d %d %d\\n\", K"), kc_current_view );
		  kc_printer(kc_t("C_OP_NAME( kc_OpToOpMap[kc_i].left), KC_NO_SONS( kc_OpToOpMap[kc_i].left ), 0, KC_ATOMICITY( kc_OpToOpMap[kc_i].left ) );\
\n    }	}\
\n\
\n    /* sort the optoopmap increasing on the operator number *"), kc_current_view );
		  kc_printer(kc_t("/\
\n    std::sort(&kc_OpToOpMap[0], &kc_OpToOpMap[KC_NO_OF_OPERATORS], OpToOpMap_cmp_left);\
\n\
\n    /* write out the grammar terminator string and the number of nodes */\
\n    fprintf( kc_stream, "), kc_current_view );
		  kc_printer(kc_t("\"$object \\n%d %d\\n\", kc_node_count, kc_node_count_base );\
\n\
\n    /* write out the tree */\
\n    kc_file_offset = 0;\
\n    kc_file_offset_base = 0;\
\n    kc_CSGIOwrite2structure( kc_stream, k"), kc_current_view );
		  kc_printer(kc_t("c_p);\
\n    kc_CSGIOhashtable.clear();\
\n}\
\n\
\n} // anonymous namespace\
\n\
\nvoid\
\nimpl_abstract_phylum::CSGIOwrite(FILE *kc_stream) const\
\n{\
\n    kc::CSGIOwrite(kc_stream, this);\
\n}\
\n"), kc_current_view );
		  kc_printer(kc_t("\
\n#endif // ! KC_NO_CSGIO_WRITE\
\n\
\n"), kc_current_view); }
	    }
	    break;
	}
	case view_gen_csgio_start_c_enum: {
	    view_gen_csgio_start_c_class& kc_current_view=static_cast<view_gen_csgio_start_c_class&>(kc_current_view_base);
	    {
		{ kc_printer(kc_t("/* translation of file(s)\n"), kc_current_view); }
		kc::unparse(Thefnfiles, kc_printer, kc_current_view);
		{ kc_printer(kc_t(" */\
\n/* generated by:\
\n *  "), kc_current_view); }
		kc::unparse(kimwitu_copyright, kc_printer, kc_current_view);
		{ kc_printer(kc_t("\
\n */\
\n#define KC_CSGIO\
\n"), kc_current_view); }
		if(g_options.stdafx!="") {
		    PRINT("#include \"");
		    PRINT(g_options.stdafx.c_str());
		    PRINT("\"\n");
		}	
			{ kc_printer(kc_t("\
\n#include <stdio.h>\
\n#include <setjmp.h>\
\n#include <ctype.h>\
\n#include <stdlib.h>\
\n#include <map>\
\n#include <algorithm>\
\n#include \""), kc_current_view); }
		PRINT(g_options.prefix.c_str()); 
			{ kc_printer(kc_t("k.h\"\
\n#include \""), kc_current_view); }
		PRINT(g_options.prefix.c_str()); 
			{ kc_printer(kc_t("csgiok.h\"\
\n\
\n"), kc_current_view); }
	    }
	    break;
	}
	case view_gen_csgio_h_enum: {
	    view_gen_csgio_h_class& kc_current_view=static_cast<view_gen_csgio_h_class&>(kc_current_view_base);
	    {
		const phylumdeclarations pds = this->phylumdeclarations_1;
		{ kc_printer(kc_t("\
\nextern const char *kc_csgio_err_reason;\
\n\
\ntypedef enum {\
\n    KC_CSGIOSTATUS_NO_ERR = 0,\
\n    KC_CSGIOSTATUS_SCAN_ERR_1, KC_CSGIOSTATUS_SCAN_ERR_2, KC_CSGIOSTATUS_SCAN_ERR_3,\
\n    KC_CSG"), kc_current_view );
		  kc_printer(kc_t("IOSTATUS_SCAN_ERR_4, KC_CSGIOSTATUS_SCAN_ERR_5, KC_CSGIOSTATUS_GRAM_INCONSISTENT,\
\n    KC_CSGIOSTATUS_ROK, KC_CSGIOSTATUS_ILLEGAL_OPTION, KC_CSGIOSTATUS_TOO_MANY_OPERATORS,\
\n    KC_CSGIOSTATUS_WOK,"), kc_current_view );
		  kc_printer(kc_t(" KC_CSGIOSTATUS_TXT_FILE_INPUT, KC_CSGIOSTATUS_SYNTAX_ERROR,\
\n    KC_CSGIOSTATUS_ILLEGAL_CONTEXT, KC_CSGIOSTATUS_PREMATURE_EOF,\
\n    KC_CSGIOSTATUS_UNEXP_FATHER_MARK\
\n} KC_IO_STATUS;\
\n\
\n// XX"), kc_current_view );
		  kc_printer(kc_t("X Needs to be extended\
\nstruct IO_exception {\
\n    IO_exception(KC_IO_STATUS _io_status, const char* _err_reason=kc_csgio_err_reason, int _line=0)\
\n	: io_status(_io_status), err_reason(_err_reaso"), kc_current_view );
		  kc_printer(kc_t("n), line(_line) { }\
\n    KC_IO_STATUS io_status;\
\n    const char *err_reason;\
\n    int line;\
\n};\
\n\
\nchar* IO_exception2char(IO_exception);\
\n\
\n#if defined(__GNUC__) && __GNUC__<3\
\n    "), kc_current_view );
		  kc_printer(kc_t("extern void CSGIOreadphylum(FILE*, abstract_phylum&, enum_phyla);\
\n#endif\
\n\
\ntemplate<typename P> void\
\nCSGIOread(FILE* kc_stream, P &kc_p)\
\n{\
\n    abstract_phylum kc_value;\
\n#if !(define"), kc_current_view );
		  kc_printer(kc_t("d(__GNUC__) && __GNUC__<3)\
\n    extern void CSGIOreadphylum(FILE*, abstract_phylum&, enum_phyla);\
\n#endif\
\n    CSGIOreadphylum( kc_stream, kc_value, kc_p->phylum_sel_ );\
\n    // Cast _could_ be"), kc_current_view );
		  kc_printer(kc_t(" static, but just to be completely sure\
\n    if (dynamic_cast<P>(kc_value)==0)\
\n	throw IO_exception(KC_CSGIOSTATUS_SCAN_ERR_5, \"Internal problem: Wrong phylum type created.\");\
\n    kc_p = dynam"), kc_current_view );
		  kc_printer(kc_t("ic_cast<P>(kc_value);\
\n}\
\n\
\n"), kc_current_view); }
	    }
	    break;
	}
	case view_gen_csgio_end_h_enum: {
	    view_gen_csgio_end_h_class& kc_current_view=static_cast<view_gen_csgio_end_h_class&>(kc_current_view_base);
	    {
		{ kc_printer(kc_t(" #endif // KC_CSGIO_HEADER\
\n\
\n"), kc_current_view); }
	    }
	    break;
	}
	case view_gen_csgio_start_h_enum: {
	    view_gen_csgio_start_h_class& kc_current_view=static_cast<view_gen_csgio_start_h_class&>(kc_current_view_base);
	    {
		{ kc_printer(kc_t("/* translation of file(s)\n"), kc_current_view); }
		kc::unparse(Thefnfiles, kc_printer, kc_current_view);
		{ kc_printer(kc_t(" */\
\n/* generated by:\
\n *  "), kc_current_view); }
		kc::unparse(kimwitu_copyright, kc_printer, kc_current_view);
		{ kc_printer(kc_t("\
\n */\
\n#ifndef KC_CSGIO_HEADER\
\n#define KC_CSGIO_HEADER\
\n#include \""), kc_current_view); }
		PRINT(g_options.prefix.c_str()); 
			{ kc_printer(kc_t("k.h\"    // in case a user forgets\
\n\
\n"), kc_current_view); }
	    }
	    break;
	}
	case view_gen_listdefs_c_enum: {
	    view_gen_listdefs_c_class& kc_current_view=static_cast<view_gen_listdefs_c_class&>(kc_current_view_base);
	    {
		const phylumdeclarations pds = this->phylumdeclarations_1;
		kc::unparse(pds, kc_printer, kc_current_view);
	    }
	    break;
	}
	case view_gen_printdotdefs_c_enum: {
	    view_gen_printdotdefs_c_class& kc_current_view=static_cast<view_gen_printdotdefs_c_class&>(kc_current_view_base);
	    {
		const phylumdeclarations pds = this->phylumdeclarations_1;
		{ kc_printer(kc_t("\
\n#ifndef KC_PRINTDOT_LABELSIZE\
\n# define KC_PRINTDOT_LABELSIZE 1023\
\n#endif\
\n\
\nclass impl_kc_dotedgenode_t\
\n{\
\npublic:\
\n    impl_kc_dotedgenode_t(c_abstract_phylum from,c_abstract_phyl"), kc_current_view );
		  kc_printer(kc_t("um to, int _son_nr):\
\n	ptr_from(from), ptr_to(to), son_nr(_son_nr), label(0), lsize(0), next(0) { }\
\n    c_abstract_phylum ptr_from;\
\n    c_abstract_phylum ptr_to;\
\n    int son_nr;\
\n    char "), kc_current_view );
		  kc_printer(kc_t("*label;\
\n    int lsize;\
\n    kc_dotedgenode_t next;\
\n};\
\n\
\nstatic kc_dotedgenode_t\
\nkc_mkdotedgenode(struct kc_dotedge_ht*, c_abstract_phylum, c_abstract_phylum, int);\
\nstatic void kc_do_"), kc_current_view );
		  kc_printer(kc_t("printdot_do_add_edge (c_abstract_phylum, c_abstract_phylum, int, int*, kc_dotedgenode_t*, const char*);\
\nstatic void kc_do_printdot_subgraph_prologue (FILE*, c_abstract_phylum, const char*, const cha"), kc_current_view );
		  kc_printer(kc_t("r*, bool, bool);\
\nstatic void kc_do_printdot_subgraph_epilogue (FILE*);\
\nstatic void kc_do_printdot_genfields (FILE*, int, bool);\
\nstatic void kc_do_printdot_edges (FILE*, kc_dotedgenode_t, const"), kc_current_view );
		  kc_printer(kc_t(" char*, bool);\
\n\
\nstatic bool\
\nkc_dotedge_less(kc_dotedgenode_t p1, kc_dotedgenode_t p2)\
\n{\
\n    if(p2==0)\
\n	return false;\
\n    if(p1==0)\
\n	return true;\
\n    if(p1->ptr_from<p2->ptr_f"), kc_current_view );
		  kc_printer(kc_t("rom)\
\n	return true;\
\n    if(p1->ptr_from>p2->ptr_from)\
\n	return false;\
\n    if(p1->ptr_to<p2->ptr_to)\
\n	return true;\
\n    if(p1->ptr_to>p2->ptr_to)\
\n	return false;\
\n    if(p1->son_nr<p2"), kc_current_view );
		  kc_printer(kc_t("->son_nr)\
\n	return true;\
\n    // OPERATORHASH((unsigned) kc_phy_from);\
\n    // OPERATORHASH((unsigned) kc_phy_to);\
\n    return false;\
\n}\
\n\
\ntemplate<typename T>\
\nstruct dotedge_less : s"), kc_current_view );
		  kc_printer(kc_t("td::binary_function<T, T, bool> {\
\n    bool operator()(const T& X, const T& Y) const { return kc_dotedge_less(X,Y); }\
\n};\
\n\
\nstruct kc_dotedge_ht: public std::set<kc_dotedgenode_t, dotedge_less"), kc_current_view );
		  kc_printer(kc_t("<kc_dotedgenode_t> > {\
\n	~kc_dotedge_ht() {\
\n		for(iterator i=begin();i!=end();++i)\
\n			delete const_cast<kc_dotedgenode_t>(*i);\
\n		clear();\
\n	}\
\n    kc_dotedgenode_t check_insert(kc_dotedg"), kc_current_view );
		  kc_printer(kc_t("enode_t t) {\
\n        std::pair<iterator,bool> res=insert(t);\
\n        return *res.first;\
\n    }\
\n};\
\n\
\nstatic kc_dotedge_ht* fprintdot_hashtable;\
\n"), kc_current_view); }
		kc::unparse(pds, kc_printer, kc_current_view);
		{ kc_printer(kc_t("\
\n\
\nkc_dotedgenode_t\
\nkc_mkdotedgenode(kc_dotedge_ht* kc_a_ht, c_abstract_phylum kc_s_from, c_abstract_phylum kc_s_to, int kc_son_nr)\
\n{\
\n    kc_dotedgenode_t kc_x = new impl_kc_dotedgenode_t"), kc_current_view );
		  kc_printer(kc_t("(kc_s_from,kc_s_to,kc_son_nr);\
\n 	kc_dotedgenode_t unique_kc_x=kc_a_ht->check_insert(kc_x);\
\n	if(unique_kc_x!=kc_x) {\
\n		delete kc_x;\
\n		kc_x=unique_kc_x;\
\n	}\
\n    return kc_x;\
\n}\
\n\
\n"), kc_current_view );
		  kc_printer(kc_t("void kc_do_printdot_subgraph_prologue(FILE *kc_f, c_abstract_phylum kc_p, const char *root_label_prefix, const char *edge_attributes, bool print_node_labels, bool use_context_when_sharing_leaves)\
\n{\
\n"), kc_current_view );
		  kc_printer(kc_t("    if (!kc_f) kc_f = stdout;\
\n    fprintf(kc_f, \"/*subgraph*/ {\\n\");\
\n    if (root_label_prefix) {\
\n	fprintf(kc_f, \"\\\"%s\\\" [shape=ellipse\", root_label_prefix);\
\n	if (edge_attributes &"), kc_current_view );
		  kc_printer(kc_t("& (strlen(edge_attributes) > 0)) {\
\n	    fprintf(kc_f, \", %s\", edge_attributes);\
\n	}\
\n	if (print_node_labels) {\
\n	    fprintf(kc_f, \", label=\\\"%s\\\\n%s\\\"\", root_label_prefix, phylum_in"), kc_current_view );
		  kc_printer(kc_t("fo[kc_p->phylum()].name);\
\n	}\
\n	fprintf(kc_f, \"];\\n\");\
\n	fprintf(kc_f, \"\\\"%s\\\" ->\", root_label_prefix);\
\n	kc_p->do_printdot_id(kc_f, use_context_when_sharing_leaves, 0, 0);\
\n	if (edg"), kc_current_view );
		  kc_printer(kc_t("e_attributes && (strlen(edge_attributes) > 0)) {\
\n	    fprintf(kc_f, \"[%s]\", edge_attributes);\
\n	}\
\n	fprintf(kc_f, \";\\n\");\
\n    }\
\n}\
\n\
\nvoid kc_do_printdot_subgraph_epilogue(FILE *kc"), kc_current_view );
		  kc_printer(kc_t("_f)\
\n{\
\n    if (!kc_f) kc_f = stdout;\
\n    fprintf(kc_f, \"}\\n\");\
\n}\
\n\
\nvoid fprintdotprologue(FILE *kc_f)\
\n{\
\n    if (!kc_f) kc_f = stdout;\
\n    fprintf(kc_f, \"digraph kc_output{\\n"), kc_current_view );
		  kc_printer(kc_t("\");\
\n    fprintf(kc_f, \"node [shape=record, height=.1, fontname=Helvetica];\\n\");\
\n}\
\n\
\nvoid fprintdotepilogue(FILE *kc_f)\
\n{\
\n    if (!kc_f) kc_f = stdout;\
\n    fprintf(kc_f, \"}\\n\""), kc_current_view );
		  kc_printer(kc_t(");\
\n}\
\n\
\nvoid kc_do_printdot_genfields(FILE *kc_f, int kc_prodsel, bool print_node_labels)\
\n{\
\n  int kc_i = 1;\
\n  KC_OPERATOR_INFO *kc_op_info = &operator_info[kc_prodsel];\
\n  if (kc_op_i"), kc_current_view );
		  kc_printer(kc_t("nfo->no_sons <= 0) return;\
\n  if (!kc_f) kc_f = stdout;\
\n  while(kc_i < kc_op_info->no_sons) {\
\n    fprintf(kc_f, \"<f%d>\", kc_i);\
\n    if (print_node_labels) {\
\n      fprintf(kc_f, \"%s\", "), kc_current_view );
		  kc_printer(kc_t("phylum_info[kc_op_info->subphylum[kc_i-1]].name);\
\n    }\
\n    fprintf(kc_f, \"|\");\
\n    kc_i++;\
\n  }\
\n  fprintf(kc_f, \"<f%d>\", kc_i);\
\n  if (print_node_labels) {\
\n    fprintf(kc_f, \"%"), kc_current_view );
		  kc_printer(kc_t("s\", phylum_info[kc_op_info->subphylum[kc_i-1]].name);\
\n  }\
\n}\
\n\
\nvoid impl_abstract_phylum::do_printdot_id(FILE *kc_f, bool use_context_when_sharing_leaves, c_abstract_phylum kc_ctxt, int kc_s"), kc_current_view );
		  kc_printer(kc_t("on_nr) const\
\n{\
\n    // The casts only make unique ids, so reinterpret_cast is alright\
\n    if (!kc_f) kc_f = stdout;\
\n    enum_phyla kc_phy = phylum();\
\n    if (kc_phy == phylum_voidptr) {\
\n"), kc_current_view );
		  kc_printer(kc_t("	fprintf(kc_f, \"kcidp%x\", reinterpret_cast<int>(this));\
\n	if (use_context_when_sharing_leaves) {\
\n	    fprintf(kc_f, \"_%x_%d\", reinterpret_cast<int>(kc_ctxt), kc_son_nr);\
\n	}\
\n    } else if"), kc_current_view );
		  kc_printer(kc_t(" ((kc_phy == phylum_casestring) || (kc_phy == phylum_nocasestring)) {\
\n	fprintf(kc_f, \"kcids%x\", reinterpret_cast<int>(this));\
\n	if (use_context_when_sharing_leaves) {\
\n	    fprintf(kc_f, \"_%x"), kc_current_view );
		  kc_printer(kc_t("_%d\", reinterpret_cast<int>(kc_ctxt), kc_son_nr);\
\n	}\
\n    } else if (kc_phy == phylum_integer) {\
\n	fprintf(kc_f, \"kcidi%x\", reinterpret_cast<int>(this));\
\n	if (use_context_when_sharing_leav"), kc_current_view );
		  kc_printer(kc_t("es) {\
\n	    fprintf(kc_f, \"_%x_%d\", reinterpret_cast<int>(kc_ctxt), kc_son_nr);\
\n	}\
\n    } else if (kc_phy == phylum_real) {\
\n	fprintf(kc_f, \"kcidf%x\", reinterpret_cast<int>(this));\
\n	if "), kc_current_view );
		  kc_printer(kc_t("(use_context_when_sharing_leaves) {\
\n	    fprintf(kc_f, \"_%x_%d\", reinterpret_cast<int>(kc_ctxt), kc_son_nr);\
\n	}\
\n    } else {\
\n	fprintf(kc_f, \"kcidx%x\", reinterpret_cast<int>(this));\
\n}"), kc_current_view );
		  kc_printer(kc_t("   }\
\n\
\nvoid kc_do_printdot_do_add_edge(c_abstract_phylum kc_p, c_abstract_phylum kc_sub_p, int kc_son_nr, int *kc_edge_nr, kc_dotedgenode_t *kc_edges, const char *edge_label_prefix)\
\n{\
\n    kc"), kc_current_view );
		  kc_printer(kc_t("_dotedgenode_t kc_hn;\
\n    char kc_buf[30];\
\n    kc_hn = kc_mkdotedgenode(fprintdot_hashtable, kc_p, kc_sub_p, kc_son_nr);\
\n    if (! kc_hn->label) {\
\n		kc_hn->label = new char[(size_t)(KC_PRIN"), kc_current_view );
		  kc_printer(kc_t("TDOT_LABELSIZE+1)];\
\n	kc_hn->lsize = KC_PRINTDOT_LABELSIZE;\
\n	strcpy(kc_hn->label, \"\");\
\n	kc_hn->next = *kc_edges;\
\n	*kc_edges = kc_hn;\
\n    } else {\
\n	char kc_buf2[30];\
\n	sprintf(kc_bu"), kc_current_view );
		  kc_printer(kc_t("f2, \", \");\
\n	strncat(kc_hn->label, kc_buf2, kc_hn->lsize - strlen(kc_hn->label));\
\n    }\
\n    if (edge_label_prefix) {\
\n	strncat(kc_hn->label, edge_label_prefix, kc_hn->lsize - strlen(kc_hn->"), kc_current_view );
		  kc_printer(kc_t("label));\
\n    }\
\n    sprintf(kc_buf, \"%d\", *kc_edge_nr);\
\n    strncat(kc_hn->label, kc_buf, kc_hn->lsize - strlen(kc_hn->label));\
\n    (*kc_edge_nr)++;\
\n}\
\n\
\nvoid impl_abstract_phylum::"), kc_current_view );
		  kc_printer(kc_t("printdot_add_edge(c_abstract_phylum kc_sub_p, int kc_son_nr, int *kc_edge_nr, kc_dotedgenode_t *kc_edges, const char *edge_label_prefix) const\
\n{\
\n  kc_do_printdot_do_add_edge(this, kc_sub_p, kc_so"), kc_current_view );
		  kc_printer(kc_t("n_nr, kc_edge_nr, kc_edges, edge_label_prefix);\
\n}\
\n\
\nvoid kc_do_printdot_edges(FILE *kc_f, kc_dotedgenode_t kc_edges, const char *edge_attributes, bool use_context_when_sharing_leaves)\
\n{\
\n "), kc_current_view );
		  kc_printer(kc_t("   kc_dotedgenode_t kc_p = kc_edges;\
\n    if (!kc_f) kc_f = stdout;\
\n    while(kc_p) {\
\n	kc_p->ptr_from->do_printdot_id(kc_f, use_context_when_sharing_leaves, 0, 0);\
\n	fprintf(kc_f, \":f%d -> \""), kc_current_view );
		  kc_printer(kc_t(", kc_p->son_nr);\
\n	kc_p->ptr_to->do_printdot_id(kc_f, use_context_when_sharing_leaves, kc_p->ptr_from, kc_p->son_nr);\
\n	fprintf(kc_f, \" [label=\\\"%s\\\"\", kc_p->label);\
\n	if (edge_attributes &"), kc_current_view );
		  kc_printer(kc_t("& (strlen(edge_attributes) > 0)) {\
\n	    fprintf(kc_f, \", %s\", edge_attributes);\
\n	}\
\n	fprintf(kc_f, \"];\\n\");\
\n	kc_p = kc_p->next;\
\n}   }\
\n\
\nvoid impl_abstract_phylum::do_printdot(FI"), kc_current_view );
		  kc_printer(kc_t("LE *kc_f, bool kc_outmost, int *kc_edge_nr, kc_dotedgenode_t *kc_edges, const char *edge_label_prefix, bool print_node_labels, bool use_context_when_sharing_leaves, c_abstract_phylum kc_ctxt, int kc_so"), kc_current_view );
		  kc_printer(kc_t("n_nr) const\
\n{\
\n    int kc_i;\
\n\
\n    if (!kc_f) kc_f = stdout;\
\n    switch(phylum()) {\
\n	case phylum_voidptr:\
\n	    do_printdot_id(kc_f, use_context_when_sharing_leaves, kc_ctxt, kc_son_n"), kc_current_view );
		  kc_printer(kc_t("r);\
\n	    fprintf(kc_f, \" [label=\\\"%p\\\", shape=ellipse];\\n\", dynamic_cast<c_voidptr>(this)->pointer);\
\n	    break;\
\n	case phylum_casestring:\
\n	case phylum_nocasestring:\
\n	    do_printd"), kc_current_view );
		  kc_printer(kc_t("ot_id(kc_f, use_context_when_sharing_leaves, kc_ctxt, kc_son_nr);\
\n#ifdef KC_UNICODE\
\n	    fprintf(kc_f, \" [label=\\\"%s\\\", shape=ellipse];\\n\", kc_to_cstring(static_cast<c_casestring>(this)->n"), kc_current_view );
		  kc_printer(kc_t("ame).c_str());\
\n#else\
\n	    fprintf(kc_f, \" [label=\\\"%s\\\", shape=ellipse];\\n\", static_cast<c_casestring>(this)->name);\
\n#endif\
\n	    break;\
\n	case phylum_integer:\
\n	    do_printdot_i"), kc_current_view );
		  kc_printer(kc_t("d(kc_f, use_context_when_sharing_leaves, kc_ctxt, kc_son_nr);\
\n	    fprintf(kc_f, \" [label=\\\"%i\\\", shape=ellipse];\\n\", ((integer)this)->value);\
\n	    break;\
\n	case phylum_real:\
\n	    do_"), kc_current_view );
		  kc_printer(kc_t("printdot_id(kc_f, use_context_when_sharing_leaves, kc_ctxt, kc_son_nr);\
\n	    fprintf(kc_f, \" [label=\\\"%f\\\", shape=ellipse];\\n\", ((real)this)->value);\
\n	    break;\
\n	default:\
\n	    if (!"), kc_current_view );
		  kc_printer(kc_t("subphylum(0)) {\
\n		do_printdot_id(kc_f, use_context_when_sharing_leaves, kc_ctxt, kc_son_nr);\
\n		fprintf(kc_f, \" [label=\\\"<f0>%s\\\"];\\n\", op_name());\
\n	    } else {\
\n		do_printdot_id(kc_f"), kc_current_view );
		  kc_printer(kc_t(", use_context_when_sharing_leaves, kc_ctxt, kc_son_nr);\
\n		fprintf(kc_f, \" [label=\\\"{<f0>%s|{\", op_name());\
\n			kc_do_printdot_genfields(kc_f, prod_sel(), print_node_labels);\
\n		fprintf(kc_f,"), kc_current_view );
		  kc_printer(kc_t(" \"}}\\\"];\\n\");\
\n                abstract_phylum child;\
\n		for (kc_i=0; (child = subphylum(kc_i)); kc_i++) {\
\n		    printdot_add_edge(child, kc_i+1, kc_edge_nr, kc_edges, edge_label_prefix );\
\n"), kc_current_view );
		  kc_printer(kc_t("		    child->do_printdot( kc_f, false, kc_edge_nr, kc_edges, edge_label_prefix, print_node_labels, use_context_when_sharing_leaves, this, kc_i+1 );\
\n		}\
\n	    }\
\n    }\
\n}\
\n"), kc_current_view); }
	    }
	    break;
	}
	case view_gen_printdotdecls_h_enum: {
	    view_gen_printdotdecls_h_class& kc_current_view=static_cast<view_gen_printdotdecls_h_class&>(kc_current_view_base);
	    {
		{ kc_printer(kc_t("\
\nvoid fprintdotprologue ( FILE* );\
\nvoid fprintdotepilogue ( FILE* );\
\n"), kc_current_view); }
	    }
	    break;
	}
	case view_gen_error_defs_c_enum: {
	    view_gen_error_defs_c_class& kc_current_view=static_cast<view_gen_error_defs_c_class&>(kc_current_view_base);
	    {
		const char *strof_phylum_error="Internal Error: unknown phylum number: ";
		int strlen_strof_phylum_error = static_cast<int>(strlen(strof_phylum_error)+30);
		casestring cstrof_phylum_error = mkcasestring(strof_phylum_error);
		const char *strof_operator_error="Internal Error: unknown operator number: ";
		int strlen_strof_operator_error = static_cast<int>(strlen(strof_operator_error)+30);
		casestring cstrof_operator_error = mkcasestring(strof_operator_error);

		{ kc_printer(kc_t("const char*\
\nphylumname_or_error(enum_phyla kc_phy)\
\n{\
\n    if ((kc_phy <= one_before_first_phylum) || (kc_phy >= last_phylum)) {\
\n	char *kc_strof_error;\
\n	sprintf((kc_strof_error=new char["), kc_current_view); }
		kc::unparse(strlen_strof_phylum_error, kc_printer, kc_current_view);
		{ kc_printer(kc_t("]), \""), kc_current_view); }
		kc::unparse(cstrof_phylum_error, kc_printer, kc_current_view);
		{ kc_printer(kc_t("%d\", kc_phy);\
\n	return kc_strof_error;\
\n    } else {\
\n	return phylum_info[kc_phy].name;\
\n}   }\
\n\
\n\
\nconst char*\
\nkc_operatorname_or_error(enum_operators kc_operator)\
\n{\
\n    if ((k"), kc_current_view );
		  kc_printer(kc_t("c_operator <= one_before_first_operator) || (kc_operator >= last_operator)) {\
\n	char *kc_strof_error;\
\n	sprintf((kc_strof_error=new char["), kc_current_view); }
		kc::unparse(strlen_strof_operator_error, kc_printer, kc_current_view);
		{ kc_printer(kc_t("]), \""), kc_current_view); }
		kc::unparse(cstrof_operator_error, kc_printer, kc_current_view);
		{ kc_printer(kc_t("%d\", kc_operator);\
\n	return kc_strof_error;\
\n    } else {\
\n	return operator_info[kc_operator].name;\
\n}   }\
\n\
\n"), kc_current_view); }
	    }
	    break;
	}
	case view_gen_error_decls_h_enum: {
	    view_gen_error_decls_h_class& kc_current_view=static_cast<view_gen_error_decls_h_class&>(kc_current_view_base);
	    {
		{ kc_printer(kc_t("const char *phylumname_or_error ( enum_phyla );\
\nconst char *kc_operatorname_or_error ( enum_operators );\
\n\
\n"), kc_current_view); }
	    }
	    break;
	}
	case view_gen_access_functions_enum: {
	    view_gen_access_functions_class& kc_current_view=static_cast<view_gen_access_functions_class&>(kc_current_view_base);
	    {
		const phylumdeclarations d = this->phylumdeclarations_1;
		{ kc_printer(kc_t("\
\nabstract_phylum\
\nkc_create(enum_operators createOp"), kc_current_view); }
		int j=Theargsnumbers->last()->value;
		if (j<2) j=2; 
		for (int i = 1; i<=j; ++i) 
		{
		    { kc_printer(kc_t(", abstract_phylum"), kc_current_view); }
		    { kc_printer(kc_t(" kc_p"), kc_current_view); }
		    kc::unparse(i, kc_printer, kc_current_view);
		}
		{ kc_printer(kc_t(")\
\n{\
\n    switch(createOp) {\r\
\n    case sel__VoidPtr:\
\n    case sel__Int:\
\n    case sel__Real:\
\n    case sel__Str:\
\n    case sel_NoCaseStr:\v\
\n	assertionFailed(\"Cannot create this kin"), kc_current_view );
		  kc_printer(kc_t("d of phylum - predefined phyla must be handled seperately\");break;\
\n"), kc_current_view); }
		kc::unparse(d, kc_printer, view_gen_create_function);
		{ kc_printer(kc_t("   \rdefault:\v\
\n	assertionFailed(\"Cannot create this kind of phylum - unkown operator id\");\
\n    }\
\n    NORETURN\
\n}\
\n\
\nabstract_phylum&\
\nattributeOf(abstract_phylum kc_p, int no)\
\n{\
\n"), kc_current_view); }



		count_printer counter;
		d->unparse(counter, view_gen_attributeOf_function);
		if (counter()==0) 
		{
		    { kc_printer(kc_t("assertionFailed(\"Cannot select attribute for this kind of phylum - has no attributes\");\
\n"), kc_current_view); }
		}
		else 
		{
		    { kc_printer(kc_t("   enum_operators kc_op = kc_p->prod_sel();\
\n    switch (kc_op) {\r\
\n"), kc_current_view); }
		    kc::unparse(d, kc_printer, view_gen_attributeOf_function);
		    { kc_printer(kc_t("   default:\v\
\n	assertionFailed(\"Cannot select attribute for this kind of phylum - unkown operator id or no attributes\");\
\n    }\
\n    assertionFailed(\"Cannot select attribute for this kind of"), kc_current_view );
		  kc_printer(kc_t(" phylum - attribute number out of range\");\
\n"), kc_current_view); }
		}
		{ kc_printer(kc_t("    NORETURN\
\n}\
\n"), kc_current_view); }
	    }
	    break;
	}
	case view_gen_operatordefs_c_enum: {
	    view_gen_operatordefs_c_class& kc_current_view=static_cast<view_gen_operatordefs_c_class&>(kc_current_view_base);
	    {
		const phylumdeclarations d = this->phylumdeclarations_1;
		kc::unparse(Thestorageclasses, kc_printer, view_gen_operatordefs_c_0);
		{ kc_printer(kc_t("\
\nbool kc_storageclass_still_uniq[] = {\
\n"), kc_current_view); }
		kc::unparse(Thestorageclasses, kc_printer, view_gen_operatordefs_c_1);
		{ kc_printer(kc_t(" };\
\n\
\nhashtable_t hashtables[] = {\
\n"), kc_current_view); }
		kc::unparse(Thestorageclasses, kc_printer, view_gen_operatordefs_c_2);
		{ kc_printer(kc_t("};\
\n\
\nconst char* kc_storageclassnames[] = { "), kc_current_view); }
		kc::unparse(Thestorageclasses, kc_printer, kc_current_view);
		{ kc_printer(kc_t(" };\
\n\
\nnamespace { // all local to k.cc\
\n\r\
\n"), kc_current_view); }
		kc::unparse(d, kc_printer, view_gen_initializephyla_c);
		{ kc_printer(kc_t("\
\n} // namespace\
\n\
\nenum_phyla\
\nimpl_abstract_phylum::phylum() const {\
\n	return operator_info[prod_sel()].phylum;\
\n}\
\n\
\nconst char*\
\nimpl_abstract_phylum::phylum_name() const {\
\n	re"), kc_current_view );
		  kc_printer(kc_t("turn phylum_info[phylum()].name;\
\n}\
\n\
\nconst char*\
\nimpl_abstract_phylum::op_name() const {\
\n	return operator_info[prod_sel()].name;\
\n}\
\n\
\ncasestring\
\nmkcasestring(const kc_char_t *kc"), kc_current_view );
		  kc_printer(kc_t("_s, int length)\
\n{\
\n    KC_COLLECT_STATS0(KC_CREATE_STATS(sel__Str));\
\n\
\n    casestring"), kc_current_view); }
		if(g_options.smart_pointer) 
		{
		    { kc_printer(kc_t("_ptr"), kc_current_view); }
		}
		{ kc_printer(kc_t(" kc_x=new impl_casestring__Str(kc_s);\
\n    if(length>=0) \
\n		kc_x->make_own(length);\
\n	\
\n    casestring unique_kc_x=hashtables[uniq]->ht_check_insert((casestring)kc_x);\
\n    if(unique_kc_x!=k"), kc_current_view );
		  kc_printer(kc_t("c_x) {\
\n		if(length<0) \
\n	kc_x->name=0;\
\n\
\n"), kc_current_view); }
		if(!g_options.smart_pointer) 
		{
		    { kc_printer(kc_t("	delete kc_x;\
\n"), kc_current_view); }
		}
		{ kc_printer(kc_t("	kc_x=unique_kc_x;\
\n    } else {\
\n	KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel__Str));\
\n		if(length<0) \
\n			kc_x->make_own(static_cast<int>(kc_strlen(kc_s)));\
\n\
\n	kc_x->post_create();\
\n"), kc_current_view );
		  kc_printer(kc_t("    }\
\n    return kc_x;\
\n}\
\n\
\nnocasestring\
\nmknocasestring(const kc_char_t *kc_s, int length)\
\n{\
\n    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_NoCaseStr));\
\n\
\n    nocasestring"), kc_current_view); }
		if(g_options.smart_pointer) 
		{
		    { kc_printer(kc_t("_ptr"), kc_current_view); }
		}
		{ kc_printer(kc_t(" kc_x=new impl_nocasestring_NoCaseStr(kc_s);\
\n	if(length>=0)\
\n		kc_x->make_own(length);\
\n    nocasestring unique_kc_x=hashtables[uniq]->ht_check_insert((nocasestring)kc_x);\
\n    if(unique_kc_x!"), kc_current_view );
		  kc_printer(kc_t("=kc_x) {\
\n		if(length<0)\
\n	kc_x->name=0;\
\n"), kc_current_view); }
		if(!g_options.smart_pointer) 
		{
		    { kc_printer(kc_t("	delete kc_x;\
\n"), kc_current_view); }
		}
		{ kc_printer(kc_t("	kc_x=unique_kc_x;\
\n    } else {\
\n	KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_NoCaseStr));\
\n		if(length<0)\
\n			kc_x->make_own(static_cast<int>(kc_strlen(kc_s)));\
\n	kc_x->post_create();\
\n"), kc_current_view );
		  kc_printer(kc_t("    }\
\n\
\n    return kc_x;\
\n}\
\n\
\ninteger\
\nmkinteger(const INTEGER kc_i)\
\n{\
\n    KC_COLLECT_STATS0(KC_CREATE_STATS(sel__Int));\
\n\
\n    integer kc_x =new impl_integer__Int(kc_i);\
\n   "), kc_current_view );
		  kc_printer(kc_t(" integer unique_kc_x=hashtables[uniq]->ht_check_insert(kc_x);\
\n    if(unique_kc_x!=kc_x) {\
\n"), kc_current_view); }
		if(!g_options.smart_pointer) 
		{
		    { kc_printer(kc_t("	delete kc_x;\
\n"), kc_current_view); }
		}
		{ kc_printer(kc_t("	kc_x=unique_kc_x;\
\n    } else {\
\n	KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel__Int));\
\n	kc_x->post_create();\
\n    }\
\n\
\n    return kc_x;\
\n}\
\n\
\nreal\
\nmkreal(const REAL kc_r)\
\n{"), kc_current_view );
		  kc_printer(kc_t("\
\n    KC_COLLECT_STATS0(KC_CREATE_STATS(sel__Real));\
\n\
\n    real kc_x=new impl_real__Real(kc_r);\
\n    real unique_kc_x=hashtables[uniq]->ht_check_insert(kc_x);\
\n    if(unique_kc_x!=kc_x) {\
\n"), kc_current_view); }
		if(!g_options.smart_pointer) 
		{
		    { kc_printer(kc_t("	delete kc_x;\
\n"), kc_current_view); }
		}
		{ kc_printer(kc_t("	kc_x=unique_kc_x;\
\n    } else {\
\n	KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel__Real));\
\n	kc_x->post_create();\
\n    }\
\n\
\n    return kc_x;\
\n}\
\n\
\nvoidptr\
\nmkvoidptr(void *kc_p)\
"), kc_current_view );
		  kc_printer(kc_t("\n{\
\n    KC_COLLECT_STATS0(KC_CREATE_STATS(sel__VoidPtr));\
\n    voidptr kc_x=new impl_voidptr__VoidPtr(kc_p);\
\n    voidptr unique_kc_x=hashtables[uniq]->ht_check_insert(kc_x);\
\n    if(unique_kc"), kc_current_view );
		  kc_printer(kc_t("_x!=kc_x) {\
\n"), kc_current_view); }
		if(!g_options.smart_pointer) 
		{
		    { kc_printer(kc_t("	delete kc_x;\
\n"), kc_current_view); }
		}
		{ kc_printer(kc_t("	kc_x=unique_kc_x;\
\n    } else {\
\n       KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel__VoidPtr));\
\n	kc_x->post_create();\
\n    }\
\n    return kc_x;\
\n}\
\n\
\n"), kc_current_view); }
		kc::unparse(d, kc_printer, kc_current_view);
		kc::unparse(this, kc_printer, view_gen_access_functions);
		{ kc_printer(kc_t("\
\nabstract_phylum\
\nimpl_abstract_phylum::subphylum(int) const\
\n{\
\n  return 0;\
\n}\
\n\
\nvoid\
\nimpl_abstract_phylum::set_subphylum(int,abstract_phylum)\
\n{\
\n}\
\n\
\nvoid\
\nimpl_abstract"), kc_current_view );
		  kc_printer(kc_t("_phylum::free(bool kc_rec)\
\n{\
\n    KC_COLLECT_STATS0(KC_FREE_CALLED_STATS(prod_sel(), kc_rec));\
\n"), kc_current_view); }
		if(g_options.smart_pointer) 
		{
		    { kc_printer(kc_t("	if(get_ref())\
\n		get_ref()->unlock();\
\n"), kc_current_view); }
		}
		{ kc_printer(kc_t("    if (!"), kc_current_view); }
		if(g_options.smart_pointer) 
		{
		    { kc_printer(kc_t("get_ref()"), kc_current_view); }
		}
		else 
		{
		    { kc_printer(kc_t("phylum_info[phylum()].uniq_stored"), kc_current_view); }
		}
		{ kc_printer(kc_t(") {\
\n"), kc_current_view); }
		if(!g_options.smart_pointer) 
		{
		    { kc_printer(kc_t("	if (kc_rec) {\
\n            abstract_phylum son;\
\n	    for (int kc_i=0; (son = subphylum(kc_i)); kc_i++)\
\n	    {\
\n		if (son!=0) son->free(kc_rec);\
\n		son=0;\
\n	    }\
\n	}\
\n"), kc_current_view); }
		}
		{ kc_printer(kc_t("	KC_COLLECT_STATS0(KC_FREED_STATS(prod_sel(), kc_rec));\
\n	delete this;\
\n	}\
\n}\
\n\
\nbool\
\nimpl_abstract_phylum::eq(c_abstract_phylum kc_p2) const\
\n{\
\n    if (this == kc_p2)\
\n		return tru"), kc_current_view );
		  kc_printer(kc_t("e;\
\n    if (prod_sel() != kc_p2->prod_sel())\
\n		return false;\
\n\
\n    int kc_st = phylum_info[phylum()].uniq_stored;\
\n    if (kc_st && kc_storageclass_still_uniq[kc_st])\
\n		return false;\
\n"), kc_current_view );
		  kc_printer(kc_t("\
\n    c_abstract_phylum son1;\
\n    for (int kc_i=0; (son1 = subphylum(kc_i)); kc_i++) {\
\n	if (!son1->eq(kc_p2->subphylum(kc_i)))\
\n	    return false;\
\n    }\
\n\
\n    return true;\
\n}\
\n\
\n"), kc_current_view );
		  kc_printer(kc_t("static string kc_indentation = \"\";\
\nstatic const char *kc_printformat_not_nullary_open = \"%s%s(\\n\";\
\nstatic const char *kc_printformat_list_open = \"%s%s\\n\";\
\n\
\nstatic const char *kc_pri"), kc_current_view );
		  kc_printer(kc_t("ntformat_not_nullary_close = \"%s)\\n\";\
\nstatic const char *kc_printformat_nullary = \"%s%s()\\n\";\
\n\
\nvoid\
\nimpl_abstract_phylum::fprint(FILE*kc_f)\
\n{\
\n    int kc_i;\
\n\
\n    if (!kc_f)"), kc_current_view );
		  kc_printer(kc_t(" kc_f = stdout;\
\n    abstract_list al = dynamic_cast<abstract_list>(this);\
\n    if (al != 0 && !al->is_nil()) {\
\n	fprintf(kc_f, kc_printformat_list_open, kc_indentation.c_str(), op_name());\
\n	k"), kc_current_view );
		  kc_printer(kc_t("c_indentation+=\"| \";\
\n	subphylum(0)->fprint(kc_f);\
\n	kc_indentation=kc_indentation.substr(0, kc_indentation.length()-2);\
\n	phylum_cast<abstract_list>(subphylum(1))->fprint_list(kc_f);\
\n	kc_in"), kc_current_view );
		  kc_printer(kc_t("dentation=kc_indentation.substr(0, kc_indentation.length()-2);\
\n    } else // not list\
\n    switch(phylum()) {\
\n	case phylum_voidptr:\
\n	    \vfprintf(kc_f, \"%s%p\\n\", kc_indentation.c_str(), "), kc_current_view );
		  kc_printer(kc_t("static_cast<voidptr>(this)->pointer);\
\n	    break;\r\
\n	case phylum_casestring:\
\n	case phylum_nocasestring:\
\n	    \vfprintf(kc_f, \"%s%s\\n\", kc_indentation.c_str(), static_cast<casestring>(thi"), kc_current_view );
		  kc_printer(kc_t("s)->name);\
\n	    break;\r\
\n	case phylum_integer:\
\n	    \vfprintf(kc_f, \"%s%i\\n\", kc_indentation.c_str(), static_cast<integer>(this)->value);\
\n	    break;\r\
\n	case phylum_real:\
\n	    \vfp"), kc_current_view );
		  kc_printer(kc_t("rintf(kc_f, \"%s%f\\n\", kc_indentation.c_str(), static_cast<real>(this)->value);\
\n	    break;\r\
\n	default:\
\n	    \vif (!subphylum(0)) {\
\n		fprintf(kc_f, kc_printformat_nullary, kc_indentation."), kc_current_view );
		  kc_printer(kc_t("c_str(), op_name());\
\n	    } else {\
\n		fprintf(kc_f, kc_printformat_not_nullary_open, kc_indentation.c_str(), op_name());\
\n		kc_indentation+=\"  \";\
\n		abstract_phylum son;\
\n		for (kc_i=0; (s"), kc_current_view );
		  kc_printer(kc_t("on = subphylum(kc_i)); kc_i++) {\
\n		    son->fprint(kc_f);\
\n		}\
\n		kc_indentation=kc_indentation.substr(0, kc_indentation.length()-2);\
\n		fprintf(kc_f, kc_printformat_not_nullary_close, kc_inde"), kc_current_view );
		  kc_printer(kc_t("ntation.c_str());\
\n	    }\r\
\n    }\
\n}\
\n\
\nvoid \
\nimpl_abstract_phylum::print()\
\n{\
\n  fprint(stdout);\
\n}\
\n\
\nvoid \
\nimpl_abstract_list::fprint_list(FILE*kc_f)\
\n{\
\n    if (!kc_f"), kc_current_view );
		  kc_printer(kc_t(")\
\n	kc_f = stdout;\
\n    if (this->is_nil()) {\
\n	kc_indentation+=\"`-\";\
\n	fprintf(kc_f, kc_printformat_nullary, kc_indentation.c_str(), op_name());\
\n    } else {\
\n	kc_indentation+=\"|-\";\
\n"), kc_current_view );
		  kc_printer(kc_t("	fprintf(kc_f, kc_printformat_list_open, kc_indentation.c_str(), op_name());\
\n	kc_indentation=kc_indentation.substr(0, kc_indentation.length()-2);\
\n	kc_indentation+=\"| \";\
\n	subphylum(0)->fprint"), kc_current_view );
		  kc_printer(kc_t("(kc_f);\
\n	kc_indentation=kc_indentation.substr(0, kc_indentation.length()-2);\
\n	phylum_cast<abstract_list>(subphylum(1))->fprint_list(kc_f);\
\n    }\
\n}\
\n\
\nint\
\nimpl_abstract_list::length()"), kc_current_view );
		  kc_printer(kc_t(" const\
\n{\
\n    int kc_length = 0;\
\n    c_abstract_phylum kc_p = this;\
\n    while((kc_p = kc_p->subphylum(1)))\
\n	kc_length++;\
\n    return kc_length;\
\n}\
\n"), kc_current_view); }
		if(g_options.smart_pointer) 
		{
		    { kc_printer(kc_t("void impl_abstract_list::freelist() { }\n"), kc_current_view); }
		}
		else 
		{
		    { kc_printer(kc_t("void impl_abstract_list::freelist()\
\n{\
\n    abstract_phylum kc_p = this, kc_tmp_p;\
\n    do {\
\n	kc_tmp_p=kc_p->subphylum(1);\
\n	kc_p->free(false);\
\n	kc_p=kc_tmp_p;\
\n    } while(kc_p);\
\n}\
\n"), kc_current_view); }
		}
		{ kc_printer(kc_t("abstract_phylum\
\nimpl_abstract_list::do_concat(c_abstract_phylum kc_p2, enum_operators mk) const\
\n{\
\n    abstract_phylum next = subphylum(1);\
\n    if(!next)\
\n	return const_cast<abstract_phyl"), kc_current_view );
		  kc_printer(kc_t("um>(kc_p2);\
\n    return kc_create(mk, subphylum(0), static_cast<abstract_list>(next)->do_concat(kc_p2, mk));\
\n}\
\n\
\nabstract_phylum\
\nimpl_abstract_list::do_reverse(c_abstract_phylum tail, enum"), kc_current_view );
		  kc_printer(kc_t("_operators mk) const\
\n{\
\n    for (impl_abstract_list const* iterator_ = this; iterator_->subphylum(1) != 0;\
\n	    iterator_ = static_cast<impl_abstract_list const*>(iterator_->subphylum(1)) )\
\n"), kc_current_view );
		  kc_printer(kc_t("	tail = kc_create(mk, iterator_->subphylum(0), const_cast<abstract_phylum>(tail));\
\n    return const_cast<abstract_phylum>(tail);\
\n}\
\n\
\nabstract_phylum\
\nimpl_abstract_list::last() const\
\n{\
\n"), kc_current_view );
		  kc_printer(kc_t("    c_abstract_phylum kc_p = this, next = subphylum(1), nextnext;\
\n#ifdef _AFX\
\n    ASSERT(next);\
\n    if(!next)\
\n	return NULL;\
\n#else\
\n    if(!next){\
\n	fflush(stdout);\
\n	fprintf(stderr"), kc_current_view );
		  kc_printer(kc_t(", \"Internal Error: list::last was called with argument Nil%s\\n\", phylum_name());\
\n	exit(1);\
\n    }\
\n#endif\
\n    while ((nextnext = next->subphylum(1))) {\
\n	kc_p = next;\
\n	next = nextnext"), kc_current_view );
		  kc_printer(kc_t(";\
\n    }\
\n    return const_cast<abstract_phylum>(kc_p->subphylum(0));/* XXX remove cast */\
\n}\
\n\
\nabstract_phylum\
\nimpl_abstract_list::do_map(abstract_phylum (*kc_fp)(abstract_phylum), enum_"), kc_current_view );
		  kc_printer(kc_t("operators mk)\
\n{\
\n    abstract_phylum el = subphylum(0);\
\n    if (!el)\
\n	return this;\
\n    abstract_list next = static_cast<abstract_list>(subphylum(1));\
\n    return kc_create(mk, kc_fp(el)"), kc_current_view );
		  kc_printer(kc_t(", next->do_map(kc_fp, mk));\
\n}\
\n\
\nabstract_phylum\
\nimpl_abstract_list::do_filter(bool (*kc_fp)(abstract_phylum), enum_operators mk)\
\n{\
\n    abstract_phylum el = subphylum(0);\
\n    if (!el"), kc_current_view );
		  kc_printer(kc_t(")\
\n	return this;\
\n    abstract_list next = static_cast<abstract_list>(subphylum(1));\
\n    if ((*kc_fp)(el)) {\
\n	return kc_create(mk, el, next->do_filter(kc_fp, mk));\
\n    } else {\
\n	return "), kc_current_view );
		  kc_printer(kc_t("next->do_filter(kc_fp, mk);\
\n    }\
\n}\
\n\
\nabstract_list\
\nimpl_abstract_list::do_append(abstract_phylum new_last, abstract_list eol)\
\n{\
\n    abstract_list next = this;\
\n    while (!next->"), kc_current_view );
		  kc_printer(kc_t("is_nil())\
\n	next = phylum_cast<abstract_list>(next->subphylum(1));\
\n    next->set_subphylum(0, new_last);\
\n    next->set_subphylum(1, eol);\
\n    return next;\
\n}\
\n\
\nabstract_phylum\
\nimpl"), kc_current_view );
		  kc_printer(kc_t("_abstract_list::do_merge(abstract_list second,abstract_phylum(*kc_fp)(abstract_phylum,abstract_phylum), enum_operators mk)\
\n{\
\n    abstract_phylum el = subphylum(0);\
\n    if (!el)\
\n	return this"), kc_current_view );
		  kc_printer(kc_t(";\
\n    abstract_phylum el2 = second->subphylum(0);\
\n    if (!el2)\
\n	return el2;\
\n    abstract_list next = static_cast<abstract_list>(subphylum(1));\
\n    abstract_list next2 = static_cast<abst"), kc_current_view );
		  kc_printer(kc_t("ract_list>(second->subphylum(1));\
\n    return kc_create(mk, kc_fp(el,el2), next->do_merge(next2, kc_fp, mk));\
\n}\
\n\
\nabstract_phylum\
\nimpl_abstract_list::do_reduce(abstract_phylum neutral, abs"), kc_current_view );
		  kc_printer(kc_t("tract_phylum(*kc_fp)(abstract_phylum,abstract_phylum)) {\
\n    abstract_phylum el = subphylum(0);\
\n    if (!el)\
\n	return neutral;\
\n    abstract_list next = static_cast<abstract_list>(subphylum(1"), kc_current_view );
		  kc_printer(kc_t("));\
\n    return kc_fp(el,next->do_reduce(neutral,kc_fp));\
\n}\
\n\
\n"), kc_current_view); }
	    }
	    break;
	}
	case view_gen_operatorcast_h_enum: {
	    view_gen_operatorcast_h_class& kc_current_view=static_cast<view_gen_operatorcast_h_class&>(kc_current_view_base);
	    {
		const phylumdeclarations d = this->phylumdeclarations_1;
		{ kc_printer(kc_t("/* translation of file(s)\n"), kc_current_view); }
		kc::unparse(Thefnfiles, kc_printer, kc_current_view);
		{ kc_printer(kc_t(" */\
\n/* generated by:\
\n *  "), kc_current_view); }
		kc::unparse(kimwitu_copyright, kc_printer, kc_current_view);
		{ kc_printer(kc_t("\
\n */\
\n#ifndef KC_OPERATOR_CAST_HEADER\
\n#define KC_OPERATOR_CAST_HEADER\
\n#include \""), kc_current_view); }
		PRINT(g_options.prefix.c_str()); 
			{ kc_printer(kc_t("k.h\"         // in case a user forgets\
\n#include <typeinfo>   // for bad_cast\
\n\
\n"), kc_current_view); }
		kc::unparse(d, kc_printer, kc_current_view);
		{ kc_printer(kc_t("#endif // KC_OPERATOR_CAST_HEADER\n\n"), kc_current_view); }
	    }
	    break;
	}
	case view_gen_operatordecls_h_enum: {
	    view_gen_operatordecls_h_class& kc_current_view=static_cast<view_gen_operatordecls_h_class&>(kc_current_view_base);
	    {
		const phylumdeclarations d = this->phylumdeclarations_1;
		{ kc_printer(kc_t("\
\ncasestring mkcasestring( const kc_char_t *, int length = -1);\
\nnocasestring mknocasestring( const kc_char_t *, int length = -1);\
\ninteger mkinteger( const INTEGER );\
\nreal mkreal( const REAL "), kc_current_view );
		  kc_printer(kc_t(");\
\ninline casestring _Str( const kc_char_t * cc) { return mkcasestring(cc); }\
\ninline nocasestring NoCaseStr( const kc_char_t * cc) { return mknocasestring(cc); }\
\ninline integer _Int( const INT"), kc_current_view );
		  kc_printer(kc_t("EGER cc) { return mkinteger(cc); }\
\ninline real _Real( const REAL cc) { return mkreal(cc); }\
\n"), kc_current_view); }
		kc::unparse(d, kc_printer, kc_current_view);
	    }
	    break;
	}
	case view_gen_assertmacros_c_enum: {
	    view_gen_assertmacros_c_class& kc_current_view=static_cast<view_gen_assertmacros_c_class&>(kc_current_view_base);
	    {
		{ kc_printer(kc_t("\
\nvoid\
\nkc_no_default_in_with( const char *kc_func, int kc_line, const char *kc_file )\
\n{\
\n    fflush(stdout);\
\n#ifdef _AFX\
\n	USES_CONVERSION;\
\n	const _TCHAR* format=A2CT(KC_NO_DEFAULT_IN"), kc_current_view );
		  kc_printer(kc_t("_WITH);\
\n	const _TCHAR* tkc_func=A2CT(kc_func);\
\n	const _TCHAR* tkc_file=A2CT(kc_file);\
\n	TRACE( format, tkc_func, tkc_file, kc_line );\
\n#ifdef _DEBUG\
\n    if (AfxAssertFailedLine(kc_file, kc"), kc_current_view );
		  kc_printer(kc_t("_line))\
\n#endif\
\n	AfxDebugBreak();\
\n#else\
\n    fprintf( stderr, KC_NO_DEFAULT_IN_WITH, kc_func, kc_file, kc_line );\
\n#ifndef KC_NODEFAULT_NO_ABORT\
\n    abort();\
\n#else\
\n    exit( 1 );\
\n"), kc_current_view );
		  kc_printer(kc_t("#endif\
\n#endif\
\n}\
\n\
\nvoid\
\nkc_returnless_function( const char *kc_func, int kc_line, const char *kc_file )\
\n{\
\n    fflush(stdout);\
\n#ifdef _AFX\
\n	USES_CONVERSION;\
\n	const _TCHAR* fo"), kc_current_view );
		  kc_printer(kc_t("rmat=_T(\"Internal Error: function %s does not return a value, at %s:%d\");\
\n	const _TCHAR* tkc_func=A2CT(kc_func);\
\n	const _TCHAR* tkc_file=A2CT(kc_file);\
\n	TRACE( format, tkc_func, tkc_file, kc"), kc_current_view );
		  kc_printer(kc_t("_line );\
\n#ifdef _DEBUG\
\n    if (AfxAssertFailedLine(kc_file, kc_line))\
\n#endif\
\n	AfxDebugBreak();\
\n#else\
\n    fprintf( stderr, \"Internal Error: function %s does not return a value, at %s:"), kc_current_view );
		  kc_printer(kc_t("%d\", kc_func, kc_file, kc_line );\
\n#ifndef KC_NODEFAULT_NO_ABORT\
\n    abort();\
\n#else\
\n    exit( 1 );\
\n#endif\
\n#endif\
\n}\
\n\
\nvoid\
\nkc_assertionFailed(const char *kc_fn, int kc_l)\
\n"), kc_current_view );
		  kc_printer(kc_t("{\
\n    fflush(stdout);\
\n#ifdef _AFX\
\n	USES_CONVERSION;\
\n	const _TCHAR* format=_T(\"Internal Error: Assertion failed at %s:%d\\n\");\
\n	const _TCHAR* tkc_func=A2CT(kc_fn);\
\n	TRACE( format, tk"), kc_current_view );
		  kc_printer(kc_t("c_func, kc_l );\
\n#ifdef _DEBUG\
\n    if (AfxAssertFailedLine(kc_fn, kc_l))\
\n#endif\
\n	AfxDebugBreak();\
\n#else\
\n    fprintf( stderr, \"Internal Error: Assertion failed at %s:%d\\n\", kc_fn, kc"), kc_current_view );
		  kc_printer(kc_t("_l );\
\n#ifndef KC_ASSERT_NO_ABORT\
\n    abort();\
\n#else\
\n    exit( 1 );\
\n#endif\
\n#endif\
\n}\
\n\
\nvoid\
\nkc_assertionReasonFailed(const char *kc_fn, int kc_l, const char *kc_s)\
\n{\
\n  "), kc_current_view );
		  kc_printer(kc_t("  fflush(stdout);\
\n#ifdef _AFX\
\n	USES_CONVERSION;\
\n	const _TCHAR* format=_T(\"Internal Error: Assertion failed at file %s:%d: %s\\n\");\
\n	const _TCHAR* tkc_func=A2CT(kc_fn);\
\n	const _TCHAR* t"), kc_current_view );
		  kc_printer(kc_t("kc_s=A2CT(kc_s);\
\n	TRACE( format, tkc_func, kc_l, tkc_s );\
\n#ifdef _DEBUG\
\n    if (AfxAssertFailedLine(kc_fn, kc_l))\
\n#endif\
\n	AfxDebugBreak();\
\n#else\
\n    fprintf( stderr, \"Internal Err"), kc_current_view );
		  kc_printer(kc_t("or: Assertion failed at file %s:%d: %s\\n\", kc_fn, kc_l, kc_s );\
\n#ifndef KC_ASSERT_NO_ABORT\
\n    abort();\
\n#else\
\n    exit( 1 );\
\n#endif\
\n#endif\
\n}\
\n\
\nvoid\
\nkc_assertionNonNullFai"), kc_current_view );
		  kc_printer(kc_t("led(const char *kc_fn, int kc_l, const char *kc_str)\
\n{\
\n    fflush(stdout);\
\n#ifdef _AFX\
\n	USES_CONVERSION;\
\n	const _TCHAR* format=_T(\"Internal Error: Assertion failed at %s:%d: pointer %s "), kc_current_view );
		  kc_printer(kc_t("is NULL\\n\");\
\n	const _TCHAR* tkc_func=A2CT(kc_fn);\
\n	const _TCHAR* tkc_s=A2CT(kc_str);\
\n	TRACE( format , tkc_func, kc_l, tkc_s);\
\n#ifdef _DEBUG\
\n    if (AfxAssertFailedLine(kc_fn, kc_l))\
\n"), kc_current_view );
		  kc_printer(kc_t("#endif\
\n	AfxDebugBreak();\
\n#else\
\n    fprintf( stderr, \"Internal Error: Assertion failed at %s:%d: pointer %s is NULL\\n\", kc_fn, kc_l, kc_str );\
\n#ifndef KC_ASSERT_NO_ABORT\
\n    abort();\
\n"), kc_current_view );
		  kc_printer(kc_t("#else\
\n    exit( 1 );\
\n#endif\
\n#endif\
\n}\
\n\
\nvoid\
\nkc_assertionOperatorInPhylumFailed(int kc_op, const char *kc_str1, const char *kc_str2, const char *kc_phy, const char *kc_fn, int kc_l)\
\n"), kc_current_view );
		  kc_printer(kc_t("{\
\n    fflush(stdout);\
\n#ifdef _AFX\
\n    USES_CONVERSION;\
\n    const _TCHAR* format=_T(\"Internal Error: Assertion failed at %s:%d: illegal value for (%s) %s%s: %d not a valid operator\\n\");\
\n"), kc_current_view );
		  kc_printer(kc_t("    const _TCHAR* tkc_func=A2CT(kc_fn);\
\n    const _TCHAR* tkc_s1=A2CT(kc_str1);\
\n    const _TCHAR* tkc_s2=A2CT(kc_str2);\
\n    const _TCHAR* tname=A2CT(kc_phy);\
\n    if ((kc_op <= one_before_fi"), kc_current_view );
		  kc_printer(kc_t("rst_operator) || (kc_op >= last_operator)) {\
\n	TRACE (format, tkc_func, kc_l, tname, tkc_s1, tkc_s2, kc_op );\
\n    } else {\
\n	format=_T(\"Internal Error: Assertion failed at %s:%d: illegal value "), kc_current_view );
		  kc_printer(kc_t("for (%s) %s%s: %s (%d) is a value of %s\\n\");\
\n	const _TCHAR* tname2=A2CT(operator_info[kc_op].name);\
\n	const _TCHAR* tname3=A2CT(phylum_info[operator_info[kc_op].phylum].name);\
\n	TRACE(format,t"), kc_current_view );
		  kc_printer(kc_t("kc_func, kc_l, tname, tkc_s1, tkc_s2, tname2, kc_op, tname3 );\
\n    }\
\n#ifdef _DEBUG\
\n	if (AfxAssertFailedLine(kc_fn, kc_l))\
\n#endif\
\n		AfxDebugBreak();\
\n#else\
\n    if ((kc_op <= one_befo"), kc_current_view );
		  kc_printer(kc_t("re_first_operator) || (kc_op >= last_operator)) {\
\n	fprintf( stderr, \"Internal Error: Assertion failed at %s:%d: illegal value for (%s) %s%s: %d not a valid operator\\n\",\
\n		kc_fn, kc_l, kc_phy, "), kc_current_view );
		  kc_printer(kc_t("kc_str1, kc_str2, kc_op );\
\n    } else {\
\n	fprintf( stderr, \"Internal Error: Assertion failed at %s:%d: illegal value for (%s) %s%s: %s (%d) is a value of %s\\n\",\
\n		kc_fn, kc_l, kc_phy, kc_str"), kc_current_view );
		  kc_printer(kc_t("1, kc_str2, operator_info[kc_op].name, kc_op, phylum_info[operator_info[kc_op].phylum].name );\
\n    }\
\n#ifndef KC_ASSERT_NO_ABORT\
\n    abort();\
\n#else\
\n    exit( 1 );\
\n#endif\
\n#endif\
\n}"), kc_current_view );
		  kc_printer(kc_t("\
\n\
\nvoid kc_invalid_operator( const char *kc_func_prefix, enum_phyla kc_phy, int kc_line, const char *kc_file, enum_operators kc_oper )\
\n{\
\n    fflush(stdout);\
\n#ifdef _AFX\
\n    USES_CONVER"), kc_current_view );
		  kc_printer(kc_t("SION;\
\n    const _TCHAR* format=_T(\"Internal Error: invalid operator code in %s%s at %s:%d: %s\\n\");\
\n    const _TCHAR* tkc_func=A2CT(kc_func_prefix);\
\n    const _TCHAR* tkc_file=A2CT(kc_file);"), kc_current_view );
		  kc_printer(kc_t("\
\n    const _TCHAR* ts1=A2CT(phylumname_or_error( kc_phy ));\
\n    const _TCHAR* ts2=A2CT(kc_operatorname_or_error( kc_oper ));\
\n    TRACE( format, tkc_func, ts1, tkc_file, kc_line, ts2);\
\n#ifde"), kc_current_view );
		  kc_printer(kc_t("f _DEBUG\
\n    if (AfxAssertFailedLine(kc_file, kc_line))\
\n#endif\
\n	AfxDebugBreak();\
\n#else\
\n    fprintf( stderr, \"Internal Error: invalid operator code in %s%s at %s:%d: %s\\n\", kc_func_pre"), kc_current_view );
		  kc_printer(kc_t("fix, phylumname_or_error( kc_phy ), kc_file, kc_line, kc_operatorname_or_error( kc_oper ));\
\n#ifndef KC_INVALID_OPERATOR_NO_ABORT\
\n    abort();\
\n#else\
\n    exit( 1 );\
\n#endif\
\n#endif\
\n}\
\n"), kc_current_view); }
	    }
	    break;
	}
	case view_gen_assertmacros_h_enum: {
	    view_gen_assertmacros_h_class& kc_current_view=static_cast<view_gen_assertmacros_h_class&>(kc_current_view_base);
	    {
		const phylumdeclarations d = this->phylumdeclarations_1;
		{ kc_printer(kc_t("\
\n#ifndef KC_NO_DEFAULT_IN_WITH\
\n# define KC_NO_DEFAULT_IN_WITH \"Internal Error: no default action defined in function %s at %s:%d\\n\"\
\n#endif\
\nvoid kc_no_default_in_with (const char*, int, "), kc_current_view );
		  kc_printer(kc_t("const char*);\
\nvoid kc_returnless_function (const char *, int, const char*);\
\n\
\n#ifndef NDEBUG\
\n# define assertCond(t) do {if (!(t)) kc_assertionFailed(__FILE__,__LINE__);}while(false)\
\n# def"), kc_current_view );
		  kc_printer(kc_t("ine assertReason(t,s) do {if (!(t)) kc_assertionReasonFailed(__FILE__,__LINE__,s);}while(false)\
\n# define assertNonNull(p) do {if (p == 0) kc_assertionNonNullFailed(__FILE__,__LINE__,#p);}while(false"), kc_current_view );
		  kc_printer(kc_t(")\
\n# define assertPhylum(ptr,phy) do { \\\
\n    assertNonNull(ptr); \\\
\n    if (ptr->phylum()!=phy) \\\
\n	kc_assertionOperatorInPhylumFailed(ptr->prod_sel(),#ptr,\"->prod_sel()\",\"phy\",__FILE__"), kc_current_view );
		  kc_printer(kc_t(",__LINE__); \\\
\n    } while(false)\
\n#else\
\n# define assertCond(t)\
\n# define assertReason(t,s)\
\n# define assertNonNull(ptr)\
\n# define assertPhylum(op,phy)\
\n#endif\
\n#define assertionFaile"), kc_current_view );
		  kc_printer(kc_t("d(s) kc_assertionReasonFailed(__FILE__,__LINE__,s)\
\n\r\
\nvoid kc_assertionFailed (const char*, int) __attribute__ ((noreturn));\
\nvoid kc_assertionReasonFailed (const char*, int, const char*) __att"), kc_current_view );
		  kc_printer(kc_t("ribute__ ((noreturn));\
\nvoid kc_assertionNonNullFailed (const char*, int, const char*) __attribute__ ((noreturn));\
\nvoid kc_assertionOperatorInPhylumFailed (int, const char*, const char*, const cha"), kc_current_view );
		  kc_printer(kc_t("r*, const char*, int) __attribute__ ((noreturn));\
\n"), kc_current_view); }
	    }
	    break;
	}
	case view_gen_noofoperators_h_enum: {
	    view_gen_noofoperators_h_class& kc_current_view=static_cast<view_gen_noofoperators_h_class&>(kc_current_view_base);
	    {
		{ kc_printer(kc_t("#define KC_NO_OF_OPERATORS "), kc_current_view); }
		kc::unparse(g_no_of_operators, kc_printer, kc_current_view);
		{ kc_printer(kc_t("\
\n\
\n"), kc_current_view); }
	    }
	    break;
	}
	case view_gen_yaccstacktype_h_enum: {
	    view_gen_yaccstacktype_h_class& kc_current_view=static_cast<view_gen_yaccstacktype_h_class&>(kc_current_view_base);
	    {
		const phylumdeclarations d = this->phylumdeclarations_1;
		{ kc_printer(kc_t("#ifndef YYSTYPE_HEADER\
\n#define YYSTYPE_HEADER\
\nunion KC_YYSTYPE {\
\n"), kc_current_view); }
		kc::unparse(d, kc_printer, kc_current_view);
		{ kc_printer(kc_t("};\
\n#define YYSTYPE KC_YYSTYPE\
\n#endif // YYSTYPE_HEADER\
\n"), kc_current_view); }
	    }
	    break;
	}
	case view_gen_nodetypes_h_enum: {
	    view_gen_nodetypes_h_class& kc_current_view=static_cast<view_gen_nodetypes_h_class&>(kc_current_view_base);
	    {
		const phylumdeclarations d = this->phylumdeclarations_1;
	    }
	    break;
	}
	case view_gen_nodetypedefs_h_enum: {
	    view_gen_nodetypedefs_h_class& kc_current_view=static_cast<view_gen_nodetypedefs_h_class&>(kc_current_view_base);
	    {
		const phylumdeclarations d = this->phylumdeclarations_1;
		if(!g_options.no_printdot) 
		{
		    { kc_printer(kc_t("typedef class impl_kc_dotedgenode_t *kc_dotedgenode_t;\
\n"), kc_current_view); }
		}
		{ kc_printer(kc_t("\
\n"), kc_current_view); }
		kc::unparse(d, kc_printer, kc_current_view);
		{ kc_printer(kc_t("\
\n"), kc_current_view); }
	    }
	    break;
	}
	case view_gen_operatormap_c_enum: {
	    view_gen_operatormap_c_class& kc_current_view=static_cast<view_gen_operatormap_c_class&>(kc_current_view_base);
	    {
		const phylumdeclarations d = this->phylumdeclarations_1;
		kc::unparse(d, kc_printer, view_gen_operatormap_subphyla);
		kc::unparse(d, kc_printer, view_gen_operatormap_attributes);
		{ kc_printer(kc_t("\
\n\
\nKC_OPERATOR_INFO operator_info[] = {\
\n"), kc_current_view); }
		{
		    int i = OPERATORNUMBEROFFSET; do 
		    {
			{ kc_printer(kc_t("    { \"\", 0, 0, one_before_first_phylum, 0, 0, 0, 0 }, /* dummy element */\
\n"), kc_current_view); }
			i--; 
			 }
		    while (i >= 0); 
		     }
		kc::unparse(d, kc_printer, kc_current_view);
		{ kc_printer(kc_t("    { \"\", 0, 0, one_before_first_phylum, 0, 0, 0, 0 } /* last element */\
\n};\
\n\
\n"), kc_current_view); }
	    }
	    break;
	}
	case view_gen_phylummap_c_enum: {
	    view_gen_phylummap_c_class& kc_current_view=static_cast<view_gen_phylummap_c_class&>(kc_current_view_base);
	    {
		const phylumdeclarations d = this->phylumdeclarations_1;
		{ kc_printer(kc_t("KC_PHYLUM_INFO phylum_info[] = {\
\n"), kc_current_view); }
		{
		    int i = PHYLUMNUMBEROFFSET; do 
		    {

			{ kc_printer(kc_t("    { \"\", one_before_first_operator, one_before_first_operator, (kc_storageclass_t)0 }, /* dummy element */\
\n"), kc_current_view); }
			i--; 
			 }
		    while (i >= 0); 
		     }
		kc::unparse(d, kc_printer, kc_current_view);
		{ kc_printer(kc_t("    { \"\", one_before_first_operator, one_before_first_operator, (kc_storageclass_t)0 } /* last element */\
\n};\
\n\
\n"), kc_current_view); }
	    }
	    break;
	}
	case view_gen_operatormap_type_h_enum: {
	    view_gen_operatormap_type_h_class& kc_current_view=static_cast<view_gen_operatormap_type_h_class&>(kc_current_view_base);
	    {
	    }
	    break;
	}
	case view_gen_enumoperators_h_enum: {
	    view_gen_enumoperators_h_class& kc_current_view=static_cast<view_gen_enumoperators_h_class&>(kc_current_view_base);
	    {
		const phylumdeclarations pds = this->phylumdeclarations_1;
		g_no_of_operators = OPERATORNUMBEROFFSET; 
			{ kc_printer(kc_t("typedef enum { one_before_first_operator = "), kc_current_view); }
		kc::unparse(g_no_of_operators, kc_printer, kc_current_view);
		{ kc_printer(kc_t(" ,\
\n"), kc_current_view); }
		g_no_of_operators++; 
		kc::unparse(pds, kc_printer, kc_current_view);
		{ kc_printer(kc_t("    last_operator = "), kc_current_view); }
		kc::unparse(g_no_of_operators, kc_printer, kc_current_view);
		{ kc_printer(kc_t("\
\n} enum_operators;\
\n"), kc_current_view); }
	    }
	    break;
	}
	case view_gen_enumphyla_h_enum: {
	    view_gen_enumphyla_h_class& kc_current_view=static_cast<view_gen_enumphyla_h_class&>(kc_current_view_base);
	    {
		const phylumdeclarations pds = this->phylumdeclarations_1;
		g_no_of_phyla = PHYLUMNUMBEROFFSET; 
			{ kc_printer(kc_t("typedef enum { one_before_first_phylum = "), kc_current_view); }
		kc::unparse(g_no_of_phyla, kc_printer, kc_current_view);
		{ kc_printer(kc_t(" ,\
\n"), kc_current_view); }
		g_no_of_phyla++; 
		kc::unparse(pds, kc_printer, kc_current_view);
		{ kc_printer(kc_t("    last_phylum = "), kc_current_view); }
		kc::unparse(g_no_of_phyla, kc_printer, kc_current_view);
		{ kc_printer(kc_t("\
\n} enum_phyla;\
\n\
\n"), kc_current_view); }
	    }
	    break;
	}
	case view_gen_alloc_c_enum: {
	    view_gen_alloc_c_class& kc_current_view=static_cast<view_gen_alloc_c_class&>(kc_current_view_base);
	    {
		{ kc_printer(kc_t("\
\n#ifdef KC_STATISTICS\
\nKC_OPERATOR_STATISTICS operator_statistics[KC_NO_OF_OPERATORS];\
\nstatic int kc_casestring_strlen =0;\
\nstatic int kc_nocasestring_strlen =0;\
\n#  define KC_COLLECT_STATS"), kc_current_view );
		  kc_printer(kc_t("0(v) v\
\n#else\
\n#  define KC_COLLECT_STATS0(v)\
\n#endif\
\n\
\n#ifndef KC_CREATE_STATS\
\n#  define KC_CREATE_STATS(oper) operator_statistics[oper].created++;\
\n#endif\
\n#ifndef KC_EXISTINGNOTFOU"), kc_current_view );
		  kc_printer(kc_t("ND_STATS\
\n#  define KC_EXISTINGNOTFOUND_STATS(oper) operator_statistics[oper].existing_not_found++;\
\n#endif\
\n\
\n#ifndef KC_FREE_CALLED_STATS\
\n#  define KC_FREE_CALLED_STATS(oper,rec) operator_"), kc_current_view );
		  kc_printer(kc_t("statistics[oper].free_called[(rec?true:false)]++;\
\n#endif\
\n\
\n#ifndef KC_FREED_STATS\
\n#  define KC_FREED_STATS(oper,rec) operator_statistics[oper].freed[(rec?true:false)]++;\
\n#endif\
\n"), kc_current_view); }
	    }
	    break;
	}
	case view_gen_alloc_h_enum: {
	    view_gen_alloc_h_class& kc_current_view=static_cast<view_gen_alloc_h_class&>(kc_current_view_base);
	    {
		const phylumdeclarations d = this->phylumdeclarations_1;
		{ kc_printer(kc_t("\
\nextern bool kc_storageclass_still_uniq[];\
\n"), kc_current_view); }
	    }
	    break;
	}
	case view_gen_k_c_enum: {
	    view_gen_k_c_class& kc_current_view=static_cast<view_gen_k_c_class&>(kc_current_view_base);
	    {
		{ kc_printer(kc_t("/* translation of file(s)\n"), kc_current_view); }
		kc::unparse(Thefnfiles, kc_printer, kc_current_view);
		{ kc_printer(kc_t(" */\
\n/* generated by:\
\n *  "), kc_current_view); }
		kc::unparse(kimwitu_copyright, kc_printer, kc_current_view);
		{ kc_printer(kc_t("\
\n */\
\n#define KC_TYPES\
\n"), kc_current_view); }
		if(g_options.stdafx!="") {
		    PRINT("#include \"");
		    PRINT(g_options.stdafx.c_str());
		    PRINT("\"\n");
		}	
			{ kc_printer(kc_t("\
\n#include \""), kc_current_view); }
		PRINT(g_options.prefix.c_str()); 
			{ kc_printer(kc_t("k.h\"\
\n#include <stdio.h>\
\n#include <ctype.h>\
\n#include <string>\
\n#include <sys/types.h>\
\n#include <stdlib.h>\
\n\
\n#ifdef _MSC_VER\
\n#pragma warning( disable : 4786 )\
\n#endif\
\n#include"), kc_current_view );
		  kc_printer(kc_t(" <new>\
\n#include <set>\
\n#include <list>\
\n#include <algorithm>\
\n\
\n#if !defined(USE_HASHSET) && (defined(__GNUC__) || defined(__ICC) || defined(__ECC)) \\\
\n	&& !defined(DONT_USE_HASHSET)\
\n#"), kc_current_view );
		  kc_printer(kc_t("  define USE_HASHSET\
\n#endif\
\n#ifdef USE_HASHSET\
\n#  if defined(__GNUC__) && __GNUC__>2\
\n#    include <ext/hash_set>\
\n#  else\
\n#    include <hash_set>\
\n#  endif\
\n#endif\
\n\
\nusing nam"), kc_current_view );
		  kc_printer(kc_t("espace std;\
\n"), kc_current_view); }
		kc::unparse(this, kc_printer, view_open_namespace);
		{ kc_printer(kc_t("\
\ninline bool\
\nht_less(casestring p1, casestring p2){\
\n    return kc_strcmp(p1->name, p2->name)<0;\
\n}\
\n\
\ninline bool\
\nht_less(nocasestring p1, nocasestring p2){\
\n    return kc_strcasecm"), kc_current_view );
		  kc_printer(kc_t("p(p1->name, p2->name)<0;\
\n}\
\n\
\ninline bool\
\nht_less(real p1, real p2){\
\n    return p1->value < p2->value;\
\n}\
\n\
\ninline bool\
\nht_less(integer p1, integer p2){\
\n    return p1->value <"), kc_current_view );
		  kc_printer(kc_t(" p2->value;\
\n}\
\n\
\ninline bool\
\nht_less(voidptr p1, voidptr p2){\
\n    return p1->pointer < p2->pointer;\
\n}\
\n\
\nbool\
\nht_less(abstract_phylum p1, abstract_phylum p2)\
\n{\
\n    enum_ope"), kc_current_view );
		  kc_printer(kc_t("rators prod_sel=p1->prod_sel();\
\n    enum_operators prod_sel2=p2->prod_sel();\
\n    if(prod_sel<prod_sel2)\
\n	return true;\
\n    if(prod_sel>prod_sel2)\
\n	return false;\
\n    switch(prod_sel) {\
\n"), kc_current_view );
		  kc_printer(kc_t("	case sel_NoCaseStr:\
\n	    \vreturn ht_less(static_cast<nocasestring>(p1),static_cast<nocasestring>(p2));\r\
\n	case sel__Str:\
\n	    \vreturn ht_less(static_cast<casestring>(p1),static_cast<casestr"), kc_current_view );
		  kc_printer(kc_t("ing>(p2));\r\
\n	case sel__Real:\
\n	    \vreturn ht_less(static_cast<real>(p1),static_cast<real>(p2));\r\
\n	case sel__Int:\
\n	    \vreturn ht_less(static_cast<integer>(p1),static_cast<integer>(p2));"), kc_current_view );
		  kc_printer(kc_t("\r\
\n	case sel__VoidPtr:\
\n	    \vreturn ht_less(static_cast<voidptr>(p1),static_cast<voidptr>(p2));\r\
\n	default: {\
\n	    int i=0;\
\n	    bool still_unique = kc_storageclass_still_uniq[phylum_in"), kc_current_view );
		  kc_printer(kc_t("fo[p1->phylum()].uniq_stored];\
\n	    abstract_phylum sub1=0;\
\n	    do {\
\n		sub1=p1->subphylum(i);\
\n		abstract_phylum sub2=p2->subphylum(i);\
\n		if(still_unique) {\
\n		    if(sub1<sub2)\
\n			"), kc_current_view );
		  kc_printer(kc_t("return true;\
\n		    if(sub2<sub1)\
\n			return false;\
\n		}\
\n		else {\
\n		    if(ht_less(sub1, sub2))\
\n			return true;\
\n		    if(ht_less(sub2, sub1))\
\n			return false;\
\n		}\
\n		++i;\
\n	"), kc_current_view );
		  kc_printer(kc_t("    } while(sub1);\
\n	}\
\n    }\
\n    return false;\
\n}\
\n\
\ntemplate<typename T>\
\nclass phylum_less : std::binary_function<T, T, bool>\
\n{\
\npublic:\
\n    bool operator()(const T& X, const "), kc_current_view );
		  kc_printer(kc_t("T& Y) const\
\n	\v{ return ht_less(X,Y); }\r\
\n};\
\n\
\ninline void deletefun(c_abstract_phylum t){\
\n    delete const_cast<abstract_phylum>(t);\
\n}\
\n\
\n"), kc_current_view); }
		string how_smart = "";
		if(g_options.smart_pointer) how_smart="_ptr"; 
			{ kc_printer(kc_t("\
\n#ifdef USE_HASHSET\
\nstruct hashitem {\
\n    size_t hashvalue;\
\n    casestring"), kc_current_view); }
		kc::unparse(how_smart, kc_printer, kc_current_view);
		{ kc_printer(kc_t(" contents;\
\n    hashitem(casestring"), kc_current_view); }
		kc::unparse(how_smart, kc_printer, kc_current_view);
		{ kc_printer(kc_t(" cs): contents(cs) {\
\n	unsigned long h = 0;\
\n	kc_char_t const *s = cs->name;\
\n	for ( ; *s; ++s)\
\n	    \vh = 5*h + *s;\r\
\n	hashvalue=(size_t)h;\
\n    }\
\n};\
\n\
\ninline void deletefunhashi"), kc_current_view );
		  kc_printer(kc_t("tem(hashitem t) {\
\n    delete t.contents;\
\n}\
\n\
\n#  ifdef __GNUC__\
\nstruct eq_hashitem { bool operator()(hashitem hi1, hashitem hi2) const {\
\n    return kc_strcmp(hi1.contents->name, hi2.con"), kc_current_view );
		  kc_printer(kc_t("tents->name) == 0; } };\
\n\
\nstruct hash_hashitem { size_t operator()(hashitem hi) const {\
\n    return hi.hashvalue; } };\
\n\
\n#  else\
\nstruct comp_hashitem {\
\n    enum { bucket_size = 4, min"), kc_current_view );
		  kc_printer(kc_t("_buckets = 8 };\
\n    // bucket_size and min_buckets are just guesses\
\n    size_t operator()(const hashitem hi) const {\
\n	return hi.hashvalue; }\
\n    bool operator()(const hashitem hi1, const ha"), kc_current_view );
		  kc_printer(kc_t("shitem hi2) const {\
\n	return kc_strcmp(hi1.contents->name, hi2.contents->name) < 0; }\
\n};\
\n#  endif // Whether gcc or icc\
\n#endif // Whether hash or not\
\n\
\nstruct hashtable_level\
\n{\
\n	h"), kc_current_view );
		  kc_printer(kc_t("ashtable_level(bool cod = true): clean_on_destruction(cod) { }\
\n"), kc_current_view); }
		if(!g_options.smart_pointer) 
		{
		    { kc_printer(kc_t("	void clear(bool free_entries=true) {\
\n	    if(free_entries)\
\n		clear_entries();\
\n	    _casestring.clear();\
\n	    _nocasestring.clear();\
\n	    _integer.clear();\
\n	    _real.clear();\
\n	   "), kc_current_view );
		  kc_printer(kc_t(" _voidptr.clear();\
\n	    _abstract_phylum.clear();\
\n	}\
\n	void clear_entries() {\
\n#ifdef USE_HASHSET\
\n		std::for_each(_casestring.begin(),_casestring.end(),deletefunhashitem);\
\n#else\
\n		st"), kc_current_view );
		  kc_printer(kc_t("d::for_each(_casestring.begin(),_casestring.end(),deletefun);\
\n#endif\
\n		std::for_each(_nocasestring.begin(),_nocasestring.end(),deletefun);\
\n		std::for_each(_integer.begin(),_integer.end(),delet"), kc_current_view );
		  kc_printer(kc_t("efun);\
\n		std::for_each(_real.begin(),_real.end(),deletefun);\
\n		std::for_each(_voidptr.begin(),_voidptr.end(),deletefun);\
\n		std::for_each(_abstract_phylum.begin(),_abstract_phylum.end(),deletef"), kc_current_view );
		  kc_printer(kc_t("un);\
\n	    }\
\n	~hashtable_level() {\
\n	    clear(clean_on_destruction);\
\n	}\
\n	abstract_phylum check_insert(abstract_phylum t) {\
\n	    return *_abstract_phylum.insert(t).first;\
\n	}\
\n	case"), kc_current_view );
		  kc_printer(kc_t("string check_insert(casestring t) {\
\n#ifdef USE_HASHSET\
\n	    return (*_casestring.insert(hashitem(t)).first).contents;\
\n#else\
\n	    return *_casestring.insert(t).first;\
\n#endif\
\n	}\
\n	noc"), kc_current_view );
		  kc_printer(kc_t("asestring check_insert(nocasestring t) {\
\n	    return *_nocasestring.insert(t).first;\
\n	}\
\n	integer check_insert(integer t) {\
\n	    return *_integer.insert(t).first;\
\n	}\
\n	real check_insert"), kc_current_view );
		  kc_printer(kc_t("(real t) {\
\n	    return *_real.insert(t).first;\
\n	}\
\n	voidptr check_insert(voidptr t) {\
\n	    return *_voidptr.insert(t).first;\
\n	}\
\n"), kc_current_view); }
		}
		else 
		{
		    { kc_printer(kc_t("	void clear() {\
\n	    _casestring.clear();\
\n	    _nocasestring.clear();\
\n	    _integer.clear();\
\n	    _real.clear();\
\n	    _voidptr.clear();\
\n	    _abstract_phylum.clear();\
\n	}\
\n	abstra"), kc_current_view );
		  kc_printer(kc_t("ct_phylum check_insert(abstract_phylum t) {\
\n	    return *_abstract_phylum.insert(abstract_phylum_ptr(t)).first;\
\n	}\
\n	casestring check_insert(casestring t) {\
\n	    return *_casestring.insert(c"), kc_current_view );
		  kc_printer(kc_t("asestring_ptr(t)).first;\
\n	}\
\n	nocasestring check_insert(nocasestring t) {\
\n	    return *_nocasestring.insert(nocasestring_ptr(t)).first;\
\n	}\
\n	integer check_insert(integer t) {\
\n	    retur"), kc_current_view );
		  kc_printer(kc_t("n *_integer.insert(integer_ptr(t)).first;\
\n	}\
\n	real check_insert(real t) {\
\n	    return *_real.insert(real_ptr(t)).first;\
\n	}\
\n	voidptr check_insert(voidptr t) {\
\n	    return *_voidptr.ins"), kc_current_view );
		  kc_printer(kc_t("ert(voidptr_ptr(t)).first;\
\n	}\
\n"), kc_current_view); }
		}
		{ kc_printer(kc_t("\rprivate:\v\
\n	bool clean_on_destruction;\
\n#ifdef USE_HASHSET\
\n#  ifdef __GNUC__\
\n#    if __GNUC__==2 || (__GNUC__==3 && __GNUC_MINOR__==0)\
\n	std::hash_set<hashitem, hash_hashitem, eq_hashite"), kc_current_view );
		  kc_printer(kc_t("m> _casestring;\
\n#    else\
\n	__gnu_cxx::hash_set<hashitem, hash_hashitem, eq_hashitem> _casestring;\
\n#    endif\
\n#  else\
\n	std::hash_set<hashitem, comp_hashitem> _casestring;\
\n#  endif\
\n#"), kc_current_view );
		  kc_printer(kc_t("else\
\n	std::set<casestring"), kc_current_view); }
		kc::unparse(how_smart, kc_printer, kc_current_view);
		{ kc_printer(kc_t(", phylum_less<casestring"), kc_current_view); }
		kc::unparse(how_smart, kc_printer, kc_current_view);
		{ kc_printer(kc_t("> > _casestring;\
\n#endif\
\n	std::set<nocasestring"), kc_current_view); }
		kc::unparse(how_smart, kc_printer, kc_current_view);
		{ kc_printer(kc_t(", phylum_less<nocasestring"), kc_current_view); }
		kc::unparse(how_smart, kc_printer, kc_current_view);
		{ kc_printer(kc_t("> > _nocasestring;\
\n	std::set<integer"), kc_current_view); }
		kc::unparse(how_smart, kc_printer, kc_current_view);
		{ kc_printer(kc_t(", phylum_less<integer"), kc_current_view); }
		kc::unparse(how_smart, kc_printer, kc_current_view);
		{ kc_printer(kc_t("> > _integer;\
\n	std::set<real"), kc_current_view); }
		kc::unparse(how_smart, kc_printer, kc_current_view);
		{ kc_printer(kc_t(", phylum_less<real"), kc_current_view); }
		kc::unparse(how_smart, kc_printer, kc_current_view);
		{ kc_printer(kc_t("> > _real;\
\n	std::set<voidptr"), kc_current_view); }
		kc::unparse(how_smart, kc_printer, kc_current_view);
		{ kc_printer(kc_t(", phylum_less<voidptr"), kc_current_view); }
		kc::unparse(how_smart, kc_printer, kc_current_view);
		{ kc_printer(kc_t("> > _voidptr;\
\n	std::set<abstract_phylum"), kc_current_view); }
		kc::unparse(how_smart, kc_printer, kc_current_view);
		{ kc_printer(kc_t(", phylum_less<abstract_phylum"), kc_current_view); }
		kc::unparse(how_smart, kc_printer, kc_current_view);
		{ kc_printer(kc_t("> > _abstract_phylum;\
\n};\
\n\
\nclass hashtable_stack: public std::list<hashtable_level> {\
\n\rpublic:\v\
\n    hashtable_stack(): _pos(begin()) { }\
\n\
\n    void inc_level() { _pos=insert(_pos, "), kc_current_view );
		  kc_printer(kc_t("hashtable_level()); }\
\n    void dec_level() { if(valid() && _pos!=end()) ++_pos; }\
\n    void free_level() { if(_pos!=begin()) { erase(begin(),_pos);_pos=begin(); } }\
\n\
\n    bool valid() const {"), kc_current_view );
		  kc_printer(kc_t(" return !empty(); }\
\n    hashtable_level& get_level() { return *_pos; }\
\n\
\n    template<typename T>\
\n    T check_insert(T t) {\
\n	return dynamic_cast<T>((*_pos).check_insert(t));\
\n    }\
\n\r"), kc_current_view );
		  kc_printer(kc_t("private:\v\
\n    iterator _pos;\
\n};\
\n\
\nclass hashtable_struct_t {\
\n\rpublic:\v\
\n    // don't clean _static_level on destruction (program ends)\
\n    hashtable_struct_t(): _static_level(fals"), kc_current_view );
		  kc_printer(kc_t("e), _to_be_freed(false),  _dynamic(false) { }\
\n\
\n    template <typename T>\
\n    T ht_check_insert(T t) {\
\n	if(_dynamic && _dynamic_level.valid())\
\n	    return _dynamic_level.check_insert(t);\
\n"), kc_current_view );
		  kc_printer(kc_t("	else\
\n	    return dynamic_cast<T>(_static_level.check_insert(t));\
\n    }\
\n    void ht_static() {_dynamic=false; }\
\n    void ht_dynamic() {\
\n	_dynamic=true;\
\n	if(!_dynamic_level.valid())\
\n"), kc_current_view );
		  kc_printer(kc_t("	    _dynamic_level.inc_level();\
\n    }\
\n    void ht_inc_level() { _dynamic_level.inc_level(); }\
\n    void ht_dec_level() { _dynamic_level.dec_level(); }\
\n    void ht_free_level() { _dynamic_le"), kc_current_view );
		  kc_printer(kc_t("vel.free_level(); }\
\n    void ht_clear() { _static_level.clear(); _dynamic_level.clear(); _dynamic=false; }\
\n\
\n    bool to_be_freed() { return _to_be_freed; }\
\n    void set_to_be_freed(bool b=t"), kc_current_view );
		  kc_printer(kc_t("rue) { _to_be_freed=b; }\
\n\rprivate:\v\
\n    hashtable_level _static_level;\
\n    hashtable_stack _dynamic_level;\
\n    bool _to_be_freed; /* should be true for dynamic, false for statically alloc"), kc_current_view );
		  kc_printer(kc_t("ated structures */\
\n    bool _dynamic;\
\n};\
\n\
\nimpl_nocasestring_NoCaseStr::impl_nocasestring_NoCaseStr(const kc_char_t* _name) : name(_name) { }\
\nvoid impl_nocasestring_NoCaseStr::make_own(in"), kc_current_view );
		  kc_printer(kc_t("t length) {\
\n    kc_char_t *newname=new kc_char_t[length+1];\
\n    for (int i=0; i < length && name[i]; ++i)\
\n	newname[i] = kc_tolower(name[i]);\
\n    newname[length]=0;\
\n    name=newname;\
\n}"), kc_current_view );
		  kc_printer(kc_t("\
\n\
\nimpl_casestring__Str::impl_casestring__Str(const kc_char_t* _name) : name(_name) { }\
\nvoid impl_casestring__Str::make_own(int length) {\
\n    kc_char_t *newname=kc_strncpy(new kc_char_t[leng"), kc_current_view );
		  kc_printer(kc_t("th+1],name,length);\
\n    newname[length]=0;\
\n    name=newname;\
\n}\
\n"), kc_current_view); }
	    }
	    break;
	}
	case view_gen_end_k_h_enum: {
	    view_gen_end_k_h_class& kc_current_view=static_cast<view_gen_end_k_h_class&>(kc_current_view_base);
	    {
		kc::unparse(this, kc_printer, view_close_namespace);
		{ kc_printer(kc_t("#endif // KC_TYPES_HEADER\
\n"), kc_current_view); }
	    }
	    break;
	}
	case view_gen_k_h_enum: {
	    view_gen_k_h_class& kc_current_view=static_cast<view_gen_k_h_class&>(kc_current_view_base);
	    {
		{ kc_printer(kc_t("/* translation of file(s)\n"), kc_current_view); }
		kc::unparse(Thefnfiles, kc_printer, kc_current_view);
		{ kc_printer(kc_t(" */\
\n/* generated by:\
\n *  "), kc_current_view); }
		kc::unparse(kimwitu_copyright, kc_printer, kc_current_view);
		{ kc_printer(kc_t("\
\n */\
\n#ifndef KC_TYPES_HEADER\
\n#define KC_TYPES_HEADER\
\n\
\n#define KIMWITUVERSIONMAJOR "), kc_current_view); }
		kc::unparse(METAKIMWITUVERSIONMAJOR, kc_printer, kc_current_view);
		{ kc_printer(kc_t("\
\n#define KIMWITUVERSIONMINOR "), kc_current_view); }
		kc::unparse(METAKIMWITUVERSIONMINOR, kc_printer, kc_current_view);
		{ kc_printer(kc_t("\
\n#define KIMWITUVERSIONMICRO "), kc_current_view); }
		kc::unparse(METAKIMWITUVERSIONMICRO, kc_printer, kc_current_view);
		{ kc_printer(kc_t("\
\n\
\n#include <stdio.h>\
\n#include <stddef.h>\
\n#include <string>\
\n\
\nnamespace kc {\r\
\n\
\n#ifndef INTEGER\
\n# define INTEGER int\
\n#endif\
\n#ifndef REAL\
\n# define REAL double\
\n#endif"), kc_current_view );
		  kc_printer(kc_t("\
\n\
\n#ifdef KC_UNICODE\
\n\
\n#define kc_t(TEXT) L ## TEXT\
\ntypedef wchar_t kc_char_t;\
\ntypedef std::wstring kc_string_t;\
\n\
\n#if defined(_WIN32) && ! defined (__GNUC__)\
\n#define kc_strlen "), kc_current_view );
		  kc_printer(kc_t("wcslen\
\n#define kc_strcmp wcscmp\
\n#define kc_strcasecmp _wcsicmp\
\n#define kc_strcpy wcscpy\
\n#define kc_strncpy wcsncpy\
\n#define kc_tolower towlower\
\n#define kc_print_integer(buf,number) swp"), kc_current_view );
		  kc_printer(kc_t("rintf(buf,kc_t(\"%d\"),number)\
\n#define kc_print_real(buf,number) swprintf(buf,kc_t(\"%g\"),number)\
\n\
\n// needed for printdot and csgio only\
\ninline\
\nstd::string kc_to_cstring(const std::wstr"), kc_current_view );
		  kc_printer(kc_t("ing& s) {\
\n    USES_CONVERSION;\
\n    return W2CA(s.c_str());\
\n}\
\n\
\n// needed for csgio only\
\ninline\
\nstd::wstring kc_to_wstring(const std::string& s) {\
\n    USES_CONVERSION;\
\n    retu"), kc_current_view );
		  kc_printer(kc_t("rn A2CW(s.c_str());\
\n}\
\n\
\n#else // !defined(_WIN32) || defined(__GNUC__)\
\n// if you want to use UNICODE on other platforms you have to write\
\n// the following functions on your own\
\nint kc_"), kc_current_view );
		  kc_printer(kc_t("strlen(const kc_char_t*);\
\nint kc_strcmp(const kc_char_t*,const kc_char_t*);\
\nint kc_strcasecmp(const kc_char_t*,const kc_char_t*);\
\nint kc_strcpy(kc_char_t*,const kc_char_t*);\
\nint kc_strncpy("), kc_current_view );
		  kc_printer(kc_t("kc_char_t*,const kc_char_t*, int);\
\nkc_char_t kc_tolower(kc_char_t);\
\nint kc_print_integer(kc_char_t* buffer, INTEGER number );\
\nint kc_print_real(kc_char_t* buffer, REAL number);\
\n\
\n// neede"), kc_current_view );
		  kc_printer(kc_t("d for printdot and csgio only\
\nstd::string kc_to_cstring(const std::wstring& );\
\n// needed for csgio only\
\nstd::wstring kc_to_wstring(const std::string& );\
\n\
\n#endif\
\n\
\n#else // !KC_UNICO"), kc_current_view );
		  kc_printer(kc_t("DE\
\n  \
\n#define kc_t(TEXT) TEXT  \
\ntypedef char kc_char_t;\
\ntypedef std::string kc_string_t;\
\n\
\n#define kc_strlen strlen\
\n#define kc_strcmp strcmp\
\n#if defined(_WIN32) && ! defined (__G"), kc_current_view );
		  kc_printer(kc_t("NUC__)\
\n#define kc_strcasecmp _stricmp\
\n#else\
\n#define kc_strcasecmp strcasecmp\
\n#endif\
\n#define kc_strcpy strcpy\
\n#define kc_strncpy strncpy\
\n#define kc_tolower tolower  \
\n#define kc_p"), kc_current_view );
		  kc_printer(kc_t("rint_integer(buf,number) sprintf(buf,kc_t(\"%d\"),number)\
\n#define kc_print_real(buf,number) sprintf(buf,kc_t(\"%g\"),number)\
\n#endif\
\n"), kc_current_view); }
		if(!g_options.no_unparse) 
		{
		    { kc_printer(kc_t("class uview_class;\
\ntypedef uview_class& uview;\
\ntypedef const uview_class& c_uview;\
\n\
\ntypedef class printer_functor_class& printer_functor;\
\ntypedef void (*printer_function)(const kc_char_t"), kc_current_view );
		  kc_printer(kc_t("*, uview);\
\n"), kc_current_view); }
		}
		if(!g_options.no_rewrite) 
		{
		    { kc_printer(kc_t("\
\nclass rview_class;\
\ntypedef rview_class& rview;\
\ntypedef const rview_class& c_rview;\
\n"), kc_current_view); }
		}
		{ kc_printer(kc_t("\
\n\v}\
\n\
\n// Some compilers know __attribute__. Right now we test for the GNU compiler\
\n// and Intel's icc (for ia32) and ecc (for ia64).\
\n#if !defined __GNUC__ && !defined __ICC && !defined _"), kc_current_view );
		  kc_printer(kc_t("_ECC\
\n# define __attribute__(x)\
\n#endif\
\n\
\n// Since all definitions are in namespace kc now, there is no need\
\n// give them a kc_ prefix. Old code may still rely on the prefix, so these\
\n//"), kc_current_view );
		  kc_printer(kc_t(" macros are generated for backwards compatibility\
\n#ifdef KC_DEPRECATED\
\n#define kc_PhylumInfo           phylum_info\
\n#define kc_OperatorInfo         operator_info\
\n#define kc_last_uview       "), kc_current_view );
		  kc_printer(kc_t("    last_uview\
\n#define kc_uviews               uviews\
\n#define kc_rviews               rviews\
\n#define kc_ht_reuse             ht_clear\
\n#define kc_ht_clear             ht_clear\
\n#define kc_"), kc_current_view );
		  kc_printer(kc_t("ht_assign            ht_assign\
\n#define kc_ht_assigned          ht_assigned\
\n"), kc_current_view); }
		kc::unparse(this, kc_printer, view_gen_deprecated);
		{ kc_printer(kc_t("\
\n#endif // KC_DEPRECATED\
\n\
\n// Some compilers are too stupid to detect that a function will always return\
\n// a proper value when it returns one in all branches of an if- or switch-\
\n// stat"), kc_current_view );
		  kc_printer(kc_t("ement (with final else or default, of course).\
\n#if !defined __GNUC__\
\n# define NORETURN throw 0;\
\n#else\
\n# define NORETURN\
\n#endif\
\n"), kc_current_view); }
		kc::unparse(this, kc_printer, view_open_namespace);
		{ kc_printer(kc_t("\
\n\
\n"), kc_current_view); }
	    }
	    break;
	}
	case view_close_namespace_enum: {
	    view_close_namespace_class& kc_current_view=static_cast<view_close_namespace_class&>(kc_current_view_base);
	    {
		{ kc_printer(kc_t("\
\n} // namespace kc\
\n"), kc_current_view); }
	    }
	    break;
	}
	case view_open_namespace_enum: {
	    view_open_namespace_class& kc_current_view=static_cast<view_open_namespace_class&>(kc_current_view_base);
	    {
		{ kc_printer(kc_t("\
\nnamespace kc {\r\
\n"), kc_current_view); }
	    }
	    break;
	}
	case view_no_of_printed_string_chars_reset_enum: {
	    view_no_of_printed_string_chars_reset_class& kc_current_view=static_cast<view_no_of_printed_string_chars_reset_class&>(kc_current_view_base);
	    {
	    }
	    break;
	}
	case view_printer_reset_enum: {
	    view_printer_reset_class& kc_current_view=static_cast<view_printer_reset_class&>(kc_current_view_base);
	    {
	    }
	    break;
	}
	case view_printer_outputfileline_enum: {
	    view_printer_outputfileline_class& kc_current_view=static_cast<view_printer_outputfileline_class&>(kc_current_view_base);
	    {
	    }
	    break;
	}

	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    { /* Alternative( *, args ) -> [view_gen_unparsedefs_default_c: */
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}

void
impl_phylumdeclarations::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    if(is_nil())
	nil_do_unparse(kc_printer, kc_current_view_base);
    else
	switch(kc_current_view_base) {
	case view_gen_yxx_union_h_enum: {
	    view_gen_yxx_union_h_class& kc_current_view=static_cast<view_gen_yxx_union_h_class&>(kc_current_view_base);
	    {
		const phylumdeclaration pd = this->phylumdeclaration_1;
		const phylumdeclarations rpds = this->phylumdeclarations_1;
		kc::unparse(rpds, kc_printer, kc_current_view);
		kc::unparse(pd, kc_printer, kc_current_view);
	    }
	    break;
	}
	case view_gen_classdefs_c_enum: {
	    view_gen_classdefs_c_class& kc_current_view=static_cast<view_gen_classdefs_c_class&>(kc_current_view_base);
	    {
		const phylumdeclaration pd = this->phylumdeclaration_1;
		const phylumdeclarations rpds = this->phylumdeclarations_1;
		kc::unparse(rpds, kc_printer, kc_current_view);
		kc::unparse(pd, kc_printer, kc_current_view);
	    }
	    break;
	}
	case view_gen_classdecls2_h_enum: {
	    view_gen_classdecls2_h_class& kc_current_view=static_cast<view_gen_classdecls2_h_class&>(kc_current_view_base);
	    {
		const phylumdeclaration pd = this->phylumdeclaration_1;
		const phylumdeclarations rpds = this->phylumdeclarations_1;
		kc::unparse(rpds, kc_printer, kc_current_view);
		kc::unparse(pd, kc_printer, kc_current_view);
	    }
	    break;
	}
	case view_gen_classdecls1_h_enum: {
	    view_gen_classdecls1_h_class& kc_current_view=static_cast<view_gen_classdecls1_h_class&>(kc_current_view_base);
	    {
		const phylumdeclaration pd = this->phylumdeclaration_1;
		const phylumdeclarations rpds = this->phylumdeclarations_1;
		kc::unparse(rpds, kc_printer, kc_current_view);
		kc::unparse(pd, kc_printer, kc_current_view);
	    }
	    break;
	}
	case view_gen_unparsedefs_c_enum: {
	    view_gen_unparsedefs_c_class& kc_current_view=static_cast<view_gen_unparsedefs_c_class&>(kc_current_view_base);
	    {
		const phylumdeclaration pd = this->phylumdeclaration_1;
		const phylumdeclarations rpds = this->phylumdeclarations_1;
		kc::unparse(rpds, kc_printer, kc_current_view);
		kc::unparse(pd, kc_printer, kc_current_view);
	    }
	    break;
	}
	case view_gen_rewritedefs_c_enum: {
	    view_gen_rewritedefs_c_class& kc_current_view=static_cast<view_gen_rewritedefs_c_class&>(kc_current_view_base);
	    {
		const phylumdeclaration pd = this->phylumdeclaration_1;
		const phylumdeclarations rpds = this->phylumdeclarations_1;
		kc::unparse(rpds, kc_printer, kc_current_view);
		kc::unparse(pd, kc_printer, kc_current_view);
	    }
	    break;
	}
	case view_gen_copy_attributes_c_enum: {
	    view_gen_copy_attributes_c_class& kc_current_view=static_cast<view_gen_copy_attributes_c_class&>(kc_current_view_base);
	    {
		const phylumdeclaration pd = this->phylumdeclaration_1;
		const phylumdeclarations rpds = this->phylumdeclarations_1;
		kc::unparse(rpds, kc_printer, kc_current_view);
		kc::unparse(pd, kc_printer, kc_current_view);
	    }
	    break;
	}
	case view_gen_listdefs_c_enum: {
	    view_gen_listdefs_c_class& kc_current_view=static_cast<view_gen_listdefs_c_class&>(kc_current_view_base);
	    {
		const phylumdeclaration pd = this->phylumdeclaration_1;
		const phylumdeclarations rpds = this->phylumdeclarations_1;
		kc::unparse(rpds, kc_printer, kc_current_view);
		kc::unparse(pd, kc_printer, kc_current_view);
	    }
	    break;
	}
	case view_gen_printdotdefs_c_enum: {
	    view_gen_printdotdefs_c_class& kc_current_view=static_cast<view_gen_printdotdefs_c_class&>(kc_current_view_base);
	    {
		const phylumdeclaration pd = this->phylumdeclaration_1;
		const phylumdeclarations rpds = this->phylumdeclarations_1;
		kc::unparse(rpds, kc_printer, kc_current_view);
		kc::unparse(pd, kc_printer, kc_current_view);
	    }
	    break;
	}
	case view_gen_attributeOf_function_enum: {
	    view_gen_attributeOf_function_class& kc_current_view=static_cast<view_gen_attributeOf_function_class&>(kc_current_view_base);
	    {
		const phylumdeclaration pd = this->phylumdeclaration_1;
		const phylumdeclarations rpds = this->phylumdeclarations_1;
		kc::unparse(rpds, kc_printer, kc_current_view);
		kc::unparse(pd, kc_printer, kc_current_view);
	    }
	    break;
	}
	case view_gen_operatordefs_c_enum: {
	    view_gen_operatordefs_c_class& kc_current_view=static_cast<view_gen_operatordefs_c_class&>(kc_current_view_base);
	    {
		const phylumdeclaration pd = this->phylumdeclaration_1;
		const phylumdeclarations rpds = this->phylumdeclarations_1;
		kc::unparse(rpds, kc_printer, kc_current_view);
		kc::unparse(pd, kc_printer, kc_current_view);
	    }
	    break;
	}
	case view_gen_operatorcast_h_enum: {
	    view_gen_operatorcast_h_class& kc_current_view=static_cast<view_gen_operatorcast_h_class&>(kc_current_view_base);
	    {
		const phylumdeclaration pd = this->phylumdeclaration_1;
		const phylumdeclarations rpds = this->phylumdeclarations_1;
		kc::unparse(rpds, kc_printer, kc_current_view);
		kc::unparse(pd, kc_printer, kc_current_view);
	    }
	    break;
	}
	case view_gen_operatordecls_h_enum: {
	    view_gen_operatordecls_h_class& kc_current_view=static_cast<view_gen_operatordecls_h_class&>(kc_current_view_base);
	    {
		const phylumdeclaration pd = this->phylumdeclaration_1;
		const phylumdeclarations rpds = this->phylumdeclarations_1;
		kc::unparse(rpds, kc_printer, kc_current_view);
		kc::unparse(pd, kc_printer, kc_current_view);
	    }
	    break;
	}
	case view_gen_yaccstacktype_h_enum: {
	    view_gen_yaccstacktype_h_class& kc_current_view=static_cast<view_gen_yaccstacktype_h_class&>(kc_current_view_base);
	    {
		const phylumdeclaration pd = this->phylumdeclaration_1;
		const phylumdeclarations rpds = this->phylumdeclarations_1;
		kc::unparse(rpds, kc_printer, kc_current_view);
		kc::unparse(pd, kc_printer, kc_current_view);
	    }
	    break;
	}
	case view_gen_nodetypedefs_h_enum: {
	    view_gen_nodetypedefs_h_class& kc_current_view=static_cast<view_gen_nodetypedefs_h_class&>(kc_current_view_base);
	    {
		const phylumdeclaration pd = this->phylumdeclaration_1;
		const phylumdeclarations rpds = this->phylumdeclarations_1;
		kc::unparse(rpds, kc_printer, kc_current_view);
		kc::unparse(pd, kc_printer, kc_current_view);
	    }
	    break;
	}
	case view_gen_operatormap_attributes_enum: {
	    view_gen_operatormap_attributes_class& kc_current_view=static_cast<view_gen_operatormap_attributes_class&>(kc_current_view_base);
	    {
		const phylumdeclaration pd = this->phylumdeclaration_1;
		const phylumdeclarations rpds = this->phylumdeclarations_1;
		kc::unparse(rpds, kc_printer, kc_current_view);
		kc::unparse(pd, kc_printer, kc_current_view);
	    }
	    break;
	}
	case view_gen_operatormap_subphyla_enum: {
	    view_gen_operatormap_subphyla_class& kc_current_view=static_cast<view_gen_operatormap_subphyla_class&>(kc_current_view_base);
	    {
		const phylumdeclaration pd = this->phylumdeclaration_1;
		const phylumdeclarations rpds = this->phylumdeclarations_1;
		kc::unparse(rpds, kc_printer, kc_current_view);
		kc::unparse(pd, kc_printer, kc_current_view);
	    }
	    break;
	}
	case view_gen_operatormap_c_enum: {
	    view_gen_operatormap_c_class& kc_current_view=static_cast<view_gen_operatormap_c_class&>(kc_current_view_base);
	    {
		const phylumdeclaration pd = this->phylumdeclaration_1;
		const phylumdeclarations rpds = this->phylumdeclarations_1;
		kc::unparse(rpds, kc_printer, kc_current_view);
		kc::unparse(pd, kc_printer, kc_current_view);
	    }
	    break;
	}
	case view_gen_phylummap_c_enum: {
	    view_gen_phylummap_c_class& kc_current_view=static_cast<view_gen_phylummap_c_class&>(kc_current_view_base);
	    {
		const phylumdeclaration pd = this->phylumdeclaration_1;
		const phylumdeclarations rpds = this->phylumdeclarations_1;
		kc::unparse(rpds, kc_printer, kc_current_view);
		kc::unparse(pd, kc_printer, kc_current_view);
	    }
	    break;
	}
	case view_gen_enumoperators_h_enum: {
	    view_gen_enumoperators_h_class& kc_current_view=static_cast<view_gen_enumoperators_h_class&>(kc_current_view_base);
	    {
		const phylumdeclaration pd = this->phylumdeclaration_1;
		const phylumdeclarations rpds = this->phylumdeclarations_1;
		kc::unparse(rpds, kc_printer, kc_current_view);
		kc::unparse(pd, kc_printer, kc_current_view);
	    }
	    break;
	}
	case view_gen_enumphyla_h_enum: {
	    view_gen_enumphyla_h_class& kc_current_view=static_cast<view_gen_enumphyla_h_class&>(kc_current_view_base);
	    {
		const phylumdeclaration pd = this->phylumdeclaration_1;
		const phylumdeclarations rpds = this->phylumdeclarations_1;
		kc::unparse(rpds, kc_printer, kc_current_view);
		kc::unparse(pd, kc_printer, kc_current_view);
	    }
	    break;
	}
	case view_gen_deprecated_enum: {
	    view_gen_deprecated_class& kc_current_view=static_cast<view_gen_deprecated_class&>(kc_current_view_base);
	    {
		const phylumdeclaration pd = this->phylumdeclaration_1;
		const phylumdeclarations rpds = this->phylumdeclarations_1;
		kc::unparse(rpds, kc_printer, kc_current_view);
		kc::unparse(pd, kc_printer, kc_current_view);
	    }
	    break;
	}
	case view_check_uniq_enum: {
	    view_check_uniq_class& kc_current_view=static_cast<view_check_uniq_class&>(kc_current_view_base);
	    {
		const phylumdeclaration d = this->phylumdeclaration_1;
		const phylumdeclarations rpds = this->phylumdeclarations_1;
		kc::unparse(rpds, kc_printer, kc_current_view);
		kc::unparse(d, kc_printer, kc_current_view);
	    }
	    break;
	}
	case view_gen_initializephyla_c_enum: {
	    view_gen_initializephyla_c_class& kc_current_view=static_cast<view_gen_initializephyla_c_class&>(kc_current_view_base);
	    {
		const phylumdeclaration pd = this->phylumdeclaration_1;
		const phylumdeclarations rpds = this->phylumdeclarations_1;
		kc::unparse(rpds, kc_printer, kc_current_view);
		kc::unparse(pd, kc_printer, kc_current_view);
	    }
	    break;
	}
	case view_check_count1_enum: {
	    view_check_count1_class& kc_current_view=static_cast<view_check_count1_class&>(kc_current_view_base);
	    {
		const phylumdeclaration pd = this->phylumdeclaration_1;
		const phylumdeclarations rpds = this->phylumdeclarations_1;
		kc::unparse(rpds, kc_printer, kc_current_view);
		kc::unparse(pd, kc_printer, kc_current_view);
	    }
	    break;
	}
	case view_check_count_enum: {
	    view_check_count_class& kc_current_view=static_cast<view_check_count_class&>(kc_current_view_base);
	    {
		kc::unparse(this, kc_printer, view_check_count1);
		v_freecount(); 
	    }
	    break;
	}
	case view_check_enum: {
	    view_check_class& kc_current_view=static_cast<view_check_class&>(kc_current_view_base);
	    {
		const phylumdeclaration pd = this->phylumdeclaration_1;
		const phylumdeclarations pds = this->phylumdeclarations_1;
		kc::unparse(pds, kc_printer, kc_current_view);
		kc::unparse(pd, kc_printer, kc_current_view);
	    }
	    break;
	}

	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    { /* Alternative( *, args ) -> [view_gen_unparsedefs_default_c: */
		for (phylumdeclarations iterator_ = this; iterator_->phylumdeclarations_1 != 0; iterator_ = iterator_->phylumdeclarations_1)
		    iterator_->phylumdeclaration_1->unparse(kc_printer, kc_current_view);
	    }
	    break;
	}
    }
}

void
impl_phylumdeclarations::nil_do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case view_gen_yxx_union_h_enum: {
	    view_gen_yxx_union_h_class& kc_current_view=static_cast<view_gen_yxx_union_h_class&>(kc_current_view_base);
	    {
	    }
	    break;
	}
	case view_gen_classdefs_c_enum: {
	    view_gen_classdefs_c_class& kc_current_view=static_cast<view_gen_classdefs_c_class&>(kc_current_view_base);
	    {
	    }
	    break;
	}
	case view_gen_classdecls2_h_enum: {
	    view_gen_classdecls2_h_class& kc_current_view=static_cast<view_gen_classdecls2_h_class&>(kc_current_view_base);
	    {
		{ kc_printer(kc_t("\
\nabstract_phylum kc_create(enum_operators createOp"), kc_current_view); }
		int j=Theargsnumbers->last()->value;
		if (j<2) j=2; 
		for (int i = 1; i<=j; ++i) 
		{
		    { kc_printer(kc_t(", abstract_phylum=0"), kc_current_view); }
		}
		{ kc_printer(kc_t(");\
\nabstract_phylum& attributeOf(abstract_phylum kc_p, int no);\
\n\n"), kc_current_view); }
	    }
	    break;
	}
	case view_gen_classdecls1_h_enum: {
	    view_gen_classdecls1_h_class& kc_current_view=static_cast<view_gen_classdecls1_h_class&>(kc_current_view_base);
	    {
	    }
	    break;
	}
	case view_gen_unparsedefs_c_enum: {
	    view_gen_unparsedefs_c_class& kc_current_view=static_cast<view_gen_unparsedefs_c_class&>(kc_current_view_base);
	    {
	    }
	    break;
	}
	case view_gen_rewritedefs_c_enum: {
	    view_gen_rewritedefs_c_class& kc_current_view=static_cast<view_gen_rewritedefs_c_class&>(kc_current_view_base);
	    {
	    }
	    break;
	}
	case view_gen_copy_attributes_c_enum: {
	    view_gen_copy_attributes_c_class& kc_current_view=static_cast<view_gen_copy_attributes_c_class&>(kc_current_view_base);
	    {
	    }
	    break;
	}
	case view_gen_listdefs_c_enum: {
	    view_gen_listdefs_c_class& kc_current_view=static_cast<view_gen_listdefs_c_class&>(kc_current_view_base);
	    {
	    }
	    break;
	}
	case view_gen_printdotdefs_c_enum: {
	    view_gen_printdotdefs_c_class& kc_current_view=static_cast<view_gen_printdotdefs_c_class&>(kc_current_view_base);
	    {
	    }
	    break;
	}
	case view_gen_attributeOf_function_enum: {
	    view_gen_attributeOf_function_class& kc_current_view=static_cast<view_gen_attributeOf_function_class&>(kc_current_view_base);
	    {
	    }
	    break;
	}
	case view_gen_operatordefs_c_enum: {
	    view_gen_operatordefs_c_class& kc_current_view=static_cast<view_gen_operatordefs_c_class&>(kc_current_view_base);
	    {
	    }
	    break;
	}
	case view_gen_operatorcast_h_enum: {
	    view_gen_operatorcast_h_class& kc_current_view=static_cast<view_gen_operatorcast_h_class&>(kc_current_view_base);
	    {
	    }
	    break;
	}
	case view_gen_operatordecls_h_enum: {
	    view_gen_operatordecls_h_class& kc_current_view=static_cast<view_gen_operatordecls_h_class&>(kc_current_view_base);
	    {
	    }
	    break;
	}
	case view_gen_yaccstacktype_h_enum: {
	    view_gen_yaccstacktype_h_class& kc_current_view=static_cast<view_gen_yaccstacktype_h_class&>(kc_current_view_base);
	    {
	    }
	    break;
	}
	case view_gen_nodetypedefs_h_enum: {
	    view_gen_nodetypedefs_h_class& kc_current_view=static_cast<view_gen_nodetypedefs_h_class&>(kc_current_view_base);
	    {
	    }
	    break;
	}
	case view_gen_operatormap_attributes_enum: {
	    view_gen_operatormap_attributes_class& kc_current_view=static_cast<view_gen_operatormap_attributes_class&>(kc_current_view_base);
	    {
	    }
	    break;
	}
	case view_gen_operatormap_subphyla_enum: {
	    view_gen_operatormap_subphyla_class& kc_current_view=static_cast<view_gen_operatormap_subphyla_class&>(kc_current_view_base);
	    {
	    }
	    break;
	}
	case view_gen_operatormap_c_enum: {
	    view_gen_operatormap_c_class& kc_current_view=static_cast<view_gen_operatormap_c_class&>(kc_current_view_base);
	    {
	    }
	    break;
	}
	case view_gen_phylummap_c_enum: {
	    view_gen_phylummap_c_class& kc_current_view=static_cast<view_gen_phylummap_c_class&>(kc_current_view_base);
	    {
	    }
	    break;
	}
	case view_gen_enumoperators_h_enum: {
	    view_gen_enumoperators_h_class& kc_current_view=static_cast<view_gen_enumoperators_h_class&>(kc_current_view_base);
	    {
	    }
	    break;
	}
	case view_gen_enumphyla_h_enum: {
	    view_gen_enumphyla_h_class& kc_current_view=static_cast<view_gen_enumphyla_h_class&>(kc_current_view_base);
	    {
	    }
	    break;
	}
	case view_gen_deprecated_enum: {
	    view_gen_deprecated_class& kc_current_view=static_cast<view_gen_deprecated_class&>(kc_current_view_base);
	    {
	    }
	    break;
	}
	case view_check_uniq_enum: {
	    view_check_uniq_class& kc_current_view=static_cast<view_check_uniq_class&>(kc_current_view_base);
	    {
	    }
	    break;
	}
	case view_gen_initializephyla_c_enum: {
	    view_gen_initializephyla_c_class& kc_current_view=static_cast<view_gen_initializephyla_c_class&>(kc_current_view_base);
	    {
		fndeclarations apfd=The_abstract_phylum_decl->additional_members,
		alfd=The_abstract_list_decl->additional_members; 
		kc::unparse(apfd, kc_printer, view_count_attrs);
		if (gl_no_of_args) 
		{
		    { kc_printer(kc_t("void kc_initialize_abstract_phylum(abstract_phylum kc_x)\
\n	    {\n"), kc_current_view); }
		    { kc_printer(kc_t("}\n"), kc_current_view); }
		}
		kc::unparse(alfd, kc_printer, view_count_attrs);
		if (gl_no_of_args) 
		{
		    { kc_printer(kc_t("void kc_initialize_abstract_list(abstract_list kc_x)\
\n	    {\n"), kc_current_view); }
		    { kc_printer(kc_t("}\n"), kc_current_view); }
		}
	    }
	    break;
	}
	case view_check_count1_enum: {
	    view_check_count1_class& kc_current_view=static_cast<view_check_count1_class&>(kc_current_view_base);
	    {
	    }
	    break;
	}
	case view_check_enum: {
	    view_check_class& kc_current_view=static_cast<view_check_class&>(kc_current_view_base);
	    {
	    }
	    break;
	}

	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    { /* Alternative( *, args ) -> [view_gen_unparsedefs_default_c: */
	    }
	    break;
	}
    }
}

void
impl_phylumnames::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    if(is_nil())
	nil_do_unparse(kc_printer, kc_current_view_base);
    else
	switch(kc_current_view_base) {
	case view_gen_uniqmap_c_1_enum: {
	    view_gen_uniqmap_c_1_class& kc_current_view=static_cast<view_gen_uniqmap_c_1_class&>(kc_current_view_base);
	    {
		const ID pn = this->ID_1;
		const phylumnames r_pn = this->phylumnames_1;
		kc::unparse(r_pn, kc_printer, kc_current_view);
		{ kc_printer(kc_t("phylum_"), kc_current_view); }
		kc::unparse(pn, kc_printer, kc_current_view);
		{ kc_printer(kc_t(", "), kc_current_view); }
	    }
	    break;
	}

	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    { /* Alternative( *, args ) -> [view_gen_unparsedefs_default_c: */
		for (phylumnames iterator_ = this; iterator_->phylumnames_1 != 0; iterator_ = iterator_->phylumnames_1)
		    iterator_->ID_1->unparse(kc_printer, kc_current_view);
	    }
	    break;
	}
    }
}

void
impl_phylumnames::nil_do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case view_gen_uniqmap_c_1_enum: {
	    view_gen_uniqmap_c_1_class& kc_current_view=static_cast<view_gen_uniqmap_c_1_class&>(kc_current_view_base);
	    {
	    }
	    break;
	}

	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    { /* Alternative( *, args ) -> [view_gen_unparsedefs_default_c: */
	    }
	    break;
	}
    }
}


void
impl_phylumdeclaration_PhylumDeclaration::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case view_gen_set_subphylumdefs_c_enum: {
	    view_gen_set_subphylumdefs_c_class& kc_current_view=static_cast<view_gen_set_subphylumdefs_c_class&>(kc_current_view_base);
	    if ((this->productionblock_1->prod_sel() == sel_PredefinedAlternatives)) {
	    } else
		if ((this->productionblock_1->prod_sel() == sel_Emptyproductionblock)) {
	    } else
		if ((this->productionblock_1->prod_sel() == sel_ListAlternatives)) {
		const ID id = this->ID_1;
		const ID el = phylum_cast<const impl_productionblock_ListAlternatives*>(this->productionblock_1)->ID_1;
		{ kc_printer(kc_t("void impl_"), kc_current_view); }
		kc::unparse(id, kc_printer, kc_current_view);
		{ kc_printer(kc_t("::set_subphylum(int no, abstract_phylum val)\
\n{\
\n    abstract_phylum newval=0;\
\n    switch(no) {\
\n	case 0: newval = "), kc_current_view); }
		kc::unparse(el, kc_printer, kc_current_view);
		{ kc_printer(kc_t("_1 = dynamic_cast<"), kc_current_view); }
		kc::unparse(el, kc_printer, kc_current_view);
		{ kc_printer(kc_t(">(val);break;\
\n	case 1: newval = "), kc_current_view); }
		kc::unparse(id, kc_printer, kc_current_view);
		{ kc_printer(kc_t("_1 = dynamic_cast<"), kc_current_view); }
		kc::unparse(id, kc_printer, kc_current_view);
		{ kc_printer(kc_t(">(val);break;\
\n    }\
\n    assertNonNull(newval);\
\n}\
\n"), kc_current_view); }
	    } else
		if ((this->productionblock_1->prod_sel() == sel_NonlistAlternatives)) {
		const ID id = this->ID_1;
		const alternatives alt = phylum_cast<const impl_productionblock_NonlistAlternatives*>(this->productionblock_1)->alternatives_1;
		kc::unparse(alt, kc_printer, kc_current_view);
	    } else
		    goto kc_unparsing_default;
	    break;
	}
	case view_gen_yxx_union_h_enum: {
	    view_gen_yxx_union_h_class& kc_current_view=static_cast<view_gen_yxx_union_h_class&>(kc_current_view_base);
	    {
		const ID id = this->ID_1;
		{ kc_printer(kc_t("    kc::"), kc_current_view); }
		kc::unparse(id, kc_printer, kc_current_view);
		{ kc_printer(kc_t(" as_"), kc_current_view); }
		kc::unparse(id, kc_printer, kc_current_view);
		{ kc_printer(kc_t(";\
\n"), kc_current_view); }
	    }
	    break;
	}
	case view_gen_subphylumdefs_c_enum: {
	    view_gen_subphylumdefs_c_class& kc_current_view=static_cast<view_gen_subphylumdefs_c_class&>(kc_current_view_base);
	    if ((this->productionblock_1->prod_sel() == sel_PredefinedAlternatives)) {
	    } else
		if ((this->productionblock_1->prod_sel() == sel_Emptyproductionblock)) {
	    } else
		if ((this->productionblock_1->prod_sel() == sel_ListAlternatives)) {
		const ID id = this->ID_1;
		const ID el = phylum_cast<const impl_productionblock_ListAlternatives*>(this->productionblock_1)->ID_1;
		{ kc_printer(kc_t("abstract_phylum impl_"), kc_current_view); }
		kc::unparse(id, kc_printer, kc_current_view);
		{ kc_printer(kc_t("::subphylum(int no) const\
\n{\
\n  switch(no){\
\n    case 0: return "), kc_current_view); }
		kc::unparse(el, kc_printer, kc_current_view);
		{ kc_printer(kc_t("_1;\
\n    case 1: return "), kc_current_view); }
		kc::unparse(id, kc_printer, kc_current_view);
		{ kc_printer(kc_t("_1;\
\n  }\
\n  return 0;\
\n}\
\n"), kc_current_view); }
	    } else
		if ((this->productionblock_1->prod_sel() == sel_NonlistAlternatives)) {
		const ID id = this->ID_1;
		const alternatives alt = phylum_cast<const impl_productionblock_NonlistAlternatives*>(this->productionblock_1)->alternatives_1;
		kc::unparse(alt, kc_printer, kc_current_view);
	    } else
		    goto kc_unparsing_default;
	    break;
	}
	case view_gen_classdefs_c_enum: {
	    view_gen_classdefs_c_class& kc_current_view=static_cast<view_gen_classdefs_c_class&>(kc_current_view_base);
	    if ((this->productionblock_1->prod_sel() == sel_Emptyproductionblock)) {
	    } else
		if ((this->productionblock_1->prod_sel() == sel_ListAlternatives)) {
		const ID id = this->ID_1;
		const ID el = phylum_cast<const impl_productionblock_ListAlternatives*>(this->productionblock_1)->ID_1;
		{ kc_printer(kc_t("const enum_phyla "), kc_current_view); }
		kc::unparse(id, kc_printer, view_class_of_phy);
		{ kc_printer(kc_t("::phylum_sel_ = phylum_"), kc_current_view); }
		kc::unparse(id, kc_printer, kc_current_view);
		{ kc_printer(kc_t(";\n"), kc_current_view); }
		kc::unparse(id, kc_printer, view_class_of_phy);
		{ kc_printer(kc_t("::"), kc_current_view); }
		kc::unparse(id, kc_printer, view_class_of_phy);
		{ kc_printer(kc_t("("), kc_current_view); }
		kc::unparse(el, kc_printer, kc_current_view);
		{ kc_printer(kc_t(" p1 , "), kc_current_view); }
		kc::unparse(id, kc_printer, kc_current_view);
		{ kc_printer(kc_t(" p2)\
\n	\v: "), kc_current_view); }
		kc::unparse(additional_members, kc_printer, view_count_nonstaticmembers);
		if (gl_no_of_args) 
		{
		    kc::unparse(gl_members, kc_printer, view_gen_user_assignment_inis);
		    { kc_printer(kc_t(", "), kc_current_view); }
		}
		kc::unparse(el, kc_printer, kc_current_view);
		{ kc_printer(kc_t("_1(p1), "), kc_current_view); }
		kc::unparse(id, kc_printer, kc_current_view);
		{ kc_printer(kc_t("_1(p2) { }\r\
\n"), kc_current_view); }
	    } else
	    {
		const ID id = this->ID_1;
		const productionblock alts = this->productionblock_1;
		{ kc_printer(kc_t("const enum_phyla "), kc_current_view); }
		kc::unparse(id, kc_printer, view_class_of_phy);
		{ kc_printer(kc_t("::phylum_sel_ = phylum_"), kc_current_view); }
		kc::unparse(id, kc_printer, kc_current_view);
		{ kc_printer(kc_t(";\n"), kc_current_view); }
		gl_phylum=id; 
		kc::unparse(alts, kc_printer, kc_current_view);
	    }
	    break;
	}
	case view_gen_classdecls2_h_enum: {
	    view_gen_classdecls2_h_class& kc_current_view=static_cast<view_gen_classdecls2_h_class&>(kc_current_view_base);
	    if ((this->productionblock_1->prod_sel() == sel_PredefinedAlternatives) && (phylum_cast<const impl_productionblock_PredefinedAlternatives*>(this->productionblock_1)->alternatives_1->prod_sel() == sel_Consalternatives) && ((phylum_cast<const impl_productionblock_PredefinedAlternatives*>(this->productionblock_1)->alternatives_1)->alternative_1->prod_sel() == sel_Alternative)) {
		const ID id = this->ID_1;
		const alternatives alts = phylum_cast<const impl_productionblock_PredefinedAlternatives*>(this->productionblock_1)->alternatives_1;
		const ID oid = phylum_cast<const impl_alternative_Alternative*>((phylum_cast<const impl_productionblock_PredefinedAlternatives*>(this->productionblock_1)->alternatives_1)->alternative_1)->ID_1;
		const Ccode_option cco = this->Ccode_option_1;
		{ kc_printer(kc_t("class impl_"), kc_current_view); }
		kc::unparse(id, kc_printer, kc_current_view);
		{ kc_printer(kc_t("_"), kc_current_view); }
		kc::unparse(oid, kc_printer, kc_current_view);
		{ kc_printer(kc_t(";\
\ntypedef impl_"), kc_current_view); }
		kc::unparse(id, kc_printer, kc_current_view);
		{ kc_printer(kc_t("_"), kc_current_view); }
		kc::unparse(oid, kc_printer, kc_current_view);
		{ kc_printer(kc_t(" impl_"), kc_current_view); }
		kc::unparse(id, kc_printer, kc_current_view);
		{ kc_printer(kc_t(";\
\n"), kc_current_view); }
		kc::unparse(alts, kc_printer, kc_current_view);
	    } else
		if ((this->productionblock_1->prod_sel() == sel_Emptyproductionblock)) {
	    } else
	    {
		const phylumdeclaration ph_decl = this/**/;
		const ID id = this->ID_1;
		const productionblock alt = this->productionblock_1;
		const Ccode_option cco = this->Ccode_option_1;
		{ kc_printer(kc_t("class "), kc_current_view); }
		if(g_options.dllexports!="") {
		    PRINT(g_options.dllexports.c_str());
		    PRINT(" ");
		} 
			{ kc_printer(kc_t("impl_"), kc_current_view); }
		kc::unparse(id, kc_printer, kc_current_view);

		{
		    baseclass_list kc_selvar_0_1 = phylum_cast<baseclass_list>(ph_decl->base_classes);
		    if ((kc_selvar_0_1->prod_sel() == sel_Consbaseclass_list)) {

			PRINT("\b :\b ");
			UNPARSE(ph_decl->base_classes);

		    } else
		    {

			{
			    productionblock kc_selvar_1_1 = phylum_cast<productionblock>(alt);
			    if ((kc_selvar_1_1->prod_sel() == sel_ListAlternatives)) {

				PRINT(": public impl_abstract_list"); 
					} else
			    {
				PRINT(": public impl_abstract_phylum"); 
			    }
			}

		    }
		}

		{ kc_printer(kc_t("{\
\n\rpublic:\v\n"), kc_current_view); }
		kc::unparse(additional_members, kc_printer, view_count_nonstaticmembers);
		if (f_listelementphylum(id)->eq(f_emptyId()) &&
		    !f_constructors_in_phylumdecl(this) && gl_no_of_args!=0) 
		{
		    { kc_printer(kc_t("explicit impl_"), kc_current_view); }
		    kc::unparse(id, kc_printer, kc_current_view);
		    { kc_printer(kc_t("()\v\n: "), kc_current_view); }
		    kc::unparse(gl_members, kc_printer, view_gen_user_assignment_inis);
		    { kc_printer(kc_t(" { }\r\n"), kc_current_view); }
		}
		{ kc_printer(kc_t("   static const enum_phyla phylum_sel_;\n"), kc_current_view); }
		if(!g_options.no_printdot) 
		{
		    { kc_printer(kc_t("    void fprintdot( FILE*, const char*, const char*, const char*, bool, bool, bool ) const;\
\n"), kc_current_view); }
		}
		if(!g_options.no_rewrite && g_options.rw_loop) 
		{
		    { kc_printer(kc_t("	"), kc_current_view); }
		    kc::unparse(id, kc_printer, kc_current_view);
		    { kc_printer(kc_t(" rewrite(rview v) { return phylum_cast<"), kc_current_view); }
		    kc::unparse(id, kc_printer, kc_current_view);
		    { kc_printer(kc_t(">(impl_abstract_phylum::rewrite(v)); }\
\n"), kc_current_view); }
		}
		if(g_options.smart_pointer) 
		{
		    { kc_printer(kc_t("   abstract_phylum_ref* new_phylum_ref() {\
\n	return new phylum_ref<impl_"), kc_current_view); }
		    kc::unparse(id, kc_printer, kc_current_view);
		    { kc_printer(kc_t(">(this);\
\n    }\
\n    impl_"), kc_current_view); }
		    kc::unparse(id, kc_printer, kc_current_view);
		    { kc_printer(kc_t("& operator=(const impl_"), kc_current_view); }
		    kc::unparse(id, kc_printer, kc_current_view);
		    { kc_printer(kc_t("& p) {\
\n	phylum_ref<impl_"), kc_current_view); }
		    kc::unparse(id, kc_printer, kc_current_view);
		    { kc_printer(kc_t(">* my_ref=static_cast<phylum_ref<impl_"), kc_current_view); }
		    kc::unparse(id, kc_printer, kc_current_view);
		    { kc_printer(kc_t(">*>(get_ref());\
\n	"), kc_current_view); }
		    kc::unparse(id, kc_printer, kc_current_view);
		    { kc_printer(kc_t(" self=this;\
\n	if(my_ref) {\
\n	    abstract_phylum_ref* ref=p.get_ref();\
\n	    self=const_cast<"), kc_current_view); }
		    kc::unparse(id, kc_printer, kc_current_view);
		    { kc_printer(kc_t(">(&p);\
\n	    if(ref)\
\n		self=phylum_cast<"), kc_current_view); }
		    kc::unparse(id, kc_printer, kc_current_view);
		    { kc_printer(kc_t(">(self->copy(true));\
\n	    my_ref->set_phylum(self);\
\n	}\
\n	return *self;\
\n    }\
\n    impl_"), kc_current_view); }
		    kc::unparse(id, kc_printer, kc_current_view);
		    { kc_printer(kc_t("& operator=(const phylum_ref<impl_"), kc_current_view); }
		    kc::unparse(id, kc_printer, kc_current_view);
		    { kc_printer(kc_t(">& r) {\
\n	phylum_ref<impl_"), kc_current_view); }
		    kc::unparse(id, kc_printer, kc_current_view);
		    { kc_printer(kc_t(">* my_ref=static_cast<phylum_ref<impl_"), kc_current_view); }
		    kc::unparse(id, kc_printer, kc_current_view);
		    { kc_printer(kc_t(">*>(get_ref());\
\n	"), kc_current_view); }
		    kc::unparse(id, kc_printer, kc_current_view);
		    { kc_printer(kc_t(" self=this;\
\n	if(my_ref) {\
\n	    self=phylum_cast<"), kc_current_view); }
		    kc::unparse(id, kc_printer, kc_current_view);
		    { kc_printer(kc_t(">(r.get_phylum()?r.get_phylum()->copy(true):0);\
\n	    my_ref->set_phylum(self);\
\n	}\
\n	return *self;\
\n    }\
\n\
\n    impl_"), kc_current_view); }
		    kc::unparse(id, kc_printer, kc_current_view);
		    { kc_printer(kc_t("* return_ptr() { if(get_ref()) get_ref()->lock(); return this; }\
\n"), kc_current_view); }
		}
		kc::unparse(cco, kc_printer, view_gen_nodetypes_h);
		kc::unparse(additional_members, kc_printer, view_gen_member_dcl_h);
		kc::unparse(this, kc_printer, view_gen_listdecls_h);
		{ kc_printer(kc_t("};\
\n"), kc_current_view); }
		kc::unparse(alt, kc_printer, kc_current_view);
	    }
	    break;
	}
	case view_gen_classdecls1_h_enum: {
	    view_gen_classdecls1_h_class& kc_current_view=static_cast<view_gen_classdecls1_h_class&>(kc_current_view_base);
	    if ((this->productionblock_1->prod_sel() == sel_PredefinedAlternatives) && (phylum_cast<const impl_productionblock_PredefinedAlternatives*>(this->productionblock_1)->alternatives_1->prod_sel() == sel_Consalternatives) && ((phylum_cast<const impl_productionblock_PredefinedAlternatives*>(this->productionblock_1)->alternatives_1)->alternative_1->prod_sel() == sel_Alternative)) {
		const ID id = this->ID_1;
		const ID oid = phylum_cast<const impl_alternative_Alternative*>((phylum_cast<const impl_productionblock_PredefinedAlternatives*>(this->productionblock_1)->alternatives_1)->alternative_1)->ID_1;
		{ kc_printer(kc_t("class impl_"), kc_current_view); }
		kc::unparse(id, kc_printer, kc_current_view);
		{ kc_printer(kc_t("_"), kc_current_view); }
		kc::unparse(oid, kc_printer, kc_current_view);
		{ kc_printer(kc_t(";\
\n"), kc_current_view); }
		if(g_options.smart_pointer) 
		{
		    { kc_printer(kc_t("typedef phylum_ptr<impl_"), kc_current_view); }
		    kc::unparse(id, kc_printer, kc_current_view);
		    { kc_printer(kc_t("_"), kc_current_view); }
		    kc::unparse(oid, kc_printer, kc_current_view);
		    { kc_printer(kc_t("> "), kc_current_view); }
		    kc::unparse(id, kc_printer, kc_current_view);
		    { kc_printer(kc_t("_ptr;\
\n"), kc_current_view); }
		}
		if(g_options.weak_pointer) 
		{
		    { kc_printer(kc_t("typedef weak_phylum_ptr<impl_"), kc_current_view); }
		    kc::unparse(id, kc_printer, kc_current_view);
		    { kc_printer(kc_t("_"), kc_current_view); }
		    kc::unparse(oid, kc_printer, kc_current_view);
		    { kc_printer(kc_t("> weak_"), kc_current_view); }
		    kc::unparse(id, kc_printer, kc_current_view);
		    { kc_printer(kc_t("_ptr;\
\n"), kc_current_view); }
		}
	    } else
		if ((this->productionblock_1->prod_sel() == sel_Emptyproductionblock)) {
	    } else
	    {
		const ID id = this->ID_1;
		{ kc_printer(kc_t("class impl_"), kc_current_view); }
		kc::unparse(id, kc_printer, kc_current_view);
		{ kc_printer(kc_t(";\
\n"), kc_current_view); }
		if(g_options.smart_pointer) 
		{
		    { kc_printer(kc_t("typedef phylum_ptr<impl_"), kc_current_view); }
		    kc::unparse(id, kc_printer, kc_current_view);
		    { kc_printer(kc_t("> "), kc_current_view); }
		    kc::unparse(id, kc_printer, kc_current_view);
		    { kc_printer(kc_t("_ptr;\
\n"), kc_current_view); }
		}
		if(g_options.weak_pointer) 
		{
		    { kc_printer(kc_t("typedef weak_phylum_ptr<impl_"), kc_current_view); }
		    kc::unparse(id, kc_printer, kc_current_view);
		    { kc_printer(kc_t("> weak_"), kc_current_view); }
		    kc::unparse(id, kc_printer, kc_current_view);
		    { kc_printer(kc_t("_ptr;\
\n"), kc_current_view); }
		}
	    }
	    break;
	}
	case view_gen_unparsedefs_default_c_enum: {
	    view_gen_unparsedefs_default_c_class& kc_current_view=static_cast<view_gen_unparsedefs_default_c_class&>(kc_current_view_base);
	    if ((this->productionblock_1->prod_sel() == sel_PredefinedAlternatives)) {
	    } else
		if ((this->productionblock_1->prod_sel() == sel_Emptyproductionblock)) {
	    } else
		if ((this->productionblock_1->prod_sel() == sel_ListAlternatives)) {
		alternative a = f_alternativeofoperator(gl_operator); 
			view_gen_unparsedefs_default_c_class vgudcL(/* is list ? */ true, kc_current_view.isOnlyDefault);
		kc::unparse(a, kc_printer, vgudcL);
	    } else
		if ((this->productionblock_1->prod_sel() == sel_NonlistAlternatives)) {
		alternative a = f_alternativeofoperator(gl_operator); 
		kc::unparse(a, kc_printer, kc_current_view);
	    } else
		    goto kc_unparsing_default;
	    break;
	}
	case view_gen_unparsedefs_c_enum: {
	    view_gen_unparsedefs_c_class& kc_current_view=static_cast<view_gen_unparsedefs_c_class&>(kc_current_view_base);
	    if ((this->productionblock_1->prod_sel() == sel_PredefinedAlternatives)) {
	    } else
		if ((this->productionblock_1->prod_sel() == sel_Emptyproductionblock)) {
	    } else
	    {
		const ID id = this->ID_1;
		const productionblock pb = this->productionblock_1;
		ID selvar = Id(Str(mkcasestring("this")));

		dollarvarstack.push( selvar );
		dollarvarextstack.push( f_emptyId() );
		gl_phylum = id; 
		kc::unparse(pb, kc_printer, kc_current_view);
		gl_phylum = 0;

		dollarvarstack.pop();
		dollarvarextstack.pop();

	    }
	    break;
	}
	case view_gen_rewritedefs_c_enum: {
	    view_gen_rewritedefs_c_class& kc_current_view=static_cast<view_gen_rewritedefs_c_class&>(kc_current_view_base);
	    if ((this->productionblock_1->prod_sel() == sel_Emptyproductionblock)) {
	    } else
		if ((this->productionblock_1->prod_sel() == sel_PredefinedAlternatives)) {
		const ID id = this->ID_1;
	    } else
	    {
		const ID id = this->ID_1;
		const productionblock pb = this->productionblock_1;
		gl_phydecl = f_lookupdecl( id );
		gl_phylum = id;
		if ( gl_phydecl == 0 ) {
		    v_report(NonFatal( FileLine( gl_phylum->file, gl_phylum->line ), Problem1S1ID( "internal error: could not find declaration of phylum:", gl_phylum )));
		}

		kc::unparse(pb, kc_printer, kc_current_view);
		gl_phydecl = 0;
		gl_phylum = 0;

	    }
	    break;
	}
	case view_gen_copy_attributes_c_enum: {
	    view_gen_copy_attributes_c_class& kc_current_view=static_cast<view_gen_copy_attributes_c_class&>(kc_current_view_base);
	    if ((this->Ccode_option_1->prod_sel() == sel_CcodeOption) && (phylum_cast<const impl_Ccode_option_CcodeOption*>(this->Ccode_option_1)->attributes_1->prod_sel() == sel_Consattributes) && ((phylum_cast<const impl_Ccode_option_CcodeOption*>(this->Ccode_option_1)->attributes_1)->attribute_1->prod_sel() == sel_Attribute) && ((phylum_cast<const impl_Ccode_option_CcodeOption*>(this->Ccode_option_1)->attributes_1)->attributes_1->prod_sel() == sel_Nilattributes)) {
		const ID id = this->ID_1;
		const ID aid = phylum_cast<const impl_attribute_Attribute*>((phylum_cast<const impl_Ccode_option_CcodeOption*>(this->Ccode_option_1)->attributes_1)->attribute_1)->ID_2;
		{ kc_printer(kc_t("   case phylum_"), kc_current_view); }
		kc::unparse(id, kc_printer, kc_current_view);
		{ kc_printer(kc_t(":\v\
\n	dynamic_cast<"), kc_current_view); }
		kc::unparse(id, kc_printer, kc_current_view);
		{ kc_printer(kc_t(">(kc_p2)->"), kc_current_view); }
		kc::unparse(aid, kc_printer, kc_current_view);
		{ kc_printer(kc_t(" = dynamic_cast<c_"), kc_current_view); }
		kc::unparse(id, kc_printer, kc_current_view);
		{ kc_printer(kc_t(">(kc_p1)->"), kc_current_view); }
		kc::unparse(aid, kc_printer, kc_current_view);
		{ kc_printer(kc_t(";\
\n	break;\r\n"), kc_current_view); }
	    } else
		if ((this->Ccode_option_1->prod_sel() == sel_CcodeOption) && (phylum_cast<const impl_Ccode_option_CcodeOption*>(this->Ccode_option_1)->attributes_1->prod_sel() == sel_Nilattributes)) {
		const ID id = this->ID_1;
	    } else
		if ((this->Ccode_option_1->prod_sel() == sel_CcodeOption)) {
		const ID id = this->ID_1;
		const attributes a = phylum_cast<const impl_Ccode_option_CcodeOption*>(this->Ccode_option_1)->attributes_1;
		{ kc_printer(kc_t("   case phylum_"), kc_current_view); }
		kc::unparse(id, kc_printer, kc_current_view);
		{ kc_printer(kc_t(": {\
\n    c_"), kc_current_view); }
		kc::unparse(id, kc_printer, kc_current_view);
		{ kc_printer(kc_t(" p1 = dynamic_cast<c_"), kc_current_view); }
		kc::unparse(id, kc_printer, kc_current_view);
		{ kc_printer(kc_t(">(kc_p1);\
\n"), kc_current_view); }
		kc::unparse(id, kc_printer, kc_current_view);
		{ kc_printer(kc_t(" p2 = dynamic_cast<"), kc_current_view); }
		kc::unparse(id, kc_printer, kc_current_view);
		{ kc_printer(kc_t(">(kc_p2);\
\n"), kc_current_view); }
		kc::unparse(a, kc_printer, kc_current_view);
		{ kc_printer(kc_t("	break;\
\n    }\n"), kc_current_view); }
	    } else
		    goto kc_unparsing_default;
	    break;
	}
	case view_gen_listdefs_c_enum: {
	    view_gen_listdefs_c_class& kc_current_view=static_cast<view_gen_listdefs_c_class&>(kc_current_view_base);
	    if ((this->productionblock_1->prod_sel() == sel_ListAlternatives)) {
		const ID id = this->ID_1;
		const ID el = phylum_cast<const impl_productionblock_ListAlternatives*>(this->productionblock_1)->ID_1;
		kc::unparse(id, kc_printer, kc_current_view);
		{ kc_printer(kc_t("\
\nconcat(c_"), kc_current_view); }
		kc::unparse(id, kc_printer, kc_current_view);
		{ kc_printer(kc_t(" kc_p1, c_"), kc_current_view); }
		kc::unparse(id, kc_printer, kc_current_view);
		{ kc_printer(kc_t(" kc_p2)\
\n{ return dynamic_cast<"), kc_current_view); }
		kc::unparse(id, kc_printer, kc_current_view);
		{ kc_printer(kc_t(">(kc_p1->do_concat(kc_p2, sel_Cons"), kc_current_view); }
		kc::unparse(id, kc_printer, kc_current_view);
		{ kc_printer(kc_t(")); }\
\n"), kc_current_view); }
		covariant_choice(id, "\nimpl_", "::reverse() const", "abstract_list\nimpl_", "::reverse() const",
		    kc_printer, kc_current_view); 
			{ kc_printer(kc_t("\n{ return dynamic_cast<"), kc_current_view); }
		kc::unparse(id, kc_printer, kc_current_view);
		{ kc_printer(kc_t(">(do_reverse(Nil"), kc_current_view); }
		kc::unparse(id, kc_printer, kc_current_view);
		{ kc_printer(kc_t("(), sel_Cons"), kc_current_view); }
		kc::unparse(id, kc_printer, kc_current_view);
		{ kc_printer(kc_t(")); }\
\n\
\n"), kc_current_view); }
		kc::unparse(el, kc_printer, kc_current_view);
		{ kc_printer(kc_t("\
\nimpl_"), kc_current_view); }
		kc::unparse(id, kc_printer, kc_current_view);
		{ kc_printer(kc_t("::last() const\
\n{ return dynamic_cast<"), kc_current_view); }
		kc::unparse(el, kc_printer, kc_current_view);
		{ kc_printer(kc_t(">(impl_abstract_list::last()); }\
\n\
\nbool\
\nimpl_"), kc_current_view); }
		kc::unparse(id, kc_printer, kc_current_view);
		{ kc_printer(kc_t("::is_nil() const\
\n{\
\n  return "), kc_current_view); }
		kc::unparse(el, kc_printer, kc_current_view);
		{ kc_printer(kc_t("_1==0 && "), kc_current_view); }
		kc::unparse(id, kc_printer, kc_current_view);
		{ kc_printer(kc_t("_1==0;\
\n}\
\n\
\n"), kc_current_view); }
		kc::unparse(id, kc_printer, kc_current_view);
		{ kc_printer(kc_t("\
\nimpl_"), kc_current_view); }
		kc::unparse(id, kc_printer, kc_current_view);
		{ kc_printer(kc_t("::map("), kc_current_view); }
		kc::unparse(el, kc_printer, kc_current_view);
		{ kc_printer(kc_t(" (*kc_fp)("), kc_current_view); }
		kc::unparse(el, kc_printer, kc_current_view);
		{ kc_printer(kc_t("))\
\n{ return dynamic_cast<"), kc_current_view); }
		kc::unparse(id, kc_printer, kc_current_view);
		{ kc_printer(kc_t(">(do_map((abstract_phylum (*)(abstract_phylum))kc_fp, sel_Cons"), kc_current_view); }
		kc::unparse(id, kc_printer, kc_current_view);
		{ kc_printer(kc_t(")); }\
\n"), kc_current_view); }
		kc::unparse(id, kc_printer, kc_current_view);
		{ kc_printer(kc_t("\
\nimpl_"), kc_current_view); }
		kc::unparse(id, kc_printer, kc_current_view);
		{ kc_printer(kc_t("::filter(bool (*kc_fp)("), kc_current_view); }
		kc::unparse(el, kc_printer, kc_current_view);
		{ kc_printer(kc_t("))\
\n{ return dynamic_cast<"), kc_current_view); }
		kc::unparse(id, kc_printer, kc_current_view);
		{ kc_printer(kc_t(">(do_filter((bool (*)(abstract_phylum))kc_fp, sel_Cons"), kc_current_view); }
		kc::unparse(id, kc_printer, kc_current_view);
		{ kc_printer(kc_t(")); }\
\n\
\n"), kc_current_view); }
		kc::unparse(id, kc_printer, kc_current_view);
		{ kc_printer(kc_t("\
\nimpl_"), kc_current_view); }
		kc::unparse(id, kc_printer, kc_current_view);
		{ kc_printer(kc_t("::append("), kc_current_view); }
		kc::unparse(el, kc_printer, kc_current_view);
		{ kc_printer(kc_t(" new_last)\
\n{\
\n  return dynamic_cast<"), kc_current_view); }
		kc::unparse(id, kc_printer, kc_current_view);
		{ kc_printer(kc_t(">(do_append(new_last, Nil"), kc_current_view); }
		kc::unparse(id, kc_printer, kc_current_view);
		{ kc_printer(kc_t("()));\
\n}\
\n"), kc_current_view); }
		kc::unparse(id, kc_printer, kc_current_view);
		{ kc_printer(kc_t("\
\nimpl_"), kc_current_view); }
		kc::unparse(id, kc_printer, kc_current_view);
		{ kc_printer(kc_t("::merge( "), kc_current_view); }
		kc::unparse(id, kc_printer, kc_current_view);
		{ kc_printer(kc_t(" second, "), kc_current_view); }
		kc::unparse(el, kc_printer, kc_current_view);
		{ kc_printer(kc_t(" (*kc_fp)("), kc_current_view); }
		kc::unparse(el, kc_printer, kc_current_view);
		{ kc_printer(kc_t(", "), kc_current_view); }
		kc::unparse(el, kc_printer, kc_current_view);
		{ kc_printer(kc_t("))\
\n{\
\n    return dynamic_cast<"), kc_current_view); }
		kc::unparse(id, kc_printer, kc_current_view);
		{ kc_printer(kc_t(">(do_merge(second,(abstract_phylum(*)(abstract_phylum,abstract_phylum))kc_fp, sel_Cons"), kc_current_view); }
		kc::unparse(id, kc_printer, kc_current_view);
		{ kc_printer(kc_t("));\
\n}\
\n"), kc_current_view); }
		kc::unparse(el, kc_printer, kc_current_view);
		{ kc_printer(kc_t("\
\nimpl_"), kc_current_view); }
		kc::unparse(id, kc_printer, kc_current_view);
		{ kc_printer(kc_t("::reduce( "), kc_current_view); }
		kc::unparse(el, kc_printer, kc_current_view);
		{ kc_printer(kc_t(" neutral, "), kc_current_view); }
		kc::unparse(el, kc_printer, kc_current_view);
		{ kc_printer(kc_t(" (*kc_fp)("), kc_current_view); }
		kc::unparse(el, kc_printer, kc_current_view);
		{ kc_printer(kc_t(", "), kc_current_view); }
		kc::unparse(el, kc_printer, kc_current_view);
		{ kc_printer(kc_t("))\
\n{\
\n    return dynamic_cast<"), kc_current_view); }
		kc::unparse(el, kc_printer, kc_current_view);
		{ kc_printer(kc_t(">(do_reduce(neutral,(abstract_phylum(*)(abstract_phylum,abstract_phylum))kc_fp));\
\n}\
\n\
\n"), kc_current_view); }
	    } else
	    {
	    }
	    break;
	}
	case view_gen_listdecls_h_enum: {
	    view_gen_listdecls_h_class& kc_current_view=static_cast<view_gen_listdecls_h_class&>(kc_current_view_base);
	    if ((this->productionblock_1->prod_sel() == sel_ListAlternatives)) {
		const ID id = this->ID_1;
		const ID el = phylum_cast<const impl_productionblock_ListAlternatives*>(this->productionblock_1)->ID_1;
		{ kc_printer(kc_t("   enum_operators prod_sel() const{\
\n      return is_nil() ? sel_Nil"), kc_current_view); }
		kc::unparse(id, kc_printer, kc_current_view);
		{ kc_printer(kc_t(": sel_Cons"), kc_current_view); }
		kc::unparse(id, kc_printer, kc_current_view);
		{ kc_printer(kc_t(";\
\n    }\
\n    explicit impl_"), kc_current_view); }
		kc::unparse(id, kc_printer, kc_current_view);
		{ kc_printer(kc_t("("), kc_current_view); }
		kc::unparse(el, kc_printer, kc_current_view);
		{ kc_printer(kc_t(" = 0, "), kc_current_view); }
		kc::unparse(id, kc_printer, kc_current_view);
		{ kc_printer(kc_t(" = 0);\
\n    abstract_phylum subphylum(int) const;\
\n    void set_subphylum(int, abstract_phylum);\
\n    friend "), kc_current_view); }
		kc::unparse(id, kc_printer, kc_current_view);
		{ kc_printer(kc_t(" concat(c_"), kc_current_view); }
		kc::unparse(id, kc_printer, kc_current_view);
		{ kc_printer(kc_t(", c_"), kc_current_view); }
		kc::unparse(id, kc_printer, kc_current_view);
		{ kc_printer(kc_t(");\n"), kc_current_view); }
		if (g_options.covariant=='p') 
		{
		    { kc_printer(kc_t("#ifndef NO_COVARIANT_RETURN\n"), kc_current_view); }
		}
		if (g_options.covariant!='n') 
		{
		    kc::unparse(id, kc_printer, kc_current_view);
		    { kc_printer(kc_t(" reverse() const;\n"), kc_current_view); }
		    if(!g_options.no_rewrite && !g_options.rw_loop) 
		    {
			kc::unparse(id, kc_printer, kc_current_view);
			{ kc_printer(kc_t(" rewrite(rview);\
\n"), kc_current_view); }
		    }
		}
		if (g_options.covariant=='p') 
		{
		    { kc_printer(kc_t("#else\n"), kc_current_view); }
		}
		if (g_options.covariant!='y') 
		{
		    { kc_printer(kc_t("    abstract_list reverse() const;\
\n"), kc_current_view); }
		    if(!g_options.no_rewrite && !g_options.rw_loop) 
		    {
			{ kc_printer(kc_t("	abstract_phylum rewrite(rview);\
\n"), kc_current_view); }
		    }
		}
		if (g_options.covariant=='p') 
		{
		    { kc_printer(kc_t("#endif // NO_COVARIANT_RETURN\n"), kc_current_view); }
		}
		if(!g_options.no_rewrite && g_options.rw_loop) 
		{
		    { kc_printer(kc_t("	abstract_phylum do_rewrite(rview);\
\n"), kc_current_view); }
		}
		kc::unparse(el, kc_printer, kc_current_view);
		{ kc_printer(kc_t(" last() const;\
\n    "), kc_current_view); }
		kc::unparse(id, kc_printer, kc_current_view);
		{ kc_printer(kc_t(" append("), kc_current_view); }
		kc::unparse(el, kc_printer, kc_current_view);
		{ kc_printer(kc_t(");\
\n    "), kc_current_view); }
		kc::unparse(id, kc_printer, kc_current_view);
		{ kc_printer(kc_t(" map("), kc_current_view); }
		kc::unparse(el, kc_printer, kc_current_view);
		{ kc_printer(kc_t(" (*)("), kc_current_view); }
		kc::unparse(el, kc_printer, kc_current_view);
		{ kc_printer(kc_t("));\
\n    "), kc_current_view); }
		kc::unparse(id, kc_printer, kc_current_view);
		{ kc_printer(kc_t(" filter( bool (*)("), kc_current_view); }
		kc::unparse(el, kc_printer, kc_current_view);
		{ kc_printer(kc_t("));\
\n    "), kc_current_view); }
		kc::unparse(id, kc_printer, kc_current_view);
		{ kc_printer(kc_t(" merge( "), kc_current_view); }
		kc::unparse(id, kc_printer, kc_current_view);
		{ kc_printer(kc_t(", "), kc_current_view); }
		kc::unparse(el, kc_printer, kc_current_view);
		{ kc_printer(kc_t(" (*)("), kc_current_view); }
		kc::unparse(el, kc_printer, kc_current_view);
		{ kc_printer(kc_t(", "), kc_current_view); }
		kc::unparse(el, kc_printer, kc_current_view);
		{ kc_printer(kc_t("));\
\n    "), kc_current_view); }
		kc::unparse(el, kc_printer, kc_current_view);
		{ kc_printer(kc_t(" reduce( "), kc_current_view); }
		kc::unparse(el, kc_printer, kc_current_view);
		{ kc_printer(kc_t(", "), kc_current_view); }
		kc::unparse(el, kc_printer, kc_current_view);
		{ kc_printer(kc_t(" (*)("), kc_current_view); }
		kc::unparse(el, kc_printer, kc_current_view);
		{ kc_printer(kc_t(", "), kc_current_view); }
		kc::unparse(el, kc_printer, kc_current_view);
		{ kc_printer(kc_t("));\
\n    bool is_nil() const;\
\n"), kc_current_view); }
		if(g_options.smart_pointer) 
		{
		    kc::unparse(el, kc_printer, kc_current_view);
		    { kc_printer(kc_t("_ptr "), kc_current_view); }
		    kc::unparse(el, kc_printer, kc_current_view);
		    { kc_printer(kc_t("_1;\
\n    "), kc_current_view); }
		    kc::unparse(id, kc_printer, kc_current_view);
		    { kc_printer(kc_t("_ptr "), kc_current_view); }
		    kc::unparse(id, kc_printer, kc_current_view);
		    { kc_printer(kc_t("_1;\
\n"), kc_current_view); }
		}
		else 
		{
		    kc::unparse(el, kc_printer, kc_current_view);
		    { kc_printer(kc_t(" "), kc_current_view); }
		    kc::unparse(el, kc_printer, kc_current_view);
		    { kc_printer(kc_t("_1;\
\n    "), kc_current_view); }
		    kc::unparse(id, kc_printer, kc_current_view);
		    { kc_printer(kc_t(" "), kc_current_view); }
		    kc::unparse(id, kc_printer, kc_current_view);
		    { kc_printer(kc_t("_1;\
\n"), kc_current_view); }
		}
		{ kc_printer(kc_t("\rprivate:\v\n"), kc_current_view); }
		if(!g_options.no_rewrite && !g_options.rw_loop) 
		{
		    if (g_options.covariant=='p') 
		    {
			{ kc_printer(kc_t("#ifndef NO_COVARIANT_RETURN\n"), kc_current_view); }
		    }
		    if (g_options.covariant!='n') 
		    {
			{ kc_printer(kc_t("	    impl_"), kc_current_view); }
			kc::unparse(id, kc_printer, kc_current_view);
			{ kc_printer(kc_t("* nil_rewrite(rview);\
\n	    impl_"), kc_current_view); }
			kc::unparse(id, kc_printer, kc_current_view);
			{ kc_printer(kc_t("* cons_rewrite(rview);\
\n"), kc_current_view); }
		    }
		    if (g_options.covariant=='p') 
		    {
			{ kc_printer(kc_t("#else\n"), kc_current_view); }
		    }
		    if (g_options.covariant!='y') 
		    {
			{ kc_printer(kc_t("	    impl_abstract_phylum* nil_rewrite(rview);\
\n	    impl_abstract_phylum* cons_rewrite(rview);\
\n"), kc_current_view); }
		    }
		    if (g_options.covariant=='p') 
		    {
			{ kc_printer(kc_t("#endif // NO_COVARIANT_RETURN\n"), kc_current_view); }
		    }
		}
		if (!g_options.no_unparse) 
		{
		    { kc_printer(kc_t("	void nil_do_unparse(printer_functor, uview);\
\n	void do_unparse(printer_functor, uview);\
\n"), kc_current_view); }
		}
	    } else
	    {
		const ID id = this->ID_1;
		if (g_options.covariant!='n') 
		{
		    if (g_options.covariant=='p') 
		    {
			{ kc_printer(kc_t("#ifndef NO_COVARIANT_RETURN\n"), kc_current_view); }
		    }
		    if(!g_options.no_rewrite && !g_options.rw_loop) 
		    {
			kc::unparse(id, kc_printer, kc_current_view);
			{ kc_printer(kc_t(" rewrite(rview) =0;\n"), kc_current_view); }
		    }
		    if (g_options.covariant=='p') 
		    {
			{ kc_printer(kc_t("#endif // NO_COVARIANT_RETURN\n"), kc_current_view); }
		    }
		}
	    }
	    break;
	}
	case view_gen_printdotdefs_c_enum: {
	    view_gen_printdotdefs_c_class& kc_current_view=static_cast<view_gen_printdotdefs_c_class&>(kc_current_view_base);
	    if ((this->productionblock_1->prod_sel() == sel_Emptyproductionblock)) {
	    } else
		if ((this->productionblock_1->prod_sel() == sel_PredefinedAlternatives)) {
		const ID id = this->ID_1;
		{ kc_printer(kc_t("void impl_"), kc_current_view); }
		kc::unparse(id, kc_printer, kc_current_view);
		{ kc_printer(kc_t("::fprintdot(FILE *f, const char *root_label_prefix, const char *edge_label_prefix, const char *edge_attributes, bool print_node_labels, bool use_context_when_sharing_leaves, bool print_prologue_and_epi"), kc_current_view );
		  kc_printer(kc_t("logue) const\
\n{\
\n    int kc_edge_nr = 1;\
\n    kc_dotedgenode_t kc_edges = 0;\
\n    if (print_prologue_and_epilogue) fprintdotprologue(f);\
\n    /*if (kc_outmost)*/ kc_do_printdot_subgraph_prolo"), kc_current_view );
		  kc_printer(kc_t("gue(f, this, root_label_prefix, edge_attributes, print_node_labels, use_context_when_sharing_leaves);\
\n    fprintdot_hashtable = new kc_dotedge_ht;\
\n    do_printdot(f, true, &kc_edge_nr, &kc_edges,"), kc_current_view );
		  kc_printer(kc_t(" edge_label_prefix, print_node_labels, use_context_when_sharing_leaves, 0, 0);\
\n    kc_do_printdot_edges(f, kc_edges, edge_attributes, use_context_when_sharing_leaves);\
\n    delete fprintdot_hashta"), kc_current_view );
		  kc_printer(kc_t("ble;\
\n	fprintdot_hashtable=0;\
\n    /*if (kc_outmost)*/ kc_do_printdot_subgraph_epilogue(f);\
\n    if (print_prologue_and_epilogue) fprintdotepilogue(f);\
\n}\
\n"), kc_current_view); }
	    } else
		if ((this->productionblock_1->prod_sel() == sel_ListAlternatives)) {
		const ID id = this->ID_1;
		{ kc_printer(kc_t("void impl_"), kc_current_view); }
		kc::unparse(id, kc_printer, kc_current_view);
		{ kc_printer(kc_t("::fprintdot(FILE *f, const char *root_label_prefix, const char *edge_label_prefix, const char *edge_attributes, bool print_node_labels, bool use_context_when_sharing_leaves, bool print_prologue_and_epi"), kc_current_view );
		  kc_printer(kc_t("logue) const\
\n{\
\n    int kc_edge_nr = 1;\
\n    kc_dotedgenode_t kc_edges = 0;\
\n    if (print_prologue_and_epilogue) fprintdotprologue(f);\
\n    /*if (kc_outmost)*/ kc_do_printdot_subgraph_prolo"), kc_current_view );
		  kc_printer(kc_t("gue(f, this, root_label_prefix, edge_attributes, print_node_labels, use_context_when_sharing_leaves);\
\n    fprintdot_hashtable = new kc_dotedge_ht;\
\n    do_printdot(f, true, &kc_edge_nr, &kc_edges,"), kc_current_view );
		  kc_printer(kc_t(" edge_label_prefix, print_node_labels, use_context_when_sharing_leaves, 0, 0);\
\n    kc_do_printdot_edges(f, kc_edges, edge_attributes, use_context_when_sharing_leaves);\
\n    delete fprintdot_hashta"), kc_current_view );
		  kc_printer(kc_t("ble;\
\n	fprintdot_hashtable=0;\
\n    /*if (kc_outmost)*/ kc_do_printdot_subgraph_epilogue(f);\
\n    if (print_prologue_and_epilogue) fprintdotepilogue(f);\
\n}\
\n"), kc_current_view); }
	    } else
		if ((this->productionblock_1->prod_sel() == sel_NonlistAlternatives)) {
		const ID id = this->ID_1;
		{ kc_printer(kc_t("void impl_"), kc_current_view); }
		kc::unparse(id, kc_printer, kc_current_view);
		{ kc_printer(kc_t("::fprintdot(FILE *f, const char *root_label_prefix, const char *edge_label_prefix, const char *edge_attributes, bool print_node_labels, bool use_context_when_sharing_leaves, bool print_prologue_and_epi"), kc_current_view );
		  kc_printer(kc_t("logue) const\
\n{\
\n    int kc_edge_nr = 1;\
\n    kc_dotedgenode_t kc_edges = 0;\
\n    if (print_prologue_and_epilogue) fprintdotprologue(f);\
\n    /*if (kc_outmost)*/ kc_do_printdot_subgraph_prolo"), kc_current_view );
		  kc_printer(kc_t("gue(f, this, root_label_prefix, edge_attributes, print_node_labels, use_context_when_sharing_leaves);\
\n    fprintdot_hashtable = new kc_dotedge_ht;\
\n    do_printdot(f, true, &kc_edge_nr, &kc_edges,"), kc_current_view );
		  kc_printer(kc_t(" edge_label_prefix, print_node_labels, use_context_when_sharing_leaves, 0, 0);\
\n    kc_do_printdot_edges(f, kc_edges, edge_attributes, use_context_when_sharing_leaves);\
\n    delete fprintdot_hashta"), kc_current_view );
		  kc_printer(kc_t("ble;\
\n	fprintdot_hashtable=0;\
\n    /*if (kc_outmost)*/ kc_do_printdot_subgraph_epilogue(f);\
\n    if (print_prologue_and_epilogue) fprintdotepilogue(f);\
\n}\
\n"), kc_current_view); }
	    } else
		    goto kc_unparsing_default;
	    break;
	}
	case view_gen_attributeOf_function_enum: {
	    view_gen_attributeOf_function_class& kc_current_view=static_cast<view_gen_attributeOf_function_class&>(kc_current_view_base);
	    if ((this->productionblock_1->prod_sel() == sel_Emptyproductionblock)) {
	    } else
		if ((this->productionblock_1->prod_sel() == sel_ListAlternatives)) {
		const ID id = this->ID_1;
		const alternatives a = phylum_cast<const impl_productionblock_ListAlternatives*>(this->productionblock_1)->alternatives_1;
		The_abstract_phylum_decl->additional_members->unparse(kc_printer, view_count_attrs);
		int attrcount = gl_no_of_args;
		arguments attrs = gl_args;
		ac_identifier_list idents = gl_idents; 
		kc::unparse(additional_members, kc_printer, view_count_attrs);
		gl_no_of_args += attrcount; 
		gl_args = concat(gl_args, attrs); 
		gl_idents = concat(gl_idents, idents); 
		kc::unparse(a, kc_printer, kc_current_view);
	    } else
		if ((this->productionblock_1->prod_sel() == sel_NonlistAlternatives)) {
		const ID id = this->ID_1;
		const alternatives a = phylum_cast<const impl_productionblock_NonlistAlternatives*>(this->productionblock_1)->alternatives_1;
		The_abstract_phylum_decl->additional_members->unparse(kc_printer, view_count_attrs);
		int attrcount = gl_no_of_args;
		arguments attrs = gl_args;
		ac_identifier_list idents = gl_idents; 
		kc::unparse(additional_members, kc_printer, view_count_attrs);
		gl_no_of_args += attrcount; 
		gl_args = concat(gl_args, attrs); 
		gl_idents = concat(gl_idents, idents); 
		kc::unparse(a, kc_printer, kc_current_view);
	    } else
		if ((this->productionblock_1->prod_sel() == sel_PredefinedAlternatives)) {
		const ID id = this->ID_1;
		const alternatives a = phylum_cast<const impl_productionblock_PredefinedAlternatives*>(this->productionblock_1)->alternatives_1;
		The_abstract_phylum_decl->additional_members->unparse(kc_printer, view_count_attrs);
		int attrcount = gl_no_of_args;
		arguments attrs = gl_args;
		ac_identifier_list idents = gl_idents; 
		kc::unparse(additional_members, kc_printer, view_count_attrs);
		gl_no_of_args += attrcount; 
		gl_args = concat(gl_args, attrs); 
		gl_idents = concat(gl_idents, idents); 
		kc::unparse(a, kc_printer, kc_current_view);
	    } else
		    goto kc_unparsing_default;
	    break;
	}
	case view_gen_create_function_enum: {
	    view_gen_create_function_class& kc_current_view=static_cast<view_gen_create_function_class&>(kc_current_view_base);
	    if ((this->productionblock_1->prod_sel() == sel_ListAlternatives)) {
		const alternatives alts = phylum_cast<const impl_productionblock_ListAlternatives*>(this->productionblock_1)->alternatives_1;
		kc::unparse(alts, kc_printer, kc_current_view);
	    } else
		if ((this->productionblock_1->prod_sel() == sel_NonlistAlternatives)) {
		const alternatives alts = phylum_cast<const impl_productionblock_NonlistAlternatives*>(this->productionblock_1)->alternatives_1;
		kc::unparse(alts, kc_printer, kc_current_view);
	    } else
		if ((this->productionblock_1->prod_sel() == sel_PredefinedAlternatives)) {
	    } else
		    goto kc_unparsing_default;
	    break;
	}
	case view_gen_operatordefs_c_enum: {
	    view_gen_operatordefs_c_class& kc_current_view=static_cast<view_gen_operatordefs_c_class&>(kc_current_view_base);
	    if ((this->storageoption_1->prod_sel() == sel_NoStorageOption) && (this->productionblock_1->prod_sel() == sel_ListAlternatives)) {
		const ID id = this->ID_1;
		const alternatives alts = phylum_cast<const impl_productionblock_ListAlternatives*>(this->productionblock_1)->alternatives_1;
		const Ccode_option cco = this->Ccode_option_1;
		gl_phylum = id; gl_cco = cco; 
		kc::unparse(alts, kc_printer, view_gen_operatordefs_nonhash_c);
		gl_phylum = 0; gl_cco = (Ccode_option)0; 
			} else
		if ((this->storageoption_1->prod_sel() == sel_NegativeStorageOption) && (this->productionblock_1->prod_sel() == sel_ListAlternatives)) {
		const ID id = this->ID_1;
		const alternatives alts = phylum_cast<const impl_productionblock_ListAlternatives*>(this->productionblock_1)->alternatives_1;
		const Ccode_option cco = this->Ccode_option_1;
		gl_phylum = id; gl_cco = cco; 
		kc::unparse(alts, kc_printer, view_gen_operatordefs_nonhash_c);
		gl_phylum = 0; gl_cco = (Ccode_option)0; 
			} else
		if ((this->storageoption_1->prod_sel() == sel_NoStorageOption) && (this->productionblock_1->prod_sel() == sel_NonlistAlternatives)) {
		const ID id = this->ID_1;
		const alternatives alts = phylum_cast<const impl_productionblock_NonlistAlternatives*>(this->productionblock_1)->alternatives_1;
		const Ccode_option cco = this->Ccode_option_1;
		gl_phylum = id; gl_cco = cco; 
		kc::unparse(alts, kc_printer, view_gen_operatordefs_nonhash_c);
		gl_phylum = 0; gl_cco = (Ccode_option)0; 
			} else
		if ((this->storageoption_1->prod_sel() == sel_NegativeStorageOption) && (this->productionblock_1->prod_sel() == sel_NonlistAlternatives)) {
		const ID id = this->ID_1;
		const alternatives alts = phylum_cast<const impl_productionblock_NonlistAlternatives*>(this->productionblock_1)->alternatives_1;
		const Ccode_option cco = this->Ccode_option_1;
		gl_phylum = id; gl_cco = cco; 
		kc::unparse(alts, kc_printer, view_gen_operatordefs_nonhash_c);
		gl_phylum = 0; gl_cco = (Ccode_option)0; 
			} else
		if ((this->storageoption_1->prod_sel() == sel_PositiveStorageOption) && (this->productionblock_1->prod_sel() == sel_ListAlternatives)) {
		const ID id = this->ID_1;
		const ID sto = phylum_cast<const impl_storageoption_PositiveStorageOption*>(this->storageoption_1)->ID_1;
		const alternatives alts = phylum_cast<const impl_productionblock_ListAlternatives*>(this->productionblock_1)->alternatives_1;
		const Ccode_option cco = this->Ccode_option_1;
		gl_phylum = id; gl_cco = cco; gl_sto = sto; 
		kc::unparse(alts, kc_printer, view_gen_operatordefs_hash_c);
		gl_phylum = 0; gl_cco = (Ccode_option)0; gl_sto = 0; 
			} else
		if ((this->storageoption_1->prod_sel() == sel_PositiveStorageOption) && (this->productionblock_1->prod_sel() == sel_NonlistAlternatives)) {
		const ID id = this->ID_1;
		const ID sto = phylum_cast<const impl_storageoption_PositiveStorageOption*>(this->storageoption_1)->ID_1;
		const alternatives alts = phylum_cast<const impl_productionblock_NonlistAlternatives*>(this->productionblock_1)->alternatives_1;
		const Ccode_option cco = this->Ccode_option_1;
		gl_phylum = id; gl_cco = cco; gl_sto = sto; 
		kc::unparse(alts, kc_printer, view_gen_operatordefs_hash_c);
		gl_phylum = 0; gl_cco = (Ccode_option)0; gl_sto = 0; 
			} else
		if ((this->productionblock_1->prod_sel() == sel_Emptyproductionblock)) {
	    } else
		if ((this->productionblock_1->prod_sel() == sel_PredefinedAlternatives)) {
	    } else
		    goto kc_unparsing_default;
	    break;
	}
	case view_gen_operatorcast_h_enum: {
	    view_gen_operatorcast_h_class& kc_current_view=static_cast<view_gen_operatorcast_h_class&>(kc_current_view_base);
	    if ((this->productionblock_1->prod_sel() == sel_Emptyproductionblock)) {
	    } else
		if ((this->productionblock_1->prod_sel() == sel_ListAlternatives)) {
		const ID id = this->ID_1;
		const ID el = phylum_cast<const impl_productionblock_ListAlternatives*>(this->productionblock_1)->ID_1;
		{ kc_printer(kc_t("//"), kc_current_view); }
		kc::unparse(id, kc_printer, kc_current_view);
		{ kc_printer(kc_t(" Nil"), kc_current_view); }
		kc::unparse(id, kc_printer, kc_current_view);
		{ kc_printer(kc_t("();\
\n    //"), kc_current_view); }
		kc::unparse(id, kc_printer, kc_current_view);
		{ kc_printer(kc_t(" Cons"), kc_current_view); }
		kc::unparse(id, kc_printer, kc_current_view);
		{ kc_printer(kc_t("("), kc_current_view); }
		kc::unparse(el, kc_printer, kc_current_view);
		{ kc_printer(kc_t(","), kc_current_view); }
		kc::unparse(id, kc_printer, kc_current_view);
		{ kc_printer(kc_t(");\
\n"), kc_current_view); }
	    } else
		if ((this->productionblock_1->prod_sel() == sel_NonlistAlternatives)) {
		const alternatives a = phylum_cast<const impl_productionblock_NonlistAlternatives*>(this->productionblock_1)->alternatives_1;
		kc::unparse(a, kc_printer, kc_current_view);
	    } else
		if ((this->productionblock_1->prod_sel() == sel_PredefinedAlternatives)) {
	    } else
		    goto kc_unparsing_default;
	    break;
	}
	case view_gen_operatordecls_h_enum: {
	    view_gen_operatordecls_h_class& kc_current_view=static_cast<view_gen_operatordecls_h_class&>(kc_current_view_base);
	    if ((this->productionblock_1->prod_sel() == sel_Emptyproductionblock)) {
	    } else
		if ((this->productionblock_1->prod_sel() == sel_ListAlternatives)) {
		const ID id = this->ID_1;
		const ID el = phylum_cast<const impl_productionblock_ListAlternatives*>(this->productionblock_1)->ID_1;
		kc::unparse(id, kc_printer, kc_current_view);
		{ kc_printer(kc_t(" Nil"), kc_current_view); }
		kc::unparse(id, kc_printer, kc_current_view);
		{ kc_printer(kc_t("();\
\n    "), kc_current_view); }
		kc::unparse(id, kc_printer, kc_current_view);
		{ kc_printer(kc_t(" Cons"), kc_current_view); }
		kc::unparse(id, kc_printer, kc_current_view);
		{ kc_printer(kc_t("("), kc_current_view); }
		kc::unparse(el, kc_printer, kc_current_view);
		{ kc_printer(kc_t(","), kc_current_view); }
		kc::unparse(id, kc_printer, kc_current_view);
		{ kc_printer(kc_t(");\
\n"), kc_current_view); }
	    } else
		if ((this->productionblock_1->prod_sel() == sel_NonlistAlternatives)) {
		const alternatives a = phylum_cast<const impl_productionblock_NonlistAlternatives*>(this->productionblock_1)->alternatives_1;
		kc::unparse(a, kc_printer, kc_current_view);
	    } else
		if ((this->productionblock_1->prod_sel() == sel_PredefinedAlternatives)) {
	    } else
		    goto kc_unparsing_default;
	    break;
	}
	case view_gen_yaccstacktype_h_enum: {
	    view_gen_yaccstacktype_h_class& kc_current_view=static_cast<view_gen_yaccstacktype_h_class&>(kc_current_view_base);
	    {
		const ID id = this->ID_1;
		{ kc_printer(kc_t("    kc::"), kc_current_view); }
		kc::unparse(id, kc_printer, kc_current_view);
		{ kc_printer(kc_t(" yt_"), kc_current_view); }
		kc::unparse(id, kc_printer, kc_current_view);
		{ kc_printer(kc_t(";\
\n"), kc_current_view); }
	    }
	    break;
	}
	case view_gen_nodetypedefs_h_enum: {
	    view_gen_nodetypedefs_h_class& kc_current_view=static_cast<view_gen_nodetypedefs_h_class&>(kc_current_view_base);
	    if ((this->productionblock_1->prod_sel() == sel_PredefinedAlternatives) && (phylum_cast<const impl_productionblock_PredefinedAlternatives*>(this->productionblock_1)->alternatives_1->prod_sel() == sel_Consalternatives) && ((phylum_cast<const impl_productionblock_PredefinedAlternatives*>(this->productionblock_1)->alternatives_1)->alternative_1->prod_sel() == sel_Alternative)) {
		const ID id = this->ID_1;
		const ID oid = phylum_cast<const impl_alternative_Alternative*>((phylum_cast<const impl_productionblock_PredefinedAlternatives*>(this->productionblock_1)->alternatives_1)->alternative_1)->ID_1;
		{ kc_printer(kc_t("typedef impl_"), kc_current_view); }
		kc::unparse(id, kc_printer, kc_current_view);
		{ kc_printer(kc_t("_"), kc_current_view); }
		kc::unparse(oid, kc_printer, kc_current_view);
		{ kc_printer(kc_t(" *"), kc_current_view); }
		kc::unparse(id, kc_printer, kc_current_view);
		{ kc_printer(kc_t(";\
\ntypedef const impl_"), kc_current_view); }
		kc::unparse(id, kc_printer, kc_current_view);
		{ kc_printer(kc_t("_"), kc_current_view); }
		kc::unparse(oid, kc_printer, kc_current_view);
		{ kc_printer(kc_t(" *c_"), kc_current_view); }
		kc::unparse(id, kc_printer, kc_current_view);
		{ kc_printer(kc_t(";\
\n"), kc_current_view); }
	    } else
		if ((this->productionblock_1->prod_sel() == sel_Emptyproductionblock)) {
	    } else
	    {
		const ID id = this->ID_1;
		{ kc_printer(kc_t("typedef impl_"), kc_current_view); }
		kc::unparse(id, kc_printer, kc_current_view);
		{ kc_printer(kc_t(" *"), kc_current_view); }
		kc::unparse(id, kc_printer, kc_current_view);
		{ kc_printer(kc_t(";\
\ntypedef const impl_"), kc_current_view); }
		kc::unparse(id, kc_printer, kc_current_view);
		{ kc_printer(kc_t(" *c_"), kc_current_view); }
		kc::unparse(id, kc_printer, kc_current_view);
		{ kc_printer(kc_t(";\
\n"), kc_current_view); }
	    }
	    break;
	}
	case view_gen_operatormap_attributes_enum: {
	    view_gen_operatormap_attributes_class& kc_current_view=static_cast<view_gen_operatormap_attributes_class&>(kc_current_view_base);
	    if ((this->productionblock_1->prod_sel() == sel_Emptyproductionblock)) {
	    } else
		if ((this->productionblock_1->prod_sel() == sel_ListAlternatives)) {
		const ID id = this->ID_1;
		const alternatives a = phylum_cast<const impl_productionblock_ListAlternatives*>(this->productionblock_1)->alternatives_1;
		The_abstract_phylum_decl->additional_members->unparse(kc_printer, view_count_attrs);
		int attrcount = gl_no_of_args;
		arguments attrs = gl_args;
		ac_identifier_list idents = gl_idents; 
		kc::unparse(additional_members, kc_printer, view_count_attrs);
		gl_no_of_args += attrcount; 
		gl_args = concat(gl_args, attrs); 
		gl_idents = concat(gl_idents, idents); 
		kc::unparse(a, kc_printer, kc_current_view);
	    } else
		if ((this->productionblock_1->prod_sel() == sel_NonlistAlternatives)) {
		const ID id = this->ID_1;
		const alternatives a = phylum_cast<const impl_productionblock_NonlistAlternatives*>(this->productionblock_1)->alternatives_1;
		The_abstract_phylum_decl->additional_members->unparse(kc_printer, view_count_attrs);
		int attrcount = gl_no_of_args;
		arguments attrs = gl_args;
		ac_identifier_list idents = gl_idents; 
		kc::unparse(additional_members, kc_printer, view_count_attrs);
		gl_no_of_args += attrcount; 
		gl_args = concat(gl_args, attrs); 
		gl_idents = concat(gl_idents, idents); 
		kc::unparse(a, kc_printer, kc_current_view);
	    } else
		if ((this->productionblock_1->prod_sel() == sel_PredefinedAlternatives)) {
		const ID id = this->ID_1;
		const alternatives a = phylum_cast<const impl_productionblock_PredefinedAlternatives*>(this->productionblock_1)->alternatives_1;
		The_abstract_phylum_decl->additional_members->unparse(kc_printer, view_count_attrs);
		int attrcount = gl_no_of_args;
		arguments attrs = gl_args;
		ac_identifier_list idents = gl_idents; 
		kc::unparse(additional_members, kc_printer, view_count_attrs);
		gl_no_of_args += attrcount; 
		gl_args = concat(gl_args, attrs); 
		gl_idents = concat(gl_idents, idents); 
		kc::unparse(a, kc_printer, kc_current_view);
	    } else
		    goto kc_unparsing_default;
	    break;
	}
	case view_gen_operatormap_subphyla_enum: {
	    view_gen_operatormap_subphyla_class& kc_current_view=static_cast<view_gen_operatormap_subphyla_class&>(kc_current_view_base);
	    if ((this->productionblock_1->prod_sel() == sel_Emptyproductionblock)) {
	    } else
		if ((this->productionblock_1->prod_sel() == sel_ListAlternatives)) {
		const alternatives a = phylum_cast<const impl_productionblock_ListAlternatives*>(this->productionblock_1)->alternatives_1;
		kc::unparse(a, kc_printer, kc_current_view);
	    } else
		if ((this->productionblock_1->prod_sel() == sel_NonlistAlternatives)) {
		const alternatives a = phylum_cast<const impl_productionblock_NonlistAlternatives*>(this->productionblock_1)->alternatives_1;
		kc::unparse(a, kc_printer, kc_current_view);
	    } else
		if ((this->productionblock_1->prod_sel() == sel_PredefinedAlternatives)) {
		const alternatives a = phylum_cast<const impl_productionblock_PredefinedAlternatives*>(this->productionblock_1)->alternatives_1;
		kc::unparse(a, kc_printer, kc_current_view);
	    } else
		    goto kc_unparsing_default;
	    break;
	}
	case view_gen_operatormap_c_enum: {
	    view_gen_operatormap_c_class& kc_current_view=static_cast<view_gen_operatormap_c_class&>(kc_current_view_base);
	    if ((this->productionblock_1->prod_sel() == sel_Emptyproductionblock)) {
	    } else
		if ((this->productionblock_1->prod_sel() == sel_ListAlternatives)) {
		const ID id = this->ID_1;
		const storageoption st_opt = this->storageoption_1;
		const alternatives a = phylum_cast<const impl_productionblock_ListAlternatives*>(this->productionblock_1)->alternatives_1;
		const Ccode_option cco = this->Ccode_option_1;
		gl_phylum = id; gl_storageoption = st_opt; gl_atomicity = false; 
		kc::unparse(a, kc_printer, kc_current_view);
		gl_phylum = 0; gl_storageoption = 0; 
			} else
		if ((this->productionblock_1->prod_sel() == sel_NonlistAlternatives)) {
		const ID id = this->ID_1;
		const storageoption st_opt = this->storageoption_1;
		const alternatives a = phylum_cast<const impl_productionblock_NonlistAlternatives*>(this->productionblock_1)->alternatives_1;
		const Ccode_option cco = this->Ccode_option_1;
		gl_phylum = id; gl_storageoption = st_opt; gl_atomicity = false; 
		kc::unparse(a, kc_printer, kc_current_view);
		gl_phylum = 0; gl_storageoption = 0; 
			} else
		if ((this->productionblock_1->prod_sel() == sel_PredefinedAlternatives)) {
		const ID id = this->ID_1;
		const storageoption st_opt = this->storageoption_1;
		const alternatives a = phylum_cast<const impl_productionblock_PredefinedAlternatives*>(this->productionblock_1)->alternatives_1;
		const Ccode_option cco = this->Ccode_option_1;
		gl_phylum = id; gl_storageoption = st_opt; gl_atomicity = true; 
		kc::unparse(a, kc_printer, kc_current_view);
		gl_phylum = 0; gl_storageoption = 0; 
			} else
		    goto kc_unparsing_default;
	    break;
	}
	case view_gen_phylummap_c_enum: {
	    view_gen_phylummap_c_class& kc_current_view=static_cast<view_gen_phylummap_c_class&>(kc_current_view_base);
	    if ((this->productionblock_1->prod_sel() == sel_ListAlternatives)) {
		const ID id = this->ID_1;
		const storageoption st_opt = this->storageoption_1;
		const productionblock pb = this->productionblock_1;
		const Ccode_option cco = this->Ccode_option_1;
		gl_phylum = id; 
			{ kc_printer(kc_t("    { \""), kc_current_view); }
		kc::unparse(id, kc_printer, kc_current_view);
		{ kc_printer(kc_t("\", "), kc_current_view); }
		kc::unparse(pb, kc_printer, kc_current_view);
		{ kc_printer(kc_t(", "), kc_current_view); }
		kc::unparse(st_opt, kc_printer, kc_current_view);
		{ kc_printer(kc_t(" },\
\n"), kc_current_view); }
		gl_phylum = 0; 
			} else
	    {
		const ID id = this->ID_1;
		const storageoption st_opt = this->storageoption_1;
		const productionblock pb = this->productionblock_1;
		const Ccode_option cco = this->Ccode_option_1;
		gl_phylum = id; 
			{ kc_printer(kc_t("    { \""), kc_current_view); }
		kc::unparse(id, kc_printer, kc_current_view);
		{ kc_printer(kc_t("\", "), kc_current_view); }
		kc::unparse(pb, kc_printer, kc_current_view);
		{ kc_printer(kc_t(", "), kc_current_view); }
		kc::unparse(st_opt, kc_printer, kc_current_view);
		{ kc_printer(kc_t(" },\
\n"), kc_current_view); }
		gl_phylum = 0; 
	    }
	    break;
	}
	case view_gen_enumoperators_h_enum: {
	    view_gen_enumoperators_h_class& kc_current_view=static_cast<view_gen_enumoperators_h_class&>(kc_current_view_base);
	    if ((this->productionblock_1->prod_sel() == sel_Emptyproductionblock)) {
	    } else
		if ((this->productionblock_1->prod_sel() == sel_ListAlternatives)) {
		const alternatives a = phylum_cast<const impl_productionblock_ListAlternatives*>(this->productionblock_1)->alternatives_1;
		kc::unparse(a, kc_printer, kc_current_view);
	    } else
		if ((this->productionblock_1->prod_sel() == sel_NonlistAlternatives)) {
		const alternatives a = phylum_cast<const impl_productionblock_NonlistAlternatives*>(this->productionblock_1)->alternatives_1;
		kc::unparse(a, kc_printer, kc_current_view);
	    } else
		if ((this->productionblock_1->prod_sel() == sel_PredefinedAlternatives)) {
		const alternatives a = phylum_cast<const impl_productionblock_PredefinedAlternatives*>(this->productionblock_1)->alternatives_1;
		kc::unparse(a, kc_printer, kc_current_view);
	    } else
		    goto kc_unparsing_default;
	    break;
	}
	case view_gen_enumphyla_h_enum: {
	    view_gen_enumphyla_h_class& kc_current_view=static_cast<view_gen_enumphyla_h_class&>(kc_current_view_base);
	    {
		const ID id = this->ID_1;
		const productionblock productions = this->productionblock_1;
		{ kc_printer(kc_t("    phylum_"), kc_current_view); }
		kc::unparse(id, kc_printer, kc_current_view);
		{ kc_printer(kc_t(" = "), kc_current_view); }
		kc::unparse(g_no_of_phyla, kc_printer, kc_current_view);
		{ kc_printer(kc_t(",\
\n"), kc_current_view); }
		g_no_of_phyla++; 
	    }
	    break;
	}
	case view_gen_deprecated_enum: {
	    view_gen_deprecated_class& kc_current_view=static_cast<view_gen_deprecated_class&>(kc_current_view_base);
	    {
		const ID id = this->ID_1;
		const productionblock productions = this->productionblock_1;
		{ kc_printer(kc_t("#define kc_phylum_"), kc_current_view); }
		kc::unparse(id, kc_printer, kc_current_view);
		{ kc_printer(kc_t(" phylum_"), kc_current_view); }
		kc::unparse(id, kc_printer, kc_current_view);
		{ kc_printer(kc_t("\
\n"), kc_current_view); }
		gl_phylum = id;
		kc::unparse(productions, kc_printer, kc_current_view);
	    }
	    break;
	}
	case view_check_uniq2_enum: {
	    view_check_uniq2_class& kc_current_view=static_cast<view_check_uniq2_class&>(kc_current_view_base);
	    if ((this->storageoption_1->prod_sel() == sel_PositiveStorageOption) && (this->productionblock_1->prod_sel() == sel_Emptyproductionblock)) {
	    } else
		if ((this->storageoption_1->prod_sel() == sel_PositiveStorageOption) && (this->productionblock_1->prod_sel() == sel_ListAlternatives)) {
	    } else
		if ((this->storageoption_1->prod_sel() == sel_PositiveStorageOption) && (this->productionblock_1->prod_sel() == sel_NonlistAlternatives)) {
	    } else
		if ((this->storageoption_1->prod_sel() == sel_PositiveStorageOption) && (this->productionblock_1->prod_sel() == sel_PredefinedAlternatives)) {
	    } else
		if ((this->productionblock_1->prod_sel() == sel_Emptyproductionblock)) {
	    } else
		if ((this->productionblock_1->prod_sel() == sel_ListAlternatives)) {
		const ID id = this->ID_1;
		if (! this->marked) 
		{
		    v_report(NonFatal( FileLine( cl_storageID->file, cl_storageID->line ),
			    Problem1S1ID1S1ID( "'uniq' declared phylum:", cl_uniqueID,
				"has non 'uniq' (transitive) subterm:", id) ));
		    (this)->marked = 1;

		    kc::unparse(this, kc_printer, view_check_uniq1);
		}
	    } else
		if ((this->productionblock_1->prod_sel() == sel_NonlistAlternatives)) {
		const ID id = this->ID_1;
		if (! this->marked) 
		{
		    v_report(NonFatal( FileLine( cl_storageID->file, cl_storageID->line ),
			    Problem1S1ID1S1ID( "'uniq' declared phylum:", cl_uniqueID,
				"has non 'uniq' (transitive) subterm:", id) ));
		    (this)->marked = 1;

		    kc::unparse(this, kc_printer, view_check_uniq1);
		}
	    } else
		if ((this->productionblock_1->prod_sel() == sel_PredefinedAlternatives)) {
	    } else
		    goto kc_unparsing_default;
	    break;
	}
	case view_check_uniq1_enum: {
	    view_check_uniq1_class& kc_current_view=static_cast<view_check_uniq1_class&>(kc_current_view_base);
	    {
		const productionblock pb = this->productionblock_1;
		kc::unparse(pb, kc_printer, kc_current_view);
	    }
	    break;
	}
	case view_check_uniq_enum: {
	    view_check_uniq_class& kc_current_view=static_cast<view_check_uniq_class&>(kc_current_view_base);
	    if ((this->storageoption_1->prod_sel() == sel_NoStorageOption)) {
		const productionblock pb = this->productionblock_1;
		kc::unparse(pb, kc_printer, kc_current_view);
	    } else
		if ((this->storageoption_1->prod_sel() == sel_NegativeStorageOption)) {
	    } else
		if ((this->storageoption_1->prod_sel() == sel_PositiveStorageOption)) {
		const ID id = this->ID_1;
		const ID s_id = phylum_cast<const impl_storageoption_PositiveStorageOption*>(this->storageoption_1)->ID_1;
		const productionblock pb = this->productionblock_1;
		this->marked = 1;
		cl_uniqueID = id;
		cl_storageID = s_id;

		kc::unparse(pb, kc_printer, view_check_uniq1);
		v_reset_phylumdeclaration_marks();
		cl_uniqueID = 0;
		cl_storageID = 0;

	    } else
		    goto kc_unparsing_default;
	    break;
	}
	case view_gen_initializephyla_c_enum: {
	    view_gen_initializephyla_c_class& kc_current_view=static_cast<view_gen_initializephyla_c_class&>(kc_current_view_base);
	    if ((this->productionblock_1->prod_sel() == sel_Emptyproductionblock)) {
	    } else
		if ((this->productionblock_1->prod_sel() == sel_PredefinedAlternatives)) {
	    } else
		if ((this->productionblock_1->prod_sel() == sel_ListAlternatives)) {
		const ID id = this->ID_1;
		const productionblock a = this->productionblock_1;
		const Ccode_option cco = this->Ccode_option_1;
		if (f_something_to_initialize( cco )) 
		{
		    kc::unparse(id, kc_printer, kc_current_view);
		    { kc_printer(kc_t(" kc_initialize_"), kc_current_view); }
		    kc::unparse(id, kc_printer, kc_current_view);
		    { kc_printer(kc_t("("), kc_current_view); }
		    kc::unparse(id, kc_printer, kc_current_view);
		    { kc_printer(kc_t(" kc_x)\
\n{\
\n"), kc_current_view); }
		    kc::unparse(cco, kc_printer, kc_current_view);
		    kc::unparse(g_emptystring, kc_printer, view_printer_outputfileline);
		    { kc_printer(kc_t("    return kc_x;\
\n}\
\n\
\n"), kc_current_view); }
		}
		kc::unparse(a, kc_printer, kc_current_view);
	    } else
		if ((this->productionblock_1->prod_sel() == sel_NonlistAlternatives)) {
		const ID id = this->ID_1;
		const productionblock a = this->productionblock_1;
		const Ccode_option cco = this->Ccode_option_1;
		if (f_something_to_initialize( cco )) 
		{
		    kc::unparse(id, kc_printer, kc_current_view);
		    { kc_printer(kc_t(" kc_initialize_"), kc_current_view); }
		    kc::unparse(id, kc_printer, kc_current_view);
		    { kc_printer(kc_t("("), kc_current_view); }
		    kc::unparse(id, kc_printer, kc_current_view);
		    { kc_printer(kc_t(" kc_x)\
\n{\
\n"), kc_current_view); }
		    kc::unparse(cco, kc_printer, kc_current_view);
		    kc::unparse(g_emptystring, kc_printer, view_printer_outputfileline);
		    { kc_printer(kc_t("    return kc_x;\
\n}\
\n\
\n"), kc_current_view); }
		}
		kc::unparse(a, kc_printer, kc_current_view);
	    } else
		    goto kc_unparsing_default;
	    break;
	}
	case view_check_count1_enum: {
	    view_check_count1_class& kc_current_view=static_cast<view_check_count1_class&>(kc_current_view_base);
	    if ((this->productionblock_1->prod_sel() == sel_Emptyproductionblock)) {
		const ID id = this->ID_1;
		const storageoption stopt = this->storageoption_1;
		gl_phylum = id; 
		kc::unparse(stopt, kc_printer, kc_current_view);
		gl_phylum = 0; 
		 v_report(NonFatal( NoFileLine(),
			Problem1S1ID( "no operators defined for phylum", id ))); 
			} else
	    {
		const ID id = this->ID_1;
		const storageoption stopt = this->storageoption_1;
		const productionblock pb = this->productionblock_1;
		gl_phylum = id; 
		kc::unparse(stopt, kc_printer, kc_current_view);
		gl_phylum = 0; 
		kc::unparse(pb, kc_printer, kc_current_view);
	    }
	    break;
	}
	case view_check_enum: {
	    view_check_class& kc_current_view=static_cast<view_check_class&>(kc_current_view_base);
	    {
		const ID i = this->ID_1;
		const Ccode_option cco = this->Ccode_option_1;
		outmostoperators.push( Niloperators() );
		dollarvarsallowed.push( DVAllowed() );
		phylumstack.push( i );

		kc::unparse(cco, kc_printer, kc_current_view);
		outmostoperators.top()->freelist();
		outmostoperators.pop();
		dollarvarsallowed.pop();
		phylumstack.pop();

	    }
	    break;
	}

	default:
	kc_unparsing_default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    { /* Alternative( *, args ) -> [view_gen_unparsedefs_default_c: */
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


void
impl_storageoption_PositiveStorageOption::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case view_gen_phylummap_c_enum: {
	    view_gen_phylummap_c_class& kc_current_view=static_cast<view_gen_phylummap_c_class&>(kc_current_view_base);
	    {
		const ID sc = this->ID_1;
		kc::unparse(sc, kc_printer, kc_current_view);
	    }
	    break;
	}
	case view_check_count1_enum: {
	    view_check_count1_class& kc_current_view=static_cast<view_check_count1_class&>(kc_current_view_base);
	    {
		const ID sc = this->ID_1;
		if (pg_storageclasseshavebeendefined)
		f_useoccurstorageclass( sc );
		else v_extendoccur( sc, ITStorageClass() );
		v_add_to_storageclasses( sc, gl_phylum );

	    }
	    break;
	}
	case view_error_enum: {
	    view_error_class& kc_current_view=static_cast<view_error_class&>(kc_current_view_base);
	    {
		const ID id = this->ID_1;
		{ kc_printer(kc_t("{ "), kc_current_view); }
		kc::unparse(id, kc_printer, kc_current_view);
		{ kc_printer(kc_t(" } at "), kc_current_view); }
		kc::unparse(id->file, kc_printer, kc_current_view);
		{ kc_printer(kc_t(":"), kc_current_view); }
		kc::unparse(id->line, kc_printer, kc_current_view);
	    }
	    break;
	}

	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    { /* Alternative( *, args ) -> [view_gen_unparsedefs_default_c: */
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


void
impl_storageoption_NegativeStorageOption::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case view_gen_phylummap_c_enum: {
	    view_gen_phylummap_c_class& kc_current_view=static_cast<view_gen_phylummap_c_class&>(kc_current_view_base);
	    {
		{ kc_printer(kc_t("kc_not_uniq"), kc_current_view); }
	    }
	    break;
	}
	case view_check_count1_enum: {
	    view_check_count1_class& kc_current_view=static_cast<view_check_count1_class&>(kc_current_view_base);
	    {
		const ID sc = this->ID_1;
		if (pg_storageclasseshavebeendefined)
		f_useoccurstorageclass( sc );
		else v_extendoccur( sc, ITStorageClass() );
		v_add_to_storageclasses( sc, gl_phylum );

	    }
	    break;
	}
	case view_error_enum: {
	    view_error_class& kc_current_view=static_cast<view_error_class&>(kc_current_view_base);
	    {
		const ID id = this->ID_1;
		{ kc_printer(kc_t("{! "), kc_current_view); }
		kc::unparse(id, kc_printer, kc_current_view);
		{ kc_printer(kc_t(" } at "), kc_current_view); }
		kc::unparse(id->file, kc_printer, kc_current_view);
		{ kc_printer(kc_t(":"), kc_current_view); }
		kc::unparse(id->line, kc_printer, kc_current_view);
	    }
	    break;
	}

	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    { /* Alternative( *, args ) -> [view_gen_unparsedefs_default_c: */
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


void
impl_storageoption_NoStorageOption::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case view_gen_phylummap_c_enum: {
	    view_gen_phylummap_c_class& kc_current_view=static_cast<view_gen_phylummap_c_class&>(kc_current_view_base);
	    {
		{ kc_printer(kc_t("kc_not_uniq"), kc_current_view); }
	    }
	    break;
	}
	case view_check_count1_enum: {
	    view_check_count1_class& kc_current_view=static_cast<view_check_count1_class&>(kc_current_view_base);
	    {
	    }
	    break;
	}
	case view_error_enum: {
	    view_error_class& kc_current_view=static_cast<view_error_class&>(kc_current_view_base);
	    {
	    }
	    break;
	}

	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    { /* Alternative( *, args ) -> [view_gen_unparsedefs_default_c: */
	    }
	    break;
	}
    }
}

void
impl_storageclasses::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    if(is_nil())
	nil_do_unparse(kc_printer, kc_current_view_base);
    else
	switch(kc_current_view_base) {
	case view_gen_operatordefs_c_2_enum: {
	    view_gen_operatordefs_c_2_class& kc_current_view=static_cast<view_gen_operatordefs_c_2_class&>(kc_current_view_base);
	    {
		const ID sc = this->ID_1;
		const storageclasses r_sc = this->storageclasses_1;
		kc::unparse(r_sc, kc_printer, kc_current_view);
		{ kc_printer(kc_t("&"), kc_current_view); }
		kc::unparse(sc, kc_printer, kc_current_view);
		{ kc_printer(kc_t("_static_hashtable,\
\n"), kc_current_view); }
	    }
	    break;
	}
	case view_gen_operatordefs_c_1_enum: {
	    view_gen_operatordefs_c_1_class& kc_current_view=static_cast<view_gen_operatordefs_c_1_class&>(kc_current_view_base);
	    if ((this->storageclasses_1->prod_sel() == sel_Nilstorageclasses)) {
		{ kc_printer(kc_t("true"), kc_current_view); }
	    } else
	    {
		const storageclasses r_sc = this->storageclasses_1;
		kc::unparse(r_sc, kc_printer, kc_current_view);
		{ kc_printer(kc_t(", true"), kc_current_view); }
	    }
	    break;
	}
	case view_gen_operatordefs_c_0_enum: {
	    view_gen_operatordefs_c_0_class& kc_current_view=static_cast<view_gen_operatordefs_c_0_class&>(kc_current_view_base);
	    {
		const ID sc = this->ID_1;
		const storageclasses r_sc = this->storageclasses_1;
		kc::unparse(r_sc, kc_printer, kc_current_view);
		{ kc_printer(kc_t("static hashtable_struct_t "), kc_current_view); }
		kc::unparse(sc, kc_printer, kc_current_view);
		{ kc_printer(kc_t("_static_hashtable;\
\n"), kc_current_view); }
	    }
	    break;
	}
	case view_gen_operatordefs_c_enum: {
	    view_gen_operatordefs_c_class& kc_current_view=static_cast<view_gen_operatordefs_c_class&>(kc_current_view_base);
	    if ((this->storageclasses_1->prod_sel() == sel_Nilstorageclasses)) {
		const ID sc = this->ID_1;
		{ kc_printer(kc_t("\""), kc_current_view); }
		kc::unparse(sc, kc_printer, kc_current_view);
		{ kc_printer(kc_t("\""), kc_current_view); }
	    } else
	    {
		const ID sc = this->ID_1;
		const storageclasses r_sc = this->storageclasses_1;
		kc::unparse(r_sc, kc_printer, kc_current_view);
		{ kc_printer(kc_t(", \""), kc_current_view); }
		kc::unparse(sc, kc_printer, kc_current_view);
		{ kc_printer(kc_t("\""), kc_current_view); }
	    }
	    break;
	}
	case view_gen_uniqmap_c_2_enum: {
	    view_gen_uniqmap_c_2_class& kc_current_view=static_cast<view_gen_uniqmap_c_2_class&>(kc_current_view_base);
	    if ((this->storageclasses_1->prod_sel() == sel_Nilstorageclasses)) {
		const ID sc = this->ID_1;
		if (this->phyla->length() > 0) 
		{
		    { kc_printer(kc_t("    phylumstorageclass_"), kc_current_view); }
		    kc::unparse(sc, kc_printer, kc_current_view);
		}
		else 
		{
		    { kc_printer(kc_t("    (KC_UNIQ_INFO)0"), kc_current_view); }
		}
	    } else
	    {
		const ID sc = this->ID_1;
		const storageclasses r_sc = this->storageclasses_1;
		kc::unparse(r_sc, kc_printer, kc_current_view);
		if (this->phyla->length() > 0) 
		{
		    { kc_printer(kc_t(",\
\n    phylumstorageclass_"), kc_current_view); }
		    kc::unparse(sc, kc_printer, kc_current_view);
		}
		else 
		{
		    { kc_printer(kc_t(",\
\n    (KC_UNIQ_INFO)0"), kc_current_view); }
		}
	    }
	    break;
	}
	case view_gen_uniqmap_c_1_enum: {
	    view_gen_uniqmap_c_1_class& kc_current_view=static_cast<view_gen_uniqmap_c_1_class&>(kc_current_view_base);
	    {
		const ID sc = this->ID_1;
		const storageclasses r_sc = this->storageclasses_1;
		kc::unparse(r_sc, kc_printer, kc_current_view);
		if (this->phyla->length() > 0) 
		{
		    { kc_printer(kc_t("static enum_phyla phylumstorageclass_"), kc_current_view); }
		    kc::unparse(sc, kc_printer, kc_current_view);
		    { kc_printer(kc_t("[] = { one_before_first_phylum, "), kc_current_view); }
		    kc::unparse(this->phyla, kc_printer, kc_current_view);
		    { kc_printer(kc_t("last_phylum };\
\n"), kc_current_view); }
		}
	    }
	    break;
	}
	case view_gen_uniqmap_c_enum: {
	    view_gen_uniqmap_c_class& kc_current_view=static_cast<view_gen_uniqmap_c_class&>(kc_current_view_base);
	    {
		kc::unparse(this, kc_printer, view_gen_uniqmap_c_1);
		{ kc_printer(kc_t("\
\nKC_UNIQ_INFO kc_UniqInfo[] = {\
\n"), kc_current_view); }
		kc::unparse(this, kc_printer, view_gen_uniqmap_c_2);
		{ kc_printer(kc_t("\
\n};\
\n"), kc_current_view); }
	    }
	    break;
	}
	case view_gen_operatormap_type_h_enum: {
	    view_gen_operatormap_type_h_class& kc_current_view=static_cast<view_gen_operatormap_type_h_class&>(kc_current_view_base);
	    if ((this->storageclasses_1->prod_sel() == sel_Nilstorageclasses)) {
		const ID sc = this->ID_1;
		kc::unparse(sc, kc_printer, kc_current_view);
	    } else
	    {
		const ID sc = this->ID_1;
		const storageclasses r_sc = this->storageclasses_1;
		kc::unparse(r_sc, kc_printer, kc_current_view);
		{ kc_printer(kc_t(",\
\n	"), kc_current_view); }
		kc::unparse(sc, kc_printer, kc_current_view);
	    }
	    break;
	}

	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    { /* Alternative( *, args ) -> [view_gen_unparsedefs_default_c: */
		for (storageclasses iterator_ = this; iterator_->storageclasses_1 != 0; iterator_ = iterator_->storageclasses_1)
		    iterator_->ID_1->unparse(kc_printer, kc_current_view);
	    }
	    break;
	}
    }
}

void
impl_storageclasses::nil_do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case view_gen_operatordefs_c_2_enum: {
	    view_gen_operatordefs_c_2_class& kc_current_view=static_cast<view_gen_operatordefs_c_2_class&>(kc_current_view_base);
	    {
	    }
	    break;
	}
	case view_gen_operatordefs_c_1_enum: {
	    view_gen_operatordefs_c_1_class& kc_current_view=static_cast<view_gen_operatordefs_c_1_class&>(kc_current_view_base);
	    {
	    }
	    break;
	}
	case view_gen_operatordefs_c_0_enum: {
	    view_gen_operatordefs_c_0_class& kc_current_view=static_cast<view_gen_operatordefs_c_0_class&>(kc_current_view_base);
	    {
	    }
	    break;
	}
	case view_gen_operatordefs_c_enum: {
	    view_gen_operatordefs_c_class& kc_current_view=static_cast<view_gen_operatordefs_c_class&>(kc_current_view_base);
	    {
	    }
	    break;
	}
	case view_gen_uniqmap_c_2_enum: {
	    view_gen_uniqmap_c_2_class& kc_current_view=static_cast<view_gen_uniqmap_c_2_class&>(kc_current_view_base);
	    {
	    }
	    break;
	}
	case view_gen_uniqmap_c_1_enum: {
	    view_gen_uniqmap_c_1_class& kc_current_view=static_cast<view_gen_uniqmap_c_1_class&>(kc_current_view_base);
	    {
	    }
	    break;
	}
	case view_gen_uniqmap_c_enum: {
	    view_gen_uniqmap_c_class& kc_current_view=static_cast<view_gen_uniqmap_c_class&>(kc_current_view_base);
	    {
	    }
	    break;
	}
	case view_gen_operatormap_type_h_enum: {
	    view_gen_operatormap_type_h_class& kc_current_view=static_cast<view_gen_operatormap_type_h_class&>(kc_current_view_base);
	    {
	    }
	    break;
	}

	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    { /* Alternative( *, args ) -> [view_gen_unparsedefs_default_c: */
	    }
	    break;
	}
    }
}


void
impl_productionblock_PredefinedAlternatives::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case view_gen_unparsedefs_c_enum: {
	    view_gen_unparsedefs_c_class& kc_current_view=static_cast<view_gen_unparsedefs_c_class&>(kc_current_view_base);
	    {
	    }
	    break;
	}
	case view_gen_phylummap_c_enum: {
	    view_gen_phylummap_c_class& kc_current_view=static_cast<view_gen_phylummap_c_class&>(kc_current_view_base);
	    if ((this->alternatives_1->prod_sel() == sel_Consalternatives) && ((this->alternatives_1)->alternative_1->prod_sel() == sel_Alternative) && ((this->alternatives_1)->alternatives_1->prod_sel() == sel_Nilalternatives)) {
		const ID oid = phylum_cast<const impl_alternative_Alternative*>((this->alternatives_1)->alternative_1)->ID_1;
		{ kc_printer(kc_t("sel_"), kc_current_view); }
		kc::unparse(oid, kc_printer, kc_current_view);
		{ kc_printer(kc_t(", sel_"), kc_current_view); }
		kc::unparse(oid, kc_printer, kc_current_view);
	    } else
		if ((this->alternatives_1->prod_sel() == sel_Consalternatives) && ((this->alternatives_1)->alternative_1->prod_sel() == sel_Alternative)) {
		const ID oid = phylum_cast<const impl_alternative_Alternative*>((this->alternatives_1)->alternative_1)->ID_1;
		const alternatives ra = (this->alternatives_1)->alternatives_1;
		{ kc_printer(kc_t("sel_"), kc_current_view); }
		kc::unparse(ra, kc_printer, kc_current_view);
		{ kc_printer(kc_t(", sel_"), kc_current_view); }
		kc::unparse(oid, kc_printer, kc_current_view);
	    } else
		    goto kc_unparsing_default;
	    break;
	}
	case view_gen_deprecated_enum: {
	    view_gen_deprecated_class& kc_current_view=static_cast<view_gen_deprecated_class&>(kc_current_view_base);
	    {
		const alternatives a = this->alternatives_1;
		kc::unparse(a, kc_printer, kc_current_view);
	    }
	    break;
	}
	case view_check_uniq1_enum: {
	    view_check_uniq1_class& kc_current_view=static_cast<view_check_uniq1_class&>(kc_current_view_base);
	    {
		const alternatives alt = this->alternatives_1;
		kc::unparse(alt, kc_printer, kc_current_view);
	    }
	    break;
	}
	case view_check_count1_enum: {
	    view_check_count1_class& kc_current_view=static_cast<view_check_count1_class&>(kc_current_view_base);
	    {
	    }
	    break;
	}

	default:
	kc_unparsing_default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    { /* Alternative( *, args ) -> [view_gen_unparsedefs_default_c: */
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


void
impl_productionblock_NonlistAlternatives::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case view_gen_classdefs_c_enum: {
	    view_gen_classdefs_c_class& kc_current_view=static_cast<view_gen_classdefs_c_class&>(kc_current_view_base);
	    {
		const alternatives alts = this->alternatives_1;
		kc::unparse(alts, kc_printer, kc_current_view);
	    }
	    break;
	}
	case view_gen_classdecls2_h_enum: {
	    view_gen_classdecls2_h_class& kc_current_view=static_cast<view_gen_classdecls2_h_class&>(kc_current_view_base);
	    {
		const alternatives alts = this->alternatives_1;
		kc::unparse(alts, kc_printer, kc_current_view);
	    }
	    break;
	}
	case view_gen_unparsedefs_c_enum: {
	    view_gen_unparsedefs_c_class& kc_current_view=static_cast<view_gen_unparsedefs_c_class&>(kc_current_view_base);
	    {
		const alternatives a = this->alternatives_1;
		kc::unparse(a, kc_printer, kc_current_view);
	    }
	    break;
	}
	case view_gen_rewritedefs_c_enum: {
	    view_gen_rewritedefs_c_class& kc_current_view=static_cast<view_gen_rewritedefs_c_class&>(kc_current_view_base);
	    {
		const alternatives a = this->alternatives_1;
		kc::unparse(a, kc_printer, kc_current_view);
	    }
	    break;
	}
	case view_gen_phylummap_c_enum: {
	    view_gen_phylummap_c_class& kc_current_view=static_cast<view_gen_phylummap_c_class&>(kc_current_view_base);
	    if ((this->alternatives_1->prod_sel() == sel_Consalternatives) && ((this->alternatives_1)->alternative_1->prod_sel() == sel_Alternative) && ((this->alternatives_1)->alternatives_1->prod_sel() == sel_Nilalternatives)) {
		const ID oid = phylum_cast<const impl_alternative_Alternative*>((this->alternatives_1)->alternative_1)->ID_1;
		{ kc_printer(kc_t("sel_"), kc_current_view); }
		kc::unparse(oid, kc_printer, kc_current_view);
		{ kc_printer(kc_t(", sel_"), kc_current_view); }
		kc::unparse(oid, kc_printer, kc_current_view);
	    } else
		if ((this->alternatives_1->prod_sel() == sel_Consalternatives) && ((this->alternatives_1)->alternative_1->prod_sel() == sel_Alternative)) {
		const ID oid = phylum_cast<const impl_alternative_Alternative*>((this->alternatives_1)->alternative_1)->ID_1;
		const alternatives ra = (this->alternatives_1)->alternatives_1;
		{ kc_printer(kc_t("sel_"), kc_current_view); }
		kc::unparse(ra, kc_printer, kc_current_view);
		{ kc_printer(kc_t(", sel_"), kc_current_view); }
		kc::unparse(oid, kc_printer, kc_current_view);
	    } else
		    goto kc_unparsing_default;
	    break;
	}
	case view_gen_deprecated_enum: {
	    view_gen_deprecated_class& kc_current_view=static_cast<view_gen_deprecated_class&>(kc_current_view_base);
	    {
		const alternatives a = this->alternatives_1;
		kc::unparse(a, kc_printer, kc_current_view);
	    }
	    break;
	}
	case view_check_uniq1_enum: {
	    view_check_uniq1_class& kc_current_view=static_cast<view_check_uniq1_class&>(kc_current_view_base);
	    {
		const alternatives alt = this->alternatives_1;
		kc::unparse(alt, kc_printer, kc_current_view);
	    }
	    break;
	}
	case view_gen_initializephyla_c_enum: {
	    view_gen_initializephyla_c_class& kc_current_view=static_cast<view_gen_initializephyla_c_class&>(kc_current_view_base);
	    {
		const alternatives a = this->alternatives_1;
		kc::unparse(a, kc_printer, kc_current_view);
	    }
	    break;
	}
	case view_check_count1_enum: {
	    view_check_count1_class& kc_current_view=static_cast<view_check_count1_class&>(kc_current_view_base);
	    {
		const alternatives alt = this->alternatives_1;
		kc::unparse(alt, kc_printer, kc_current_view);
	    }
	    break;
	}

	default:
	kc_unparsing_default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    { /* Alternative( *, args ) -> [view_gen_unparsedefs_default_c: */
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


void
impl_productionblock_ListAlternatives::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case view_gen_classdefs_c_enum: {
	    view_gen_classdefs_c_class& kc_current_view=static_cast<view_gen_classdefs_c_class&>(kc_current_view_base);
	    {
	    }
	    break;
	}
	case view_gen_classdecls2_h_enum: {
	    view_gen_classdecls2_h_class& kc_current_view=static_cast<view_gen_classdecls2_h_class&>(kc_current_view_base);
	    {
	    }
	    break;
	}
	case view_gen_unparsedefs_c_enum: {
	    view_gen_unparsedefs_c_class& kc_current_view=static_cast<view_gen_unparsedefs_c_class&>(kc_current_view_base);
	    if ((this->alternatives_1->prod_sel() == sel_Consalternatives) && ((this->alternatives_1)->alternative_1->prod_sel() == sel_Alternative) && ((this->alternatives_1)->alternatives_1->prod_sel() == sel_Consalternatives) && (((this->alternatives_1)->alternatives_1)->alternative_1->prod_sel() == sel_Alternative)) {
		const alternative consa = (this->alternatives_1)->alternative_1;
		const ID consid = phylum_cast<const impl_alternative_Alternative*>((this->alternatives_1)->alternative_1)->ID_1;
		const alternative nila = ((this->alternatives_1)->alternatives_1)->alternative_1;
		const ID nilid = phylum_cast<const impl_alternative_Alternative*>(((this->alternatives_1)->alternatives_1)->alternative_1)->ID_1;
		{ kc_printer(kc_t("void\
\nimpl_"), kc_current_view); }
		kc::unparse(gl_phylum, kc_printer, kc_current_view);
		{ kc_printer(kc_t("::do_unparse(printer_functor kc_printer, uview kc_current_view_base)\
\n{\
\n    if(is_nil())\
\n	nil_do_unparse(kc_printer, kc_current_view_base);\
\n    else\
\n	switch(kc_current_view_base) {\
\n"), kc_current_view); }
		unparseviewsinfo a_unparseviewsinfo = f_unparseviewsinfo_of_alternative( consa, Theuviewnames );
		gl_operator = consid; 
		kc::unparse(a_unparseviewsinfo, kc_printer, view_gen_unparsedefs_c);
		{ kc_printer(kc_t("	}\
\n}\
\n\
\nvoid\
\nimpl_"), kc_current_view); }
		kc::unparse(gl_phylum, kc_printer, kc_current_view);
		{ kc_printer(kc_t("::nil_do_unparse(printer_functor kc_printer, uview kc_current_view_base)\
\n{\
\n    switch(kc_current_view_base) {\
\n"), kc_current_view); }
		freespineandelements(a_unparseviewsinfo);
		a_unparseviewsinfo = f_unparseviewsinfo_of_alternative( nila, Theuviewnames );
		gl_operator = nilid; 
		kc::unparse(a_unparseviewsinfo, kc_printer, view_gen_unparsedefs_c);
		{ kc_printer(kc_t("    }\
\n}\
\n\
\n"), kc_current_view); }
		freespineandelements(a_unparseviewsinfo); 
			} else
		    goto kc_unparsing_default;
	    break;
	}
	case view_gen_rewritedefs_c_enum: {
	    view_gen_rewritedefs_c_class& kc_current_view=static_cast<view_gen_rewritedefs_c_class&>(kc_current_view_base);
	    if ((this->alternatives_1->prod_sel() == sel_Consalternatives) && ((this->alternatives_1)->alternative_1->prod_sel() == sel_Alternative) && ((this->alternatives_1)->alternatives_1->prod_sel() == sel_Consalternatives)) {
		const alternative consa = (this->alternatives_1)->alternative_1;
		const ID oid = phylum_cast<const impl_alternative_Alternative*>((this->alternatives_1)->alternative_1)->ID_1;
		const alternative nila = ((this->alternatives_1)->alternatives_1)->alternative_1;
		gl_phylum = f_phylumofoperator(oid); 
		 if(!g_options.rw_loop) 
		{
		    covariant_choice(gl_phylum, "", "abstract_phylum", kc_printer, kc_current_view); 
		     }
		else 
		{
		    { kc_printer(kc_t("abstract_phylum"), kc_current_view); }
		}
		{ kc_printer(kc_t(" impl_"), kc_current_view); }
		kc::unparse(gl_phylum, kc_printer, kc_current_view);
		{ kc_printer(kc_t("::"), kc_current_view); }
		if(f_rewrite_in_operatordecl(consa) || g_options.rw_loop) 
		{
		    { kc_printer(kc_t("do_"), kc_current_view); }
		}
		{ kc_printer(kc_t("rewrite(rview kc_current_view_base)\
\n{\
\n    if (is_nil()) {\
\n"), kc_current_view); }
		kc::unparse(nila, kc_printer, view_gen_rewritedefs_body_c);
		{ kc_printer(kc_t("   } else { // not Nil, Cons\
\n"), kc_current_view); }
		kc::unparse(consa, kc_printer, view_gen_rewritedefs_body_c);
		{ kc_printer(kc_t("   }\
\n}\
\n"), kc_current_view); }
		gl_phylum = 0; 
			} else
		    goto kc_unparsing_default;
	    break;
	}
	case view_gen_phylummap_c_enum: {
	    view_gen_phylummap_c_class& kc_current_view=static_cast<view_gen_phylummap_c_class&>(kc_current_view_base);
	    if ((this->alternatives_1->prod_sel() == sel_Consalternatives) && ((this->alternatives_1)->alternative_1->prod_sel() == sel_Alternative) && ((this->alternatives_1)->alternatives_1->prod_sel() == sel_Nilalternatives)) {
		const ID oid = phylum_cast<const impl_alternative_Alternative*>((this->alternatives_1)->alternative_1)->ID_1;
		{ kc_printer(kc_t("sel_"), kc_current_view); }
		kc::unparse(oid, kc_printer, kc_current_view);
		{ kc_printer(kc_t(", sel_"), kc_current_view); }
		kc::unparse(oid, kc_printer, kc_current_view);
	    } else
		if ((this->alternatives_1->prod_sel() == sel_Consalternatives) && ((this->alternatives_1)->alternative_1->prod_sel() == sel_Alternative)) {
		const ID oid = phylum_cast<const impl_alternative_Alternative*>((this->alternatives_1)->alternative_1)->ID_1;
		const alternatives ra = (this->alternatives_1)->alternatives_1;
		{ kc_printer(kc_t("sel_"), kc_current_view); }
		kc::unparse(ra, kc_printer, kc_current_view);
		{ kc_printer(kc_t(", sel_"), kc_current_view); }
		kc::unparse(oid, kc_printer, kc_current_view);
	    } else
		    goto kc_unparsing_default;
	    break;
	}
	case view_gen_deprecated_enum: {
	    view_gen_deprecated_class& kc_current_view=static_cast<view_gen_deprecated_class&>(kc_current_view_base);
	    {
		const alternatives a = this->alternatives_1;
		kc::unparse(a, kc_printer, kc_current_view);
	    }
	    break;
	}
	case view_check_uniq1_enum: {
	    view_check_uniq1_class& kc_current_view=static_cast<view_check_uniq1_class&>(kc_current_view_base);
	    {
		const alternatives alt = this->alternatives_1;
		kc::unparse(alt, kc_printer, kc_current_view);
	    }
	    break;
	}
	case view_gen_initializephyla_c_enum: {
	    view_gen_initializephyla_c_class& kc_current_view=static_cast<view_gen_initializephyla_c_class&>(kc_current_view_base);
	    {
		const alternatives a = this->alternatives_1;
		kc::unparse(a, kc_printer, kc_current_view);
	    }
	    break;
	}
	case view_check_count1_enum: {
	    view_check_count1_class& kc_current_view=static_cast<view_check_count1_class&>(kc_current_view_base);
	    {
		const alternatives alt = this->alternatives_1;
		kc::unparse(alt, kc_printer, kc_current_view);
	    }
	    break;
	}

	default:
	kc_unparsing_default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    { /* Alternative( *, args ) -> [view_gen_unparsedefs_default_c: */
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


void
impl_productionblock_Emptyproductionblock::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case view_gen_phylummap_c_enum: {
	    view_gen_phylummap_c_class& kc_current_view=static_cast<view_gen_phylummap_c_class&>(kc_current_view_base);
	    {
	    }
	    break;
	}
	case view_check_uniq1_enum: {
	    view_check_uniq1_class& kc_current_view=static_cast<view_check_uniq1_class&>(kc_current_view_base);
	    {
	    }
	    break;
	}

	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    { /* Alternative( *, args ) -> [view_gen_unparsedefs_default_c: */
	    }
	    break;
	}
    }
}

void
impl_alternatives::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    if(is_nil())
	nil_do_unparse(kc_printer, kc_current_view_base);
    else
	switch(kc_current_view_base) {
	case view_gen_set_subphylumdefs_c_enum: {
	    view_gen_set_subphylumdefs_c_class& kc_current_view=static_cast<view_gen_set_subphylumdefs_c_class&>(kc_current_view_base);
	    if ((this->alternative_1->prod_sel() == sel_Alternative) && (phylum_cast<const impl_alternative_Alternative*>(this->alternative_1)->arguments_1->prod_sel() == sel_Nilarguments)) {
		const alternatives ra = this->alternatives_1;
		kc::unparse(ra, kc_printer, kc_current_view);
	    } else
		if ((this->alternative_1->prod_sel() == sel_Alternative)) {
		const ID oid = phylum_cast<const impl_alternative_Alternative*>(this->alternative_1)->ID_1;
		const arguments args = phylum_cast<const impl_alternative_Alternative*>(this->alternative_1)->arguments_1;
		const alternatives ra = this->alternatives_1;
		ID id = f_phylumofoperator(oid); 
			{ kc_printer(kc_t("void impl_"), kc_current_view); }
		kc::unparse(id, kc_printer, kc_current_view);
		{ kc_printer(kc_t("_"), kc_current_view); }
		kc::unparse(oid, kc_printer, kc_current_view);
		{ kc_printer(kc_t("::set_subphylum(int no, abstract_phylum val)\
\n{\
\n    abstract_phylum newval=0;\
\n    switch(no) {\
\n"), kc_current_view); }
		gl_no_of_args = 0; 
		kc::unparse(args, kc_printer, kc_current_view);
		{ kc_printer(kc_t("   }\
\n    assertNonNull(newval);\
\n}\
\n"), kc_current_view); }
		kc::unparse(ra, kc_printer, kc_current_view);
	    } else
		    goto kc_unparsing_default;
	    break;
	}
	case view_gen_subphylumdefs_c_enum: {
	    view_gen_subphylumdefs_c_class& kc_current_view=static_cast<view_gen_subphylumdefs_c_class&>(kc_current_view_base);
	    if ((this->alternative_1->prod_sel() == sel_Alternative) && (phylum_cast<const impl_alternative_Alternative*>(this->alternative_1)->arguments_1->prod_sel() == sel_Nilarguments)) {
		const alternatives ra = this->alternatives_1;
		kc::unparse(ra, kc_printer, kc_current_view);
	    } else
		if ((this->alternative_1->prod_sel() == sel_Alternative)) {
		const ID oid = phylum_cast<const impl_alternative_Alternative*>(this->alternative_1)->ID_1;
		const arguments args = phylum_cast<const impl_alternative_Alternative*>(this->alternative_1)->arguments_1;
		const alternatives ra = this->alternatives_1;
		ID id = f_phylumofoperator(oid); 
			{ kc_printer(kc_t("abstract_phylum impl_"), kc_current_view); }
		kc::unparse(id, kc_printer, kc_current_view);
		{ kc_printer(kc_t("_"), kc_current_view); }
		kc::unparse(oid, kc_printer, kc_current_view);
		{ kc_printer(kc_t("::subphylum(int no) const\
\n{\
\n  switch(no){\
\n"), kc_current_view); }
		gl_no_of_args = 0; 
		kc::unparse(args, kc_printer, kc_current_view);
		{ kc_printer(kc_t("  }\
\n  return 0;\
\n}\
\n"), kc_current_view); }
		kc::unparse(ra, kc_printer, kc_current_view);
	    } else
		    goto kc_unparsing_default;
	    break;
	}
	case view_gen_classdefs_c_enum: {
	    view_gen_classdefs_c_class& kc_current_view=static_cast<view_gen_classdefs_c_class&>(kc_current_view_base);
	    {
		const alternative alt = this->alternative_1;
		const alternatives ra = this->alternatives_1;
		kc::unparse(alt, kc_printer, kc_current_view);
		kc::unparse(ra, kc_printer, kc_current_view);
	    }
	    break;
	}
	case view_gen_classdecls2_h_enum: {
	    view_gen_classdecls2_h_class& kc_current_view=static_cast<view_gen_classdecls2_h_class&>(kc_current_view_base);
	    if ((this->alternative_1->prod_sel() == sel_Alternative)) {
		const alternative alt = this->alternative_1;
		const ID oid = phylum_cast<const impl_alternative_Alternative*>(this->alternative_1)->ID_1;
		const alternatives ra = this->alternatives_1;
		kc::unparse(alt, kc_printer, kc_current_view);
		kc::unparse(alt, kc_printer, view_gen_nodetypes_h);
		ID pid = f_phylumofoperator(oid);
		if (f_ispredefinedphylum(pid)) {
		    f_phylumdeclofid(pid)->additional_members->unparse(kc_printer, view_gen_member_dcl_h);
		} 
		kc::unparse(alt->additional_members, kc_printer, view_gen_member_dcl_h);
		gl_operator = 0; 
		 if(!g_options.no_unparse) 
		{
		    { kc_printer(kc_t("\rprivate:\v\
\n	void do_unparse(printer_functor, uview);\n"), kc_current_view); }
		}
		{ kc_printer(kc_t("};\
\n"), kc_current_view); }
		kc::unparse(ra, kc_printer, kc_current_view);
	    } else
		    goto kc_unparsing_default;
	    break;
	}
	case view_gen_attributeOf_function_enum: {
	    view_gen_attributeOf_function_class& kc_current_view=static_cast<view_gen_attributeOf_function_class&>(kc_current_view_base);
	    if ((this->alternative_1->prod_sel() == sel_Alternative)) {
		const alternative a = this->alternative_1;
		const ID oid = phylum_cast<const impl_alternative_Alternative*>(this->alternative_1)->ID_1;
		const alternatives ra = this->alternatives_1;
		kc::unparse(ra, kc_printer, kc_current_view);
		int attrcount = gl_no_of_args;
		arguments attrs = gl_args;
		ac_identifier_list idents = gl_idents;
		a->additional_members->unparse(kc_printer, view_count_attrs);
		gl_no_of_args += attrcount; 
		gl_args = concat(gl_args, attrs); 
		gl_idents = concat(gl_idents, idents); 
		gl_operator=oid;
		if (gl_no_of_args) 
		{
		    { kc_printer(kc_t("case sel_"), kc_current_view); }
		    kc::unparse(oid, kc_printer, kc_current_view);
		    { kc_printer(kc_t(": switch(no) {\n"), kc_current_view); }
		    kc::unparse(gl_args, kc_printer, kc_current_view);
		    { kc_printer(kc_t("}\
\n	"), kc_current_view); }
		}
		gl_no_of_args=attrcount;
		gl_args=attrs;
		gl_idents=idents; 
			} else
		    goto kc_unparsing_default;
	    break;
	}
	case view_gen_create_function_enum: {
	    view_gen_create_function_class& kc_current_view=static_cast<view_gen_create_function_class&>(kc_current_view_base);
	    if ((this->alternative_1->prod_sel() == sel_Alternative)) {
		const alternative alt = this->alternative_1;
		const ID oid = phylum_cast<const impl_alternative_Alternative*>(this->alternative_1)->ID_1;
		const arguments args = phylum_cast<const impl_alternative_Alternative*>(this->alternative_1)->arguments_1;
		const alternatives ra = this->alternatives_1;
		{ kc_printer(kc_t("   \rcase sel_"), kc_current_view); }
		kc::unparse(oid, kc_printer, kc_current_view);
		{ kc_printer(kc_t(":\v\
\n	return "), kc_current_view); }
		kc::unparse(oid, kc_printer, kc_current_view);
		{ kc_printer(kc_t("("), kc_current_view); }
		kc::unparse(args, kc_printer, kc_current_view);
		{ kc_printer(kc_t(");\
\n"), kc_current_view); }
		kc::unparse(ra, kc_printer, kc_current_view);
	    } else
		    goto kc_unparsing_default;
	    break;
	}
	case view_gen_operatordefs_hash_c_enum: {
	    view_gen_operatordefs_hash_c_class& kc_current_view=static_cast<view_gen_operatordefs_hash_c_class&>(kc_current_view_base);
	    if ((this->alternative_1->prod_sel() == sel_Alternative)) {
		const alternative alt = this->alternative_1;
		const ID oid = phylum_cast<const impl_alternative_Alternative*>(this->alternative_1)->ID_1;
		const arguments args = phylum_cast<const impl_alternative_Alternative*>(this->alternative_1)->arguments_1;
		const alternatives ra = this->alternatives_1;
		kc::unparse(ra, kc_printer, kc_current_view);
		gl_isnotlist = f_listelementphylum(gl_phylum)->eq(f_emptyId());
		gl_operator = oid;
		gl_args=args; 
		kc::unparse(args, kc_printer, view_count_args);
		if(f_constructors_in_operatordecl(alt)) 
		{
		    kc::unparse(alt->additional_members, kc_printer, kc_current_view);
		}
		else {

		    fndeclarations _fd = Consfndeclarations(FnAcDeclaration(Nilac_declaration_specifiers(),
			    AcDeclarator(Nopointer(), AcNoRef(), AcQualifiedDeclProto(Nilac_class_qualifier_list(),
				    AcDirectDeclId(oid),
				    AcParList(Nilac_parameter_list()),
				    AcNoQualifier())),
			    Nilac_declaration_list(), AcNoBaseInit(), NilCtext(), Id(Str(mkcasestring(""))),
			    ConstructorFn()), Nilfndeclarations());
		    UNPARSE(_fd);
		    _fd->free(false);
		} 
		 gl_args=0;
		gl_operator = 0;
		gl_isnotlist = true;

	    } else
		    goto kc_unparsing_default;
	    break;
	}
	case view_gen_operatordefs_nonhash_c_enum: {
	    view_gen_operatordefs_nonhash_c_class& kc_current_view=static_cast<view_gen_operatordefs_nonhash_c_class&>(kc_current_view_base);
	    if ((this->alternative_1->prod_sel() == sel_Alternative)) {
		const alternative alt = this->alternative_1;
		const ID oid = phylum_cast<const impl_alternative_Alternative*>(this->alternative_1)->ID_1;
		const arguments args = phylum_cast<const impl_alternative_Alternative*>(this->alternative_1)->arguments_1;
		const alternatives ra = this->alternatives_1;
		kc::unparse(ra, kc_printer, kc_current_view);
		gl_isnotlist = f_listelementphylum(gl_phylum)->eq(f_emptyId());
		gl_operator = oid;
		gl_args=args; 
		kc::unparse(args, kc_printer, view_count_args);
		if(f_constructors_in_operatordecl(alt)) 
		{
		    kc::unparse(alt->additional_members, kc_printer, kc_current_view);
		}
		else {

		    fndeclarations _fd = Consfndeclarations(FnAcDeclaration(Nilac_declaration_specifiers(),
			    AcDeclarator(Nopointer(), AcNoRef(), AcQualifiedDeclProto(Nilac_class_qualifier_list(),
				    AcDirectDeclId(oid),
				    AcParList(Nilac_parameter_list()),
				    AcNoQualifier())),
			    Nilac_declaration_list(), AcNoBaseInit(), NilCtext(), Id(Str(mkcasestring(""))),
			    ConstructorFn()), Nilfndeclarations());
		    UNPARSE(_fd);
		    _fd->free(false);
		} 
		 gl_args=0;
		gl_operator = 0;
		gl_isnotlist = true;

	    } else
		    goto kc_unparsing_default;
	    break;
	}
	case view_gen_operatorcast_h_enum: {
	    view_gen_operatorcast_h_class& kc_current_view=static_cast<view_gen_operatorcast_h_class&>(kc_current_view_base);
	    if ((this->alternative_1->prod_sel() == sel_Alternative)) {
		const alternative alt = this->alternative_1;
		const ID oid = phylum_cast<const impl_alternative_Alternative*>(this->alternative_1)->ID_1;
		const arguments args = phylum_cast<const impl_alternative_Alternative*>(this->alternative_1)->arguments_1;
		const alternatives ra = this->alternatives_1;
		kc::unparse(ra, kc_printer, kc_current_view);
		if(f_constructors_in_operatordecl(alt)) 
		{
		    gl_args=args; 
		     v_report(NonFatal( NoFileLine(), Problem1S( "internal error: experimental operator_cast<>() unlikely to work with user-defined constructors" ))); 
		    kc::unparse(args, kc_printer, view_count_args);
		    kc::unparse(alt->additional_members, kc_printer, kc_current_view);
		    gl_args=0; 
		     }
		else 
		{
		    ID pid = f_phylumofoperator(oid); 
		    	{ kc_printer(kc_t("template <class "), kc_current_view); }
		    kc::unparse(oid, kc_printer, view_gen_fn_pointer_name);
		    { kc_printer(kc_t("*\b kc_f("), kc_current_view); }
		    kc::unparse(args, kc_printer, kc_current_view);
		    { kc_printer(kc_t(")>\
\n	 class "), kc_current_view); }
		    kc::unparse(oid, kc_printer, view_gen_fn_pointer_name);
		    { kc_printer(kc_t("*\
\n	 operator_cast("), kc_current_view); }
		    kc::unparse(pid, kc_printer, kc_current_view);
		    { kc_printer(kc_t(" kc_p)\
\n	 {\
\n	     if (kc_f!="), kc_current_view); }
		    kc::unparse(oid, kc_printer, kc_current_view);
		    { kc_printer(kc_t(" || kc_p->prod_sel()!=sel_"), kc_current_view); }
		    kc::unparse(oid, kc_printer, kc_current_view);
		    { kc_printer(kc_t(")\
\n		 throw std::bad_cast();\
\n	     return static_cast<class "), kc_current_view); }
		    kc::unparse(oid, kc_printer, view_gen_fn_pointer_name);
		    { kc_printer(kc_t("*>(kc_p);\
\n	 }\n\n"), kc_current_view); }
		}
	    } else
		    goto kc_unparsing_default;
	    break;
	}
	case view_gen_operatordecls_h_enum: {
	    view_gen_operatordecls_h_class& kc_current_view=static_cast<view_gen_operatordecls_h_class&>(kc_current_view_base);
	    if ((this->alternative_1->prod_sel() == sel_Alternative)) {
		const alternative alt = this->alternative_1;
		const ID oid = phylum_cast<const impl_alternative_Alternative*>(this->alternative_1)->ID_1;
		const arguments args = phylum_cast<const impl_alternative_Alternative*>(this->alternative_1)->arguments_1;
		const alternatives ra = this->alternatives_1;
		kc::unparse(ra, kc_printer, kc_current_view);
		if(f_constructors_in_operatordecl(alt)) 
		{
		    gl_args=args; 
		    kc::unparse(args, kc_printer, view_count_args);
		    kc::unparse(alt->additional_members, kc_printer, kc_current_view);
		    gl_args=0; 
		     }
		else 
		{
		    { kc_printer(kc_t("class "), kc_current_view); }
		    kc::unparse(oid, kc_printer, view_gen_fn_pointer_name);
		    { kc_printer(kc_t("*\b "), kc_current_view); }
		    kc::unparse(oid, kc_printer, kc_current_view);
		    { kc_printer(kc_t(" ("), kc_current_view); }
		    kc::unparse(args, kc_printer, kc_current_view);
		    { kc_printer(kc_t(");\n"), kc_current_view); }
		}
	    } else
		    goto kc_unparsing_default;
	    break;
	}
	case view_gen_operatormap_attributes_enum: {
	    view_gen_operatormap_attributes_class& kc_current_view=static_cast<view_gen_operatormap_attributes_class&>(kc_current_view_base);
	    if ((this->alternative_1->prod_sel() == sel_Alternative)) {
		const alternative a = this->alternative_1;
		const ID oid = phylum_cast<const impl_alternative_Alternative*>(this->alternative_1)->ID_1;
		const alternatives ra = this->alternatives_1;
		kc::unparse(ra, kc_printer, kc_current_view);
		int attrcount = gl_no_of_args;
		arguments attrs = gl_args;
		ac_identifier_list idents = gl_idents;
		a->additional_members->unparse(kc_printer, view_count_attrs);
		gl_no_of_args += attrcount; 
		gl_args = concat(gl_args, attrs); 
		gl_idents = concat(gl_idents, idents);  
		if (gl_no_of_args) 
		{
		    { kc_printer(kc_t("static enum_phyla kc_attrs_"), kc_current_view); }
		    kc::unparse(oid, kc_printer, kc_current_view);
		    { kc_printer(kc_t("[] = { "), kc_current_view); }
		    kc::unparse(gl_args, kc_printer, view_gen_operatormap_subphyla);
		    { kc_printer(kc_t(" };\
\n	"), kc_current_view); }
		}
		gl_no_of_args=attrcount;
		gl_args=attrs;
		gl_idents=idents; 
			} else
		    goto kc_unparsing_default;
	    break;
	}
	case view_gen_operatormap_subphyla_enum: {
	    view_gen_operatormap_subphyla_class& kc_current_view=static_cast<view_gen_operatormap_subphyla_class&>(kc_current_view_base);
	    if ((this->alternative_1->prod_sel() == sel_Alternative)) {
		const ID oid = phylum_cast<const impl_alternative_Alternative*>(this->alternative_1)->ID_1;
		const arguments args = phylum_cast<const impl_alternative_Alternative*>(this->alternative_1)->arguments_1;
		const alternatives ra = this->alternatives_1;
		kc::unparse(ra, kc_printer, kc_current_view);
		kc::unparse(args, kc_printer, view_count_args);
		if (gl_no_of_args) 
		{
		    { kc_printer(kc_t("static enum_phyla kc_subphyla_"), kc_current_view); }
		    kc::unparse(oid, kc_printer, kc_current_view);
		    { kc_printer(kc_t("[] = { "), kc_current_view); }
		    kc::unparse(args, kc_printer, kc_current_view);
		    { kc_printer(kc_t(" };\
\n	"), kc_current_view); }
		}
	    } else
		    goto kc_unparsing_default;
	    break;
	}
	case view_gen_operatormap_c_enum: {
	    view_gen_operatormap_c_class& kc_current_view=static_cast<view_gen_operatormap_c_class&>(kc_current_view_base);
	    if ((this->alternative_1->prod_sel() == sel_Alternative)) {
		const alternative alt = this->alternative_1;
		const ID oid = phylum_cast<const impl_alternative_Alternative*>(this->alternative_1)->ID_1;
		const arguments args = phylum_cast<const impl_alternative_Alternative*>(this->alternative_1)->arguments_1;
		const alternatives ra = this->alternatives_1;
		kc::unparse(ra, kc_printer, kc_current_view);
		kc::unparse(args, kc_printer, view_count_args);
		{ kc_printer(kc_t("    { \""), kc_current_view); }
		kc::unparse(oid, kc_printer, kc_current_view);
		{ kc_printer(kc_t("\", "), kc_current_view); }
		kc::unparse(gl_no_of_args, kc_printer, kc_current_view);
		{ kc_printer(kc_t(", "), kc_current_view); }
		if (gl_atomicity) 
		{
		    { kc_printer(kc_t("true"), kc_current_view); }
		}
		else 
		{
		    { kc_printer(kc_t("false"), kc_current_view); }
		}
		{ kc_printer(kc_t(", phylum_"), kc_current_view); }
		kc::unparse(gl_phylum, kc_printer, kc_current_view);
		{ kc_printer(kc_t(", "), kc_current_view); }
		if (gl_no_of_args>0) 
		{
		    { kc_printer(kc_t("kc_subphyla_"), kc_current_view); }
		    kc::unparse(oid, kc_printer, kc_current_view);
		    { kc_printer(kc_t(", "), kc_current_view); }
		}
		else 
		{
		    { kc_printer(kc_t("0, "), kc_current_view); }
		}
		The_abstract_phylum_decl->additional_members->unparse(kc_printer, view_count_attrs);
		int attrcount = gl_no_of_args;
		f_phylumdeclofid(f_phylumofoperator(oid))->additional_members->unparse(kc_printer, view_count_attrs);
		attrcount += gl_no_of_args;
		alt->additional_members->unparse(kc_printer, view_count_attrs);
		gl_no_of_args += attrcount; 
		kc::unparse(gl_no_of_args, kc_printer, kc_current_view);
		{ kc_printer(kc_t(", "), kc_current_view); }
		if (gl_no_of_args>0) 
		{
		    { kc_printer(kc_t("kc_attrs_"), kc_current_view); }
		    kc::unparse(oid, kc_printer, kc_current_view);
		}
		else 
		{
		    { kc_printer(kc_t("0"), kc_current_view); }
		}
		{ kc_printer(kc_t(", sizeof("), kc_current_view); }
		kc::unparse(oid, kc_printer, view_class_of_op);
		{ kc_printer(kc_t(") },\n"), kc_current_view); }
	    } else
		    goto kc_unparsing_default;
	    break;
	}
	case view_gen_phylummap_c_enum: {
	    view_gen_phylummap_c_class& kc_current_view=static_cast<view_gen_phylummap_c_class&>(kc_current_view_base);
	    if ((this->alternative_1->prod_sel() == sel_Alternative) && (this->alternatives_1->prod_sel() == sel_Nilalternatives)) {
		const ID oid = phylum_cast<const impl_alternative_Alternative*>(this->alternative_1)->ID_1;
		kc::unparse(oid, kc_printer, kc_current_view);
	    } else
	    {
		const alternatives ra = this->alternatives_1;
		kc::unparse(ra, kc_printer, kc_current_view);
	    }
	    break;
	}
	case view_gen_enumoperators_h_enum: {
	    view_gen_enumoperators_h_class& kc_current_view=static_cast<view_gen_enumoperators_h_class&>(kc_current_view_base);
	    if ((this->alternatives_1->prod_sel() == sel_Nilalternatives)) {
		const alternative a = this->alternative_1;
		kc::unparse(a, kc_printer, kc_current_view);
	    } else
	    {
		const alternative a = this->alternative_1;
		const alternatives as = this->alternatives_1;
		kc::unparse(as, kc_printer, kc_current_view);
		kc::unparse(a, kc_printer, kc_current_view);
	    }
	    break;
	}
	case view_gen_deprecated_enum: {
	    view_gen_deprecated_class& kc_current_view=static_cast<view_gen_deprecated_class&>(kc_current_view_base);
	    {
		const alternative a = this->alternative_1;
		const alternatives as = this->alternatives_1;
		kc::unparse(as, kc_printer, kc_current_view);
		kc::unparse(a, kc_printer, kc_current_view);
	    }
	    break;
	}
	case view_check_uniq1_enum: {
	    view_check_uniq1_class& kc_current_view=static_cast<view_check_uniq1_class&>(kc_current_view_base);
	    {
		const alternative a = this->alternative_1;
		const alternatives ralts = this->alternatives_1;
		kc::unparse(ralts, kc_printer, kc_current_view);
		kc::unparse(a, kc_printer, kc_current_view);
	    }
	    break;
	}
	case view_check_count1_enum: {
	    view_check_count1_class& kc_current_view=static_cast<view_check_count1_class&>(kc_current_view_base);
	    if ((this->alternative_1->prod_sel() == sel_Alternative)) {
		const alternative alt = this->alternative_1;
		const ID id = phylum_cast<const impl_alternative_Alternative*>(this->alternative_1)->ID_1;
		const arguments args = phylum_cast<const impl_alternative_Alternative*>(this->alternative_1)->arguments_1;
		const alternatives ralts = this->alternatives_1;
		kc::unparse(ralts, kc_printer, kc_current_view);
		kc::unparse(args, kc_printer, kc_current_view);
		v_resetcount();

	    } else
		    goto kc_unparsing_default;
	    break;
	}

	default:
	kc_unparsing_default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    { /* Alternative( *, args ) -> [view_gen_unparsedefs_default_c: */
		for (alternatives iterator_ = this; iterator_->alternatives_1 != 0; iterator_ = iterator_->alternatives_1)
		    iterator_->alternative_1->unparse(kc_printer, kc_current_view);
	    }
	    break;
	}
    }
}

void
impl_alternatives::nil_do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case view_gen_classdefs_c_enum: {
	    view_gen_classdefs_c_class& kc_current_view=static_cast<view_gen_classdefs_c_class&>(kc_current_view_base);
	    {
	    }
	    break;
	}
	case view_gen_classdecls2_h_enum: {
	    view_gen_classdecls2_h_class& kc_current_view=static_cast<view_gen_classdecls2_h_class&>(kc_current_view_base);
	    {
	    }
	    break;
	}
	case view_gen_attributeOf_function_enum: {
	    view_gen_attributeOf_function_class& kc_current_view=static_cast<view_gen_attributeOf_function_class&>(kc_current_view_base);
	    {
	    }
	    break;
	}
	case view_gen_operatorcast_h_enum: {
	    view_gen_operatorcast_h_class& kc_current_view=static_cast<view_gen_operatorcast_h_class&>(kc_current_view_base);
	    {
	    }
	    break;
	}
	case view_gen_operatordecls_h_enum: {
	    view_gen_operatordecls_h_class& kc_current_view=static_cast<view_gen_operatordecls_h_class&>(kc_current_view_base);
	    {
	    }
	    break;
	}
	case view_gen_operatormap_attributes_enum: {
	    view_gen_operatormap_attributes_class& kc_current_view=static_cast<view_gen_operatormap_attributes_class&>(kc_current_view_base);
	    {
	    }
	    break;
	}
	case view_gen_operatormap_subphyla_enum: {
	    view_gen_operatormap_subphyla_class& kc_current_view=static_cast<view_gen_operatormap_subphyla_class&>(kc_current_view_base);
	    {
	    }
	    break;
	}
	case view_gen_operatormap_c_enum: {
	    view_gen_operatormap_c_class& kc_current_view=static_cast<view_gen_operatormap_c_class&>(kc_current_view_base);
	    {
	    }
	    break;
	}
	case view_gen_phylummap_c_enum: {
	    view_gen_phylummap_c_class& kc_current_view=static_cast<view_gen_phylummap_c_class&>(kc_current_view_base);
	    {
	    }
	    break;
	}
	case view_gen_deprecated_enum: {
	    view_gen_deprecated_class& kc_current_view=static_cast<view_gen_deprecated_class&>(kc_current_view_base);
	    {
	    }
	    break;
	}
	case view_check_uniq1_enum: {
	    view_check_uniq1_class& kc_current_view=static_cast<view_check_uniq1_class&>(kc_current_view_base);
	    {
	    }
	    break;
	}
	case view_check_count1_enum: {
	    view_check_count1_class& kc_current_view=static_cast<view_check_count1_class&>(kc_current_view_base);
	    {
	    }
	    break;
	}

	default:
	kc_unparsing_default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    { /* Alternative( *, args ) -> [view_gen_unparsedefs_default_c: */
	    }
	    break;
	}
    }
}


void
impl_alternative_Alternative::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case view_gen_classdefs_c_enum: {
	    view_gen_classdefs_c_class& kc_current_view=static_cast<view_gen_classdefs_c_class&>(kc_current_view_base);
	    {
		const alternative alt = this/**/;
		const ID oid = this->ID_1;
		const arguments args = this->arguments_1;
		gl_operator=oid;
		enum_operators kc_i = f_selofoperator(gl_operator);
		bool priorAssignments=false;
		if(kc_i!=sel_NoCaseStr && kc_i!=sel__Str) 
		{
		    if(!f_constructors_in_operatordecl(alt)) 
		    {
			kc::unparse(oid, kc_printer, view_class_of_op);
			{ kc_printer(kc_t("::"), kc_current_view); }
			kc::unparse(oid, kc_printer, view_class_of_op);
			{ kc_printer(kc_t("("), kc_current_view); }
			if (f_ispredefinedphylum(gl_phylum)) 
			{
			    kc::unparse(args, kc_printer, view_gen_fnarg_and_decls_predef);
			}
			else 
			{
			    kc::unparse(args, kc_printer, view_gen_fnarg_and_decls);
			}
			{ kc_printer(kc_t(")\n\v"), kc_current_view); }
			if (f_ispredefinedphylum(gl_phylum)) {
			    PRINT(priorAssignments ? ", " : ": "); priorAssignments=true; 
			    kc::unparse(args, kc_printer, view_gen_assignments_predef_ini);
			} else if (args->length()>0) {
			    PRINT(priorAssignments ? ", " : ": "); priorAssignments=true; 
			    kc::unparse(args, kc_printer, view_gen_assignment_inis);
			} 
			kc::unparse(additional_members, kc_printer, view_count_nonstaticmembers);
			if (gl_no_of_args) 
			{
			    PRINT(priorAssignments ? ", " : ": "); 
			    kc::unparse(gl_members, kc_printer, view_gen_user_assignment_inis);
			}
			{ kc_printer(kc_t(" { }\r\n"), kc_current_view); }
		    }
		}
	    }
	    break;
	}
	case view_gen_classdecls2_h_enum: {
	    view_gen_classdecls2_h_class& kc_current_view=static_cast<view_gen_classdecls2_h_class&>(kc_current_view_base);
	    {
		const alternative alt = this/**/;
		const ID oid = this->ID_1;
		const arguments args = this->arguments_1;
		ID id = f_phylumofoperator(oid);
		gl_operator = oid; 
			{ kc_printer(kc_t("class "), kc_current_view); }
		if(g_options.dllexports!="") {
		    PRINT(g_options.dllexports.c_str());
		    PRINT(" ");
		} 
			{ kc_printer(kc_t("impl_"), kc_current_view); }
		kc::unparse(id, kc_printer, kc_current_view);
		{ kc_printer(kc_t("_"), kc_current_view); }
		kc::unparse(oid, kc_printer, kc_current_view);
		{ kc_printer(kc_t(":"), kc_current_view); }

		{
		    baseclass_list kc_selvar_0_1 = phylum_cast<baseclass_list>(alt->base_classes);
		    if ((kc_selvar_0_1->prod_sel() == sel_Consbaseclass_list)) {

			UNPARSE(alt->base_classes);

		    } else
		    {

			if (f_ispredefinedphylum(id)) {
			    PRINT("public impl_abstract_phylum");
			} else {
			    PRINT("public impl_"); UNPARSE(id);
			}

		    }
		}

		{ kc_printer(kc_t("{\
\n\rpublic:\v\
\n    enum_operators prod_sel() const\
\n    \v{ return sel_"), kc_current_view); }
		kc::unparse(oid, kc_printer, kc_current_view);
		{ kc_printer(kc_t("; }\r\
\n"), kc_current_view); }
		if (f_ispredefinedphylum(id)) 
		{
		    { kc_printer(kc_t("   static const enum_phyla phylum_sel_;\n"), kc_current_view); }
		}
		enum_operators kc_i = f_selofoperator(gl_operator);
		if(kc_i!=sel_NoCaseStr && kc_i!=sel__Str) 
		{
		    if(!f_constructors_in_operatordecl(alt)) 
		    {
			{ kc_printer(kc_t("explicit impl_"), kc_current_view); }
			kc::unparse(id, kc_printer, kc_current_view);
			{ kc_printer(kc_t("_"), kc_current_view); }
			kc::unparse(oid, kc_printer, kc_current_view);
			{ kc_printer(kc_t("("), kc_current_view); }
			if (f_ispredefinedphylum(id)) 
			{
			    kc::unparse(args, kc_printer, view_gen_fnarg_and_decls_predef);
			}
			else 
			{
			    kc::unparse(args, kc_printer, view_gen_operatordecls_h);
			}
			{ kc_printer(kc_t(");\
\n	"), kc_current_view); }
		    }
		}
		else 
		{
		    { kc_printer(kc_t("\rprivate:\v\
\n	explicit impl_"), kc_current_view); }
		    kc::unparse(id, kc_printer, kc_current_view);
		    { kc_printer(kc_t("_"), kc_current_view); }
		    kc::unparse(oid, kc_printer, kc_current_view);
		    { kc_printer(kc_t("(const kc_char_t*);\
\n	void make_own(int length);\
\n	friend "), kc_current_view); }
		    kc::unparse(id, kc_printer, kc_current_view);
		    { kc_printer(kc_t(" mk"), kc_current_view); }
		    kc::unparse(id, kc_printer, kc_current_view);
		    { kc_printer(kc_t("(const kc_char_t*, int);\
\n\rpublic:\v\
\n	~impl_"), kc_current_view); }
		    kc::unparse(id, kc_printer, kc_current_view);
		    { kc_printer(kc_t("_"), kc_current_view); }
		    kc::unparse(oid, kc_printer, kc_current_view);
		    { kc_printer(kc_t("() {\
\n	#if defined (_MSC_VER) && _MSC_VER<1300\
\n	    delete [] (kc_char_t*)name;\
\n	#else\
\n	    delete [] name;\
\n	#endif\
\n	}\
\n"), kc_current_view); }
		}
		if(args->length()!=0) 
		{
		    { kc_printer(kc_t("       abstract_phylum subphylum(int) const;\
\n	void set_subphylum(int, abstract_phylum);\
\n"), kc_current_view); }
		}
		if (!g_options.no_printdot && f_ispredefinedphylum(id)) 
		{
		    { kc_printer(kc_t("void fprintdot( FILE*, const char*, const char*, const char*, bool, bool, bool ) const;\n"), kc_current_view); }
		}
		if (!g_options.no_rewrite) 
		{
		    if (!g_options.rw_loop) 
		    {
			if (!f_ispredefinedphylum(id)) {
			    if(!f_rewrite_in_operatordecl(alt)) 
			    covariant_choice(id, " rewrite( rview );", "abstract_phylum rewrite( rview );",
				kc_printer, kc_current_view);
			    else
			    covariant_choice(id, " do_rewrite( rview );", "abstract_phylum do_rewrite( rview );",
				kc_printer, kc_current_view);
			}
			else 
			{
			    covariant_choice(id, " rewrite( rview )", "abstract_phylum rewrite( rview )",
				kc_printer, kc_current_view); 
			    	{ kc_printer(kc_t("\n\v{ return this; }\r"), kc_current_view); }
			}
		    }
		    else 
		    {
			if (!f_ispredefinedphylum(id)) 
			{
			    { kc_printer(kc_t("abstract_phylum do_rewrite( rview );"), kc_current_view); }
			}
		    }
		}
		{ kc_printer(kc_t("\n"), kc_current_view); }
		if (g_options.smart_pointer) 
		{
		    if(f_ispredefinedphylum(id)) 
		    {
			{ kc_printer(kc_t("abstract_phylum_ref* new_phylum_ref() {\
\n        return new phylum_ref<impl_"), kc_current_view); }
			kc::unparse(id, kc_printer, kc_current_view);
			{ kc_printer(kc_t("_"), kc_current_view); }
			kc::unparse(oid, kc_printer, kc_current_view);
			{ kc_printer(kc_t(">(this);\
\n    }\
\n    impl_"), kc_current_view); }
			kc::unparse(id, kc_printer, kc_current_view);
			{ kc_printer(kc_t("& operator=(const impl_"), kc_current_view); }
			kc::unparse(id, kc_printer, kc_current_view);
			{ kc_printer(kc_t("& p) {\
\n	phylum_ref<impl_"), kc_current_view); }
			kc::unparse(id, kc_printer, kc_current_view);
			{ kc_printer(kc_t(">* my_ref=static_cast<phylum_ref<impl_"), kc_current_view); }
			kc::unparse(id, kc_printer, kc_current_view);
			{ kc_printer(kc_t(">*>(get_ref());\
\n	"), kc_current_view); }
			kc::unparse(id, kc_printer, kc_current_view);
			{ kc_printer(kc_t(" self=this;\
\n	if(my_ref) {\
\n	    abstract_phylum_ref* ref=p.get_ref();\
\n	    self=const_cast<"), kc_current_view); }
			kc::unparse(id, kc_printer, kc_current_view);
			{ kc_printer(kc_t(">(&p);\
\n	    if(ref)\
\n		self=phylum_cast<"), kc_current_view); }
			kc::unparse(id, kc_printer, kc_current_view);
			{ kc_printer(kc_t(">(self->copy(true));\
\n	    my_ref->set_phylum(self);\
\n	}\
\n	return *self;\
\n    }\
\n"), kc_current_view); }
			kc::unparse(id, kc_printer, view_class_of_phy);
			{ kc_printer(kc_t("& operator=(const phylum_ref<"), kc_current_view); }
			kc::unparse(id, kc_printer, view_class_of_phy);
			{ kc_printer(kc_t(">& r) {\
\n	phylum_ref<"), kc_current_view); }
			kc::unparse(id, kc_printer, view_class_of_phy);
			{ kc_printer(kc_t(">* my_ref=static_cast<phylum_ref<"), kc_current_view); }
			kc::unparse(id, kc_printer, view_class_of_phy);
			{ kc_printer(kc_t(">*>(get_ref());\
\n	"), kc_current_view); }
			kc::unparse(id, kc_printer, kc_current_view);
			{ kc_printer(kc_t(" self=this;\
\n	if(my_ref) {\
\n	    self=phylum_cast<"), kc_current_view); }
			kc::unparse(id, kc_printer, kc_current_view);
			{ kc_printer(kc_t(">(r.get_phylum()?r.get_phylum()->copy(true):0);\
\n	    my_ref->set_phylum(self);\
\n	}\
\n	return *self;\
\n    }\
\n    "), kc_current_view); }
		    }
		    else 
		    {
			kc::unparse(id, kc_printer, view_class_of_phy);
			{ kc_printer(kc_t("& operator=(const impl_"), kc_current_view); }
			kc::unparse(id, kc_printer, kc_current_view);
			{ kc_printer(kc_t("& p) {\
\n	return "), kc_current_view); }
			kc::unparse(id, kc_printer, view_class_of_phy);
			{ kc_printer(kc_t("::operator=(p);\
\n    }\
\n    impl_"), kc_current_view); }
			kc::unparse(id, kc_printer, kc_current_view);
			{ kc_printer(kc_t("& operator=(const phylum_ref<impl_"), kc_current_view); }
			kc::unparse(id, kc_printer, kc_current_view);
			{ kc_printer(kc_t(">& r) {\
\n	return "), kc_current_view); }
			kc::unparse(id, kc_printer, view_class_of_phy);
			{ kc_printer(kc_t("::operator=(r);\
\n    }\
\n    "), kc_current_view); }
		    }
		    kc::unparse(oid, kc_printer, view_class_of_op);
		    { kc_printer(kc_t("* return_ptr() { if(get_ref()) get_ref()->lock(); return this; }\n"), kc_current_view); }
		}
	    }
	    break;
	}
	case view_gen_unparsedefs_default_c_enum: {
	    view_gen_unparsedefs_default_c_class& kc_current_view=static_cast<view_gen_unparsedefs_default_c_class&>(kc_current_view_base);
	    {
		const arguments args = this->arguments_1;
		{ kc_printer(kc_t("	{\
\n"), kc_current_view); }
		kc::unparse(args, kc_printer, kc_current_view);
		{ kc_printer(kc_t("	}\
\n"), kc_current_view); }
	    }
	    break;
	}
	case view_gen_unparsedefs_c_enum: {
	    view_gen_unparsedefs_c_class& kc_current_view=static_cast<view_gen_unparsedefs_c_class&>(kc_current_view_base);
	    {
		const ID oid = this->ID_1;
		unparseviewsinfo a_unparseviewsinfo = f_unparseviewsinfo_of_alternative( this, Theuviewnames );
		gl_phylum = f_phylumofoperator(oid);
		gl_operator = oid;
		gl_unparse_goto_used = false; 
		kc::unparse(g_emptystring, kc_printer, view_printer_outputfileline);
		{ kc_printer(kc_t("void\
\nimpl_"), kc_current_view); }
		kc::unparse(gl_phylum, kc_printer, kc_current_view);
		{ kc_printer(kc_t("_"), kc_current_view); }
		kc::unparse(oid, kc_printer, kc_current_view);
		{ kc_printer(kc_t("::do_unparse(printer_functor kc_printer, uview kc_current_view_base)\
\n{\
\n    switch(kc_current_view_base) {\
\n"), kc_current_view); }
		kc::unparse(a_unparseviewsinfo, kc_printer, view_gen_unparsedefs_c);
		{ kc_printer(kc_t("	}\
\n}\
\n\
\n"), kc_current_view); }
		freespineandelements(a_unparseviewsinfo);
		gl_phylum = 0;

	    }
	    break;
	}
	case view_gen_rewritedefs_body_c_enum: {
	    view_gen_rewritedefs_body_c_class& kc_current_view=static_cast<view_gen_rewritedefs_body_c_class&>(kc_current_view_base);
	    {
		const alternative alt = this/**/;
		const ID oid = this->ID_1;
		const arguments args = this->arguments_1;
		rewriteviewsinfo a_rewriteviewsinfo = f_rewriteviewsinfo_of_alternative( alt, Therviewnames );

		gl_operator = oid;
		gl_alternative = alt;
		gl_rewrite_goto_used = false;
		args->unparse(kc_printer, view_gen_rewritedefs_rewritearg_c);


		bool empty=true;
		{
		    rewriteviewsinfo kc_fe_selvar_1 =  a_rewriteviewsinfo;

		    while(
			    kc_fe_selvar_1->prod_sel() == sel_Consrewriteviewsinfo
			) {
			rewriteviewinfo kc_selvar_0_1 = kc_fe_selvar_1->rewriteviewinfo_1;
			{
			    {
				{
				    const rewriteviewinfo rvi = kc_selvar_0_1;
				    {
					rewriteviewinfo kc_selvar_1_1 = phylum_cast<rewriteviewinfo>(rvi);
					if ((kc_selvar_1_1->prod_sel() == sel_Rewriteviewinfo) && (phylum_cast<const impl_rewriteviewinfo_Rewriteviewinfo*>(kc_selvar_1_1)->rewriterulesinfo_1->prod_sel() == sel_Nilrewriterulesinfo)) {

					} else
					{
					    empty=false; 
					}
				    }

				}
			    }

			}
			kc_fe_selvar_1 = kc_fe_selvar_1->rewriteviewsinfo_1;

		    }
		}
		if(!empty) {
		    PRINT("    switch(kc_current_view_base) {\n");
		    a_rewriteviewsinfo->unparse(kc_printer, view_gen_rewritedefs_c);
		    PRINT("    }\n");
		}

		kc::unparse(args, kc_printer, view_gen_rewritedefs_testarg_c);
		freespineandelements(a_rewriteviewsinfo);
		gl_operator = 0;
		gl_alternative = 0; 
	    }
	    break;
	}
	case view_gen_rewritedefs_other_c_enum: {
	    view_gen_rewritedefs_other_c_class& kc_current_view=static_cast<view_gen_rewritedefs_other_c_class&>(kc_current_view_base);
	    {
		const ID id = this->ID_1;
		const arguments args = this->arguments_1;
		if (! gl_rewrite_rewriteinfo->eq( Nilrewriterulesinfo())) 
		{
		    gl_args=args; 
		    kc::unparse(gl_rewrite_rewriteinfo, kc_printer, kc_current_view);
		    gl_args = 0; 
		     }
	    }
	    break;
	}
	case view_gen_rewritedefs_default_c_enum: {
	    view_gen_rewritedefs_default_c_class& kc_current_view=static_cast<view_gen_rewritedefs_default_c_class&>(kc_current_view_base);
	    {
		const ID id = this->ID_1;
		const arguments args = this->arguments_1;
		gl_args=args; 
		kc::unparse(gl_rewrite_rewriteinfo, kc_printer, kc_current_view);
		gl_args = 0; 
	    }
	    break;
	}
	case view_gen_rewritedefs_c_enum: {
	    view_gen_rewritedefs_c_class& kc_current_view=static_cast<view_gen_rewritedefs_c_class&>(kc_current_view_base);
	    {
		const alternative alt = this/**/;
		const ID oid = this->ID_1;
		const arguments args = this->arguments_1;
		gl_phylum = f_phylumofoperator(oid); 
		 if(!g_options.rw_loop) 
		{
		    covariant_choice(gl_phylum, "", "abstract_phylum", kc_printer, kc_current_view); 
		     }
		else 
		{
		    { kc_printer(kc_t("abstract_phylum"), kc_current_view); }
		}
		{ kc_printer(kc_t(" impl_"), kc_current_view); }
		kc::unparse(gl_phylum, kc_printer, kc_current_view);
		{ kc_printer(kc_t("_"), kc_current_view); }
		kc::unparse(oid, kc_printer, kc_current_view);
		{ kc_printer(kc_t("::"), kc_current_view); }
		if(f_rewrite_in_operatordecl(alt) || g_options.rw_loop) 
		{
		    { kc_printer(kc_t("do_"), kc_current_view); }
		}
		{ kc_printer(kc_t("rewrite(rview kc_current_view_base)\
\n{\
\n"), kc_current_view); }
		kc::unparse(this, kc_printer, view_gen_rewritedefs_body_c);
		{ kc_printer(kc_t("\
\n}\
\n"), kc_current_view); }
		gl_phylum = 0; 
	    }
	    break;
	}
	case view_gen_listdecls_h_enum: {
	    view_gen_listdecls_h_class& kc_current_view=static_cast<view_gen_listdecls_h_class&>(kc_current_view_base);
	    {
		const ID oid = this->ID_1;
		ID id = f_phylumofoperator(oid);
		ID el = f_listelementphylum(id);

		if (!el->eq(f_emptyId())) { 
		    	{ kc_printer(kc_t("// TODO: Is this code ever generated?\n"), kc_current_view); }
		    kc::unparse(id, kc_printer, kc_current_view);
		    { kc_printer(kc_t(" map("), kc_current_view); }
		    kc::unparse(el, kc_printer, kc_current_view);
		    { kc_printer(kc_t(" (*)("), kc_current_view); }
		    kc::unparse(el, kc_printer, kc_current_view);
		    { kc_printer(kc_t("));\n"), kc_current_view); }
		    kc::unparse(id, kc_printer, kc_current_view);
		    { kc_printer(kc_t(" filter( bool (*)("), kc_current_view); }
		    kc::unparse(el, kc_printer, kc_current_view);
		    { kc_printer(kc_t("));\n"), kc_current_view); }
		    kc::unparse(id, kc_printer, kc_current_view);
		    { kc_printer(kc_t(" merge( "), kc_current_view); }
		    kc::unparse(id, kc_printer, kc_current_view);
		    { kc_printer(kc_t(", "), kc_current_view); }
		    kc::unparse(el, kc_printer, kc_current_view);
		    { kc_printer(kc_t(" (*)("), kc_current_view); }
		    kc::unparse(el, kc_printer, kc_current_view);
		    { kc_printer(kc_t(", "), kc_current_view); }
		    kc::unparse(el, kc_printer, kc_current_view);
		    { kc_printer(kc_t("));\n"), kc_current_view); }
		    kc::unparse(el, kc_printer, kc_current_view);
		    { kc_printer(kc_t(" reduce( "), kc_current_view); }
		    kc::unparse(id, kc_printer, kc_current_view);
		    { kc_printer(kc_t(" neutral, "), kc_current_view); }
		    kc::unparse(el, kc_printer, kc_current_view);
		    { kc_printer(kc_t(" (*)("), kc_current_view); }
		    kc::unparse(el, kc_printer, kc_current_view);
		    { kc_printer(kc_t(", "), kc_current_view); }
		    kc::unparse(el, kc_printer, kc_current_view);
		    { kc_printer(kc_t("));\n"), kc_current_view); }
		} 
	    }
	    break;
	}
	case view_gen_nodetypes_h_enum: {
	    view_gen_nodetypes_h_class& kc_current_view=static_cast<view_gen_nodetypes_h_class&>(kc_current_view_base);
	    if ((this->arguments_1->prod_sel() == sel_Nilarguments)) {
		const ID oid = this->ID_1;
		if (f_ispredefinedphylum(f_phylumofoperator(oid))) {
		    enum_operators kc_i = f_selofoperator(oid); 
		    	{ kc_printer(kc_t("    "), kc_current_view); }
		    PRINT(preDefTypeAndName[kc_i][0]); 
		    	{ kc_printer(kc_t(" "), kc_current_view); }
		    PRINT(preDefTypeAndName[kc_i][1]); 
		    	{ kc_printer(kc_t(";\
\n"), kc_current_view); }
		} else 
		{
		}
	    } else
	    {
		const ID oid = this->ID_1;
		const arguments args = this->arguments_1;
		kc::unparse(args, kc_printer, kc_current_view);
	    }
	    break;
	}
	case view_gen_enumoperators_h_enum: {
	    view_gen_enumoperators_h_class& kc_current_view=static_cast<view_gen_enumoperators_h_class&>(kc_current_view_base);
	    {
		const ID id = this->ID_1;
		{ kc_printer(kc_t("    sel_"), kc_current_view); }
		kc::unparse(id, kc_printer, kc_current_view);
		{ kc_printer(kc_t(" = "), kc_current_view); }
		kc::unparse(g_no_of_operators, kc_printer, kc_current_view);
		{ kc_printer(kc_t(",\
\n"), kc_current_view); }
		g_no_of_operators++; 
	    }
	    break;
	}
	case view_gen_deprecated_enum: {
	    view_gen_deprecated_class& kc_current_view=static_cast<view_gen_deprecated_class&>(kc_current_view_base);
	    {
		const ID id = this->ID_1;
		{ kc_printer(kc_t("#define kc_tag_"), kc_current_view); }
		kc::unparse(gl_phylum, kc_printer, kc_current_view);
		{ kc_printer(kc_t("_"), kc_current_view); }
		kc::unparse(id, kc_printer, kc_current_view);
		{ kc_printer(kc_t(" impl_"), kc_current_view); }
		kc::unparse(gl_phylum, kc_printer, kc_current_view);
		{ kc_printer(kc_t("_"), kc_current_view); }
		kc::unparse(id, kc_printer, kc_current_view);
		{ kc_printer(kc_t("\
\n"), kc_current_view); }
	    }
	    break;
	}
	case view_check_uniq1_enum: {
	    view_check_uniq1_class& kc_current_view=static_cast<view_check_uniq1_class&>(kc_current_view_base);
	    {
		const arguments args = this->arguments_1;
		kc::unparse(args, kc_printer, kc_current_view);
	    }
	    break;
	}
	case view_gen_initializephyla_c_enum: {
	    view_gen_initializephyla_c_class& kc_current_view=static_cast<view_gen_initializephyla_c_class&>(kc_current_view_base);
	    {
		const ID id = this->ID_1;
		kc::unparse(additional_members, kc_printer, view_count_attrs);
		if (gl_no_of_args) 
		{
		    { kc_printer(kc_t("void kc_initialize_"), kc_current_view); }
		    kc::unparse(id, kc_printer, kc_current_view);
		    { kc_printer(kc_t("()\
\n	    {\n"), kc_current_view); }
		    { kc_printer(kc_t("}\n"), kc_current_view); }
		}
	    }
	    break;
	}

	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    { /* Alternative( *, args ) -> [view_gen_unparsedefs_default_c: */
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}

void
impl_arguments::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    if(is_nil())
	nil_do_unparse(kc_printer, kc_current_view_base);
    else
	switch(kc_current_view_base) {
	case view_gen_argseqnr_rec_enum: {
	    view_gen_argseqnr_rec_class& kc_current_view=static_cast<view_gen_argseqnr_rec_class&>(kc_current_view_base);
	    if ((this->arguments_1->prod_sel() == sel_Nilarguments)) {
		const ID a = this->ID_1;
		{ kc_printer(kc_t("_"), kc_current_view); }
		kc::unparse(a, kc_printer, kc_current_view);
		{ kc_printer(kc_t("_"), kc_current_view); }
		kc::unparse(this->seqnr, kc_printer, kc_current_view);
	    } else
	    {
		const ID a = this->ID_1;
		const arguments ra = this->arguments_1;
		kc::unparse(ra, kc_printer, kc_current_view);
		{ kc_printer(kc_t(", _"), kc_current_view); }
		kc::unparse(a, kc_printer, kc_current_view);
		{ kc_printer(kc_t("_"), kc_current_view); }
		kc::unparse(this->seqnr, kc_printer, kc_current_view);
	    }
	    break;
	}
	case view_gen_set_subphylumdefs_c_enum: {
	    view_gen_set_subphylumdefs_c_class& kc_current_view=static_cast<view_gen_set_subphylumdefs_c_class&>(kc_current_view_base);
	    {
		const ID a = this->ID_1;
		const arguments ra = this->arguments_1;
		kc::unparse(ra, kc_printer, kc_current_view);
		{ kc_printer(kc_t("case "), kc_current_view); }
		kc::unparse(gl_no_of_args, kc_printer, kc_current_view);
		{ kc_printer(kc_t(": newval = "), kc_current_view); }
		kc::unparse(a, kc_printer, kc_current_view);
		{ kc_printer(kc_t("_"), kc_current_view); }
		kc::unparse(this->seqnr, kc_printer, kc_current_view);
		{ kc_printer(kc_t(" = dynamic_cast<"), kc_current_view); }
		kc::unparse(a, kc_printer, kc_current_view);
		{ kc_printer(kc_t(">(val);break;\n"), kc_current_view); }
		gl_no_of_args++; 
	    }
	    break;
	}
	case view_gen_subphylumdefs_c_enum: {
	    view_gen_subphylumdefs_c_class& kc_current_view=static_cast<view_gen_subphylumdefs_c_class&>(kc_current_view_base);
	    {
		const ID a = this->ID_1;
		const arguments ra = this->arguments_1;
		kc::unparse(ra, kc_printer, kc_current_view);
		{ kc_printer(kc_t("case "), kc_current_view); }
		kc::unparse(gl_no_of_args, kc_printer, kc_current_view);
		{ kc_printer(kc_t(": return "), kc_current_view); }
		kc::unparse(a, kc_printer, kc_current_view);
		{ kc_printer(kc_t("_"), kc_current_view); }
		kc::unparse(this->seqnr, kc_printer, kc_current_view);
		{ kc_printer(kc_t(";\n"), kc_current_view); }
		gl_no_of_args++; 
	    }
	    break;
	}
	case view_gen_unparsedefs_default_c_enum: {
	    view_gen_unparsedefs_default_c_class& kc_current_view=static_cast<view_gen_unparsedefs_default_c_class&>(kc_current_view_base);
	    if ((this->arguments_1->prod_sel() == sel_Consarguments) && ((this->arguments_1)->arguments_1->prod_sel() == sel_Nilarguments) && (KC_TRACE_PROVIDED((kc_current_view.isList && kc_current_view.isOnlyDefault), "gen.k", 7409, this))) {
		const ID tail = this->ID_1;
		const ID head = (this->arguments_1)->ID_1;
		{ kc_printer(kc_t("	    for ("), kc_current_view); }
		kc::unparse(tail, kc_printer, kc_current_view);
		{ kc_printer(kc_t(" iterator_ = this; iterator_->"), kc_current_view); }
		kc::unparse(tail, kc_printer, kc_current_view);
		{ kc_printer(kc_t("_1 != 0; iterator_ = iterator_->"), kc_current_view); }
		kc::unparse(tail, kc_printer, kc_current_view);
		{ kc_printer(kc_t("_1)\
\n		\viterator_->"), kc_current_view); }
		kc::unparse(head, kc_printer, kc_current_view);
		{ kc_printer(kc_t("_1->unparse(kc_printer, kc_current_view);\r\
\n"), kc_current_view); }
	    } else
		if ((KC_TRACE_PROVIDED((kc_current_view.isList && !kc_current_view.isOnlyDefault), "gen.k", 7418, this))) {
		const ID a = this->ID_1;
		const arguments rargs = this->arguments_1;
		kc::unparse(rargs, kc_printer, kc_current_view);
		{ kc_printer(kc_t("	    "), kc_current_view); }
		kc::unparse(a, kc_printer, kc_current_view);
		{ kc_printer(kc_t("_"), kc_current_view); }
		kc::unparse(this->seqnr, kc_printer, kc_current_view);
		{ kc_printer(kc_t("->"), kc_current_view); }
		if (a->eq(f_phylumofoperator(gl_operator)) &&
		    kc_current_view.isList) 
		{
		    { kc_printer(kc_t("do_"), kc_current_view); }
		}
		{ kc_printer(kc_t("unparse(kc_printer, kc_current_view );\
\n"), kc_current_view); }
	    } else
	    {
		{ kc_printer(kc_t("default_unparse(kc_printer, kc_current_view );\
\n"), kc_current_view); }
	    }
	    break;
	}
	case view_gen_rewritedefs_args_c_enum: {
	    view_gen_rewritedefs_args_c_class& kc_current_view=static_cast<view_gen_rewritedefs_args_c_class&>(kc_current_view_base);
	    if ((this->arguments_1->prod_sel() == sel_Nilarguments)) {
		const ID a_arg = this->ID_1;
		if (!g_options.rw_loop) 
		{
		    { kc_printer(kc_t("l_"), kc_current_view); }
		}
		kc::unparse(a_arg, kc_printer, kc_current_view);
		{ kc_printer(kc_t("_"), kc_current_view); }
		kc::unparse(this->seqnr, kc_printer, kc_current_view);
	    } else
	    {
		const ID a_arg = this->ID_1;
		const arguments r_args = this->arguments_1;
		kc::unparse(r_args, kc_printer, kc_current_view);
		{ kc_printer(kc_t(", "), kc_current_view); }
		if (!g_options.rw_loop) 
		{
		    { kc_printer(kc_t("l_"), kc_current_view); }
		}
		kc::unparse(a_arg, kc_printer, kc_current_view);
		{ kc_printer(kc_t("_"), kc_current_view); }
		kc::unparse(this->seqnr, kc_printer, kc_current_view);
	    }
	    break;
	}
	case view_gen_rewritedefs_dotestarg_c_enum: {
	    view_gen_rewritedefs_dotestarg_c_class& kc_current_view=static_cast<view_gen_rewritedefs_dotestarg_c_class&>(kc_current_view_base);
	    if ((this->arguments_1->prod_sel() == sel_Nilarguments)) {
		const ID a_arg = this->ID_1;
		{ kc_printer(kc_t("l_"), kc_current_view); }
		kc::unparse(a_arg, kc_printer, kc_current_view);
		{ kc_printer(kc_t("_"), kc_current_view); }
		kc::unparse(this->seqnr, kc_printer, kc_current_view);
		{ kc_printer(kc_t(" == "), kc_current_view); }
		kc::unparse(a_arg, kc_printer, kc_current_view);
		{ kc_printer(kc_t("_"), kc_current_view); }
		kc::unparse(this->seqnr, kc_printer, kc_current_view);
	    } else
	    {
		const ID a_arg = this->ID_1;
		const arguments r_args = this->arguments_1;
		kc::unparse(r_args, kc_printer, kc_current_view);
		{ kc_printer(kc_t(") &&  (l_"), kc_current_view); }
		kc::unparse(a_arg, kc_printer, kc_current_view);
		{ kc_printer(kc_t("_"), kc_current_view); }
		kc::unparse(this->seqnr, kc_printer, kc_current_view);
		{ kc_printer(kc_t(" == "), kc_current_view); }
		kc::unparse(a_arg, kc_printer, kc_current_view);
		{ kc_printer(kc_t("_"), kc_current_view); }
		kc::unparse(this->seqnr, kc_printer, kc_current_view);
	    }
	    break;
	}
	case view_gen_rewritedefs_testarg_c_enum: {
	    view_gen_rewritedefs_testarg_c_class& kc_current_view=static_cast<view_gen_rewritedefs_testarg_c_class&>(kc_current_view_base);
	    {
		gl_phylum = f_phylumofoperator(gl_operator); 
		 if(!g_options.rw_loop) 
		{
		    { kc_printer(kc_t("	if (("), kc_current_view); }
		    kc::unparse(this, kc_printer, view_gen_rewritedefs_dotestarg_c);
		    { kc_printer(kc_t("))\
\n	    return this;\
\n	else {\
\n	    impl_"), kc_current_view); }
		    kc::unparse(gl_phylum, kc_printer, kc_current_view);
		    if(f_listelementphylum(gl_phylum)->eq(f_emptyId()))
		    {
			{ kc_printer(kc_t("_"), kc_current_view); }
			kc::unparse(gl_operator, kc_printer, kc_current_view);
		    }
		    { kc_printer(kc_t("* kc_result= "), kc_current_view); }
		    kc::unparse(gl_operator, kc_printer, kc_current_view);
		    { kc_printer(kc_t("("), kc_current_view); }
		    kc::unparse(this, kc_printer, view_gen_rewritedefs_args_c);
		    { kc_printer(kc_t(");\
\n	    kc_result->rewrite_members(this);\
\n	    return kc_result;\
\n	}"), kc_current_view); }
		}
		else 
		{
		    { kc_printer(kc_t("	return this;"), kc_current_view); }
		}
		gl_phylum = 0; 
	    }
	    break;
	}
	case view_gen_rewritedefs_nl_arg_c_enum: {
	    view_gen_rewritedefs_nl_arg_c_class& kc_current_view=static_cast<view_gen_rewritedefs_nl_arg_c_class&>(kc_current_view_base);
	    {
		{ kc_printer(kc_t("	"), kc_current_view); }
		kc::unparse(gl_phylum, kc_printer, kc_current_view);
		{ kc_printer(kc_t(" kc_rp = (("), kc_current_view); }
		kc::unparse(this, kc_printer, view_gen_rewritedefs_dotestarg_c);
		{ kc_printer(kc_t("))\
\n	    ? this\
\n	    : "), kc_current_view); }
		kc::unparse(gl_operator, kc_printer, kc_current_view);
		{ kc_printer(kc_t("("), kc_current_view); }
		kc::unparse(this, kc_printer, view_gen_rewritedefs_args_c);
		{ kc_printer(kc_t(");\
\n"), kc_current_view); }
	    }
	    break;
	}
	case view_gen_rewritedefs_rewritearg_c_enum: {
	    view_gen_rewritedefs_rewritearg_c_class& kc_current_view=static_cast<view_gen_rewritedefs_rewritearg_c_class&>(kc_current_view_base);
	    {
		const ID a_arg = this->ID_1;
		const arguments r_args = this->arguments_1;
		kc::unparse(r_args, kc_printer, kc_current_view);
		if (!g_options.rw_loop) 
		{
		    if(g_options.smart_pointer) 
		    {
			{ kc_printer(kc_t("	"), kc_current_view); }
			kc::unparse(a_arg, kc_printer, kc_current_view);
			{ kc_printer(kc_t("_ptr l_"), kc_current_view); }
			kc::unparse(a_arg, kc_printer, kc_current_view);
			{ kc_printer(kc_t("_"), kc_current_view); }
			kc::unparse(this->seqnr, kc_printer, kc_current_view);
			{ kc_printer(kc_t(" ="), kc_current_view); }
		    }
		    else 
		    {
			{ kc_printer(kc_t("	"), kc_current_view); }
			kc::unparse(a_arg, kc_printer, kc_current_view);
			{ kc_printer(kc_t(" l_"), kc_current_view); }
			kc::unparse(a_arg, kc_printer, kc_current_view);
			{ kc_printer(kc_t("_"), kc_current_view); }
			kc::unparse(this->seqnr, kc_printer, kc_current_view);
			{ kc_printer(kc_t(" ="), kc_current_view); }
		    }
		    { kc_printer(kc_t("\n"), kc_current_view); }
		    if (g_options.covariant=='p') 
		    {
			{ kc_printer(kc_t("#ifndef NO_COVARIANT_RETURN\n"), kc_current_view); }
		    }
		    if (g_options.covariant!='n') 
		    {
			{ kc_printer(kc_t("\v"), kc_current_view); }
			kc::unparse(a_arg, kc_printer, kc_current_view);
			{ kc_printer(kc_t("_"), kc_current_view); }
			kc::unparse(this->seqnr, kc_printer, kc_current_view);
			{ kc_printer(kc_t("->rewrite(kc_current_view_base);\r\n"), kc_current_view); }
		    }
		    if (g_options.covariant=='p') 
		    {
			{ kc_printer(kc_t("#else\n"), kc_current_view); }
		    }
		    if (g_options.covariant!='y') 
		    {
			{ kc_printer(kc_t("\vstatic_cast<"), kc_current_view); }
			kc::unparse(a_arg, kc_printer, kc_current_view);
			{ kc_printer(kc_t(">("), kc_current_view); }
			kc::unparse(a_arg, kc_printer, kc_current_view);
			{ kc_printer(kc_t("_"), kc_current_view); }
			kc::unparse(this->seqnr, kc_printer, kc_current_view);
			{ kc_printer(kc_t("->rewrite(kc_current_view_base));\r\n"), kc_current_view); }
		    }
		    if (g_options.covariant=='p') 
		    {
			{ kc_printer(kc_t("#endif // NO_COVARIANT_RETURN\n"), kc_current_view); }
		    }
		}
	    }
	    break;
	}
	case view_gen_test_enum: {
	    view_gen_test_class& kc_current_view=static_cast<view_gen_test_class&>(kc_current_view_base);
	    {
		const arguments rargs = this->arguments_1;
		bool isnotlist=f_listelementphylum(gl_phylum)->eq(f_emptyId()); 
		kc::unparse(rargs, kc_printer, kc_current_view);
		if(isnotlist)
		{
		    { kc_printer(kc_t(" && (dynamic_cast<impl_"), kc_current_view); }
		    kc::unparse(gl_phylum, kc_printer, kc_current_view);
		    { kc_printer(kc_t("_"), kc_current_view); }
		    kc::unparse(gl_operator, kc_printer, kc_current_view);
		    { kc_printer(kc_t("*>(kc_x)->"), kc_current_view); }
		}
		else
		{
		    { kc_printer(kc_t(" && (kc_x->"), kc_current_view); }
		}
		kc::unparse(this, kc_printer, view_gen_argseqnr);
		{ kc_printer(kc_t(" == _"), kc_current_view); }
		kc::unparse(this, kc_printer, view_gen_argseqnr);
		{ kc_printer(kc_t(")"), kc_current_view); }
	    }
	    break;
	}
	case view_gen_assignment_inis_enum: {
	    view_gen_assignment_inis_class& kc_current_view=static_cast<view_gen_assignment_inis_class&>(kc_current_view_base);
	    if ((this->arguments_1->prod_sel() == sel_Nilarguments)) {
		const ID a = this->ID_1;
		kc::unparse(this, kc_printer, view_gen_argseqnr);
		{ kc_printer(kc_t("(_"), kc_current_view); }
		kc::unparse(this, kc_printer, view_gen_argseqnr);
		{ kc_printer(kc_t(")"), kc_current_view); }
		if (a->named_subphylum) 
		{
		    { kc_printer(kc_t(", "), kc_current_view); }
		    kc::unparse(a->named_subphylum, kc_printer, kc_current_view);
		    { kc_printer(kc_t("("), kc_current_view); }
		    kc::unparse(this, kc_printer, view_gen_argseqnr);
		    { kc_printer(kc_t(")"), kc_current_view); }
		}
	    } else
	    {
		const ID a = this->ID_1;
		const arguments rargs = this->arguments_1;
		kc::unparse(rargs, kc_printer, kc_current_view);
		{ kc_printer(kc_t(", "), kc_current_view); }
		kc::unparse(this, kc_printer, view_gen_argseqnr);
		{ kc_printer(kc_t("(_"), kc_current_view); }
		kc::unparse(this, kc_printer, view_gen_argseqnr);
		{ kc_printer(kc_t(")"), kc_current_view); }
		if (a->named_subphylum) 
		{
		    { kc_printer(kc_t(", "), kc_current_view); }
		    kc::unparse(a->named_subphylum, kc_printer, kc_current_view);
		    { kc_printer(kc_t("("), kc_current_view); }
		    kc::unparse(this, kc_printer, view_gen_argseqnr);
		    { kc_printer(kc_t(")"), kc_current_view); }
		}
	    }
	    break;
	}
	case view_gen_assignments_enum: {
	    view_gen_assignments_class& kc_current_view=static_cast<view_gen_assignments_class&>(kc_current_view_base);
	    {
		const arguments rargs = this->arguments_1;
		kc::unparse(rargs, kc_printer, kc_current_view);
		kc::unparse(this, kc_printer, view_gen_argseqnr);
		{ kc_printer(kc_t(" = _"), kc_current_view); }
		kc::unparse(this, kc_printer, view_gen_argseqnr);
		{ kc_printer(kc_t(";\
\n"), kc_current_view); }
	    }
	    break;
	}
	case view_gen_fnarg_and_decls_enum: {
	    view_gen_fnarg_and_decls_class& kc_current_view=static_cast<view_gen_fnarg_and_decls_class&>(kc_current_view_base);
	    if ((this->arguments_1->prod_sel() == sel_Nilarguments)) {
		const ID a = this->ID_1;
		kc::unparse(a, kc_printer, kc_current_view);
		{ kc_printer(kc_t(" _"), kc_current_view); }
		kc::unparse(this, kc_printer, view_gen_argseqnr);
	    } else
	    {
		const ID a = this->ID_1;
		const arguments rargs = this->arguments_1;
		kc::unparse(rargs, kc_printer, kc_current_view);
		{ kc_printer(kc_t(", "), kc_current_view); }
		kc::unparse(a, kc_printer, kc_current_view);
		{ kc_printer(kc_t(" _"), kc_current_view); }
		kc::unparse(this, kc_printer, view_gen_argseqnr);
	    }
	    break;
	}
	case view_gen_fnarg_asserts_enum: {
	    view_gen_fnarg_asserts_class& kc_current_view=static_cast<view_gen_fnarg_asserts_class&>(kc_current_view_base);
	    {
		const ID a = this->ID_1;
		const arguments rargs = this->arguments_1;
		kc::unparse(rargs, kc_printer, kc_current_view);
		{ kc_printer(kc_t("assertPhylum(_"), kc_current_view); }
		kc::unparse(this, kc_printer, view_gen_argseqnr);
		{ kc_printer(kc_t(", phylum_"), kc_current_view); }
		kc::unparse(a, kc_printer, kc_current_view);
		{ kc_printer(kc_t(");\n"), kc_current_view); }
	    }
	    break;
	}
	case view_gen_argseqnr_enum: {
	    view_gen_argseqnr_class& kc_current_view=static_cast<view_gen_argseqnr_class&>(kc_current_view_base);
	    {
		const ID a = this->ID_1;
		kc::unparse(a, kc_printer, kc_current_view);
		{ kc_printer(kc_t("_"), kc_current_view); }
		kc::unparse(this->seqnr, kc_printer, kc_current_view);
	    }
	    break;
	}
	case view_gen_attributeOf_function_enum: {
	    view_gen_attributeOf_function_class& kc_current_view=static_cast<view_gen_attributeOf_function_class&>(kc_current_view_base);
	    {
		const ID a = this->ID_1;
		const arguments ra = this->arguments_1;
		kc::unparse(ra, kc_printer, kc_current_view);
		ID ident;
		ac_identifier_list idents = gl_idents;
		for (int i=gl_idents->length(); i>gl_no_of_args; --i) {
		    {
			ac_identifier_list kc_selvar_0_1 = phylum_cast<ac_identifier_list>(idents);
			if ((kc_selvar_0_1->prod_sel() == sel_Consac_identifier_list)) {
			    const ID i = (kc_selvar_0_1)->ID_1;
			    const ac_identifier_list ri = (kc_selvar_0_1)->ac_identifier_list_1;
			    ident=i; idents=ri; 
			    	} else
			    kc_no_default_in_with( "", __LINE__, __FILE__ );
		    }
		}

		{ kc_printer(kc_t("case "), kc_current_view); }
		kc::unparse(gl_no_of_args, kc_printer, kc_current_view);
		{ kc_printer(kc_t(": return reinterpret_cast<abstract_phylum&>(phylum_cast<"), kc_current_view); }
		kc::unparse(gl_operator, kc_printer, view_class_of_op);
		{ kc_printer(kc_t("*>(kc_p)->"), kc_current_view); }
		kc::unparse(ident, kc_printer, kc_current_view);
		{ kc_printer(kc_t(");\n"), kc_current_view); }
		++gl_no_of_args; 
	    }
	    break;
	}
	case view_gen_create_function_enum: {
	    view_gen_create_function_class& kc_current_view=static_cast<view_gen_create_function_class&>(kc_current_view_base);
	    if ((this->arguments_1->prod_sel() == sel_Nilarguments)) {
		const ID a = this->ID_1;
		{ kc_printer(kc_t("phylum_cast<"), kc_current_view); }
		kc::unparse(a, kc_printer, kc_current_view);
		{ kc_printer(kc_t(">(kc_p1)"), kc_current_view); }
		gl_generic_counter=2; 
			} else
	    {
		const ID a = this->ID_1;
		const arguments ra = this->arguments_1;
		kc::unparse(ra, kc_printer, kc_current_view);
		{ kc_printer(kc_t(", "), kc_current_view); }
		{ kc_printer(kc_t("phylum_cast<"), kc_current_view); }
		kc::unparse(a, kc_printer, kc_current_view);
		{ kc_printer(kc_t(">(kc_p"), kc_current_view); }
		kc::unparse(gl_generic_counter, kc_printer, kc_current_view);
		{ kc_printer(kc_t(")"), kc_current_view); }
		++gl_generic_counter; 
	    }
	    break;
	}
	case view_gen_operatorcast_h_enum: {
	    view_gen_operatorcast_h_class& kc_current_view=static_cast<view_gen_operatorcast_h_class&>(kc_current_view_base);
	    if ((this->arguments_1->prod_sel() == sel_Nilarguments)) {
		const ID a = this->ID_1;
		kc::unparse(a, kc_printer, kc_current_view);
	    } else
	    {
		const ID a = this->ID_1;
		const arguments rargs = this->arguments_1;
		kc::unparse(rargs, kc_printer, kc_current_view);
		{ kc_printer(kc_t(", "), kc_current_view); }
		kc::unparse(a, kc_printer, kc_current_view);
	    }
	    break;
	}
	case view_gen_operatordecls_h_enum: {
	    view_gen_operatordecls_h_class& kc_current_view=static_cast<view_gen_operatordecls_h_class&>(kc_current_view_base);
	    if ((this->arguments_1->prod_sel() == sel_Nilarguments)) {
		const ID a = this->ID_1;
		kc::unparse(a, kc_printer, kc_current_view);
	    } else
	    {
		const ID a = this->ID_1;
		const arguments rargs = this->arguments_1;
		kc::unparse(rargs, kc_printer, kc_current_view);
		{ kc_printer(kc_t(", "), kc_current_view); }
		kc::unparse(a, kc_printer, kc_current_view);
	    }
	    break;
	}
	case view_gen_nodetypes_h_enum: {
	    view_gen_nodetypes_h_class& kc_current_view=static_cast<view_gen_nodetypes_h_class&>(kc_current_view_base);
	    {
		const ID a = this->ID_1;
		const arguments rargs = this->arguments_1;
		kc::unparse(rargs, kc_printer, kc_current_view);
		if(g_options.smart_pointer) 
		{
		    kc::unparse(a, kc_printer, kc_current_view);
		    { kc_printer(kc_t("_ptr "), kc_current_view); }
		}
		else 
		{
		    { kc_printer(kc_t("	    impl_"), kc_current_view); }
		    kc::unparse(a, kc_printer, kc_current_view);
		    { kc_printer(kc_t("* "), kc_current_view); }
		}
		kc::unparse(a, kc_printer, kc_current_view);
		{ kc_printer(kc_t("_"), kc_current_view); }
		kc::unparse(this->seqnr, kc_printer, kc_current_view);
		{ kc_printer(kc_t(";\n"), kc_current_view); }
		if (a->named_subphylum) 
		{
		    if(g_options.smart_pointer) 
		    {
			kc::unparse(a, kc_printer, kc_current_view);
			{ kc_printer(kc_t("_ptr& "), kc_current_view); }
		    }
		    else 
		    {
			{ kc_printer(kc_t("	    impl_"), kc_current_view); }
			kc::unparse(a, kc_printer, kc_current_view);
			{ kc_printer(kc_t("*& "), kc_current_view); }
		    }
		    kc::unparse(a->named_subphylum, kc_printer, kc_current_view);
		    { kc_printer(kc_t(" /* = "), kc_current_view); }
		    kc::unparse(a, kc_printer, kc_current_view);
		    { kc_printer(kc_t("_"), kc_current_view); }
		    kc::unparse(this->seqnr, kc_printer, kc_current_view);
		    { kc_printer(kc_t("*/;\n"), kc_current_view); }
		}
	    }
	    break;
	}
	case view_gen_operatormap_subphyla_enum: {
	    view_gen_operatormap_subphyla_class& kc_current_view=static_cast<view_gen_operatormap_subphyla_class&>(kc_current_view_base);
	    if ((this->arguments_1->prod_sel() == sel_Nilarguments)) {
		const ID a = this->ID_1;
		{ kc_printer(kc_t("phylum_"), kc_current_view); }
		kc::unparse(a, kc_printer, kc_current_view);
	    } else
	    {
		const ID a = this->ID_1;
		const arguments ra = this->arguments_1;
		kc::unparse(ra, kc_printer, kc_current_view);
		{ kc_printer(kc_t(", "), kc_current_view); }
		{ kc_printer(kc_t("phylum_"), kc_current_view); }
		kc::unparse(a, kc_printer, kc_current_view);
	    }
	    break;
	}
	case view_count_args_enum: {
	    view_count_args_class& kc_current_view=static_cast<view_count_args_class&>(kc_current_view_base);
	    {
		const arguments ra = this->arguments_1;
		kc::unparse(ra, kc_printer, kc_current_view);
		gl_no_of_args++; 
	    }
	    break;
	}
	case view_check_uniq1_enum: {
	    view_check_uniq1_class& kc_current_view=static_cast<view_check_uniq1_class&>(kc_current_view_base);
	    {
		const ID id = this->ID_1;
		const arguments rargs = this->arguments_1;
		phylumdeclaration tmp = f_lookupdecl( id ); 
		kc::unparse(rargs, kc_printer, kc_current_view);
		if (tmp) 
		{
		    kc::unparse(tmp, kc_printer, view_check_uniq2);
		}
	    }
	    break;
	}
	case view_check_count1_enum: {
	    view_check_count1_class& kc_current_view=static_cast<view_check_count1_class&>(kc_current_view_base);
	    {
		const ID id = this->ID_1;
		const arguments rargs = this->arguments_1;
		kc::unparse(rargs, kc_printer, kc_current_view);
		f_useoccurphylum( id );
		this->seqnr = f_getcount( id );

	    }
	    break;
	}

	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    { /* Alternative( *, args ) -> [view_gen_unparsedefs_default_c: */
		for (arguments iterator_ = this; iterator_->arguments_1 != 0; iterator_ = iterator_->arguments_1)
		    iterator_->ID_1->unparse(kc_printer, kc_current_view);
	    }
	    break;
	}
    }
}

void
impl_arguments::nil_do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case view_gen_rewritedefs_args_c_enum: {
	    view_gen_rewritedefs_args_c_class& kc_current_view=static_cast<view_gen_rewritedefs_args_c_class&>(kc_current_view_base);
	    {
	    }
	    break;
	}
	case view_gen_rewritedefs_dotestarg_c_enum: {
	    view_gen_rewritedefs_dotestarg_c_class& kc_current_view=static_cast<view_gen_rewritedefs_dotestarg_c_class&>(kc_current_view_base);
	    {
	    }
	    break;
	}
	case view_gen_rewritedefs_testarg_c_enum: {
	    view_gen_rewritedefs_testarg_c_class& kc_current_view=static_cast<view_gen_rewritedefs_testarg_c_class&>(kc_current_view_base);
	    {
		{ kc_printer(kc_t("	return this;\
\n"), kc_current_view); }
	    }
	    break;
	}
	case view_gen_rewritedefs_nl_arg_c_enum: {
	    view_gen_rewritedefs_nl_arg_c_class& kc_current_view=static_cast<view_gen_rewritedefs_nl_arg_c_class&>(kc_current_view_base);
	    {
		{ kc_printer(kc_t("	"), kc_current_view); }
		kc::unparse(gl_phylum, kc_printer, kc_current_view);
		{ kc_printer(kc_t(" kc_rp = this;\
\n"), kc_current_view); }
	    }
	    break;
	}
	case view_gen_rewritedefs_rewritearg_c_enum: {
	    view_gen_rewritedefs_rewritearg_c_class& kc_current_view=static_cast<view_gen_rewritedefs_rewritearg_c_class&>(kc_current_view_base);
	    {
	    }
	    break;
	}
	case view_gen_test_enum: {
	    view_gen_test_class& kc_current_view=static_cast<view_gen_test_class&>(kc_current_view_base);
	    {
	    }
	    break;
	}
	case view_gen_assignments_predef_ini_enum: {
	    view_gen_assignments_predef_ini_class& kc_current_view=static_cast<view_gen_assignments_predef_ini_class&>(kc_current_view_base);
	    {
		enum_operators kc_i = f_selofoperator(gl_operator);
		PRINT(preDefTypeAndName[kc_i][1]); 
			{ kc_printer(kc_t("(_"), kc_current_view); }
		PRINT(preDefTypeAndName[kc_i][1]); 
			{ kc_printer(kc_t(")"), kc_current_view); }
	    }
	    break;
	}
	case view_gen_assignments_predef_enum: {
	    view_gen_assignments_predef_class& kc_current_view=static_cast<view_gen_assignments_predef_class&>(kc_current_view_base);
	    {
		enum_operators kc_i = f_selofoperator(gl_operator);
		PRINT(preDefTypeAndName[kc_i][1]); 
			{ kc_printer(kc_t(" = _"), kc_current_view); }
		PRINT(preDefTypeAndName[kc_i][1]); 
			{ kc_printer(kc_t(";\n"), kc_current_view); }
	    }
	    break;
	}
	case view_gen_assignments_enum: {
	    view_gen_assignments_class& kc_current_view=static_cast<view_gen_assignments_class&>(kc_current_view_base);
	    {
	    }
	    break;
	}
	case view_gen_fnarg_and_decls_predef_enum: {
	    view_gen_fnarg_and_decls_predef_class& kc_current_view=static_cast<view_gen_fnarg_and_decls_predef_class&>(kc_current_view_base);
	    {
		enum_operators kc_i = f_selofoperator(gl_operator); 
		 PRINT(preDefTypeAndName[kc_i][0]); 
			{ kc_printer(kc_t(" _"), kc_current_view); }
		PRINT(preDefTypeAndName[kc_i][1]); 
	    }
	    break;
	}
	case view_gen_fnarg_and_decls_enum: {
	    view_gen_fnarg_and_decls_class& kc_current_view=static_cast<view_gen_fnarg_and_decls_class&>(kc_current_view_base);
	    {
	    }
	    break;
	}
	case view_gen_fnarg_asserts_enum: {
	    view_gen_fnarg_asserts_class& kc_current_view=static_cast<view_gen_fnarg_asserts_class&>(kc_current_view_base);
	    {
	    }
	    break;
	}
	case view_gen_attributeOf_function_enum: {
	    view_gen_attributeOf_function_class& kc_current_view=static_cast<view_gen_attributeOf_function_class&>(kc_current_view_base);
	    {
		gl_no_of_args=0;
	    }
	    break;
	}
	case view_gen_operatormap_subphyla_enum: {
	    view_gen_operatormap_subphyla_class& kc_current_view=static_cast<view_gen_operatormap_subphyla_class&>(kc_current_view_base);
	    {
	    }
	    break;
	}
	case view_count_args_enum: {
	    view_count_args_class& kc_current_view=static_cast<view_count_args_class&>(kc_current_view_base);
	    {
		gl_no_of_args = 0; 
	    }
	    break;
	}
	case view_check_uniq1_enum: {
	    view_check_uniq1_class& kc_current_view=static_cast<view_check_uniq1_class&>(kc_current_view_base);
	    {
	    }
	    break;
	}
	case view_check_count1_enum: {
	    view_check_count1_class& kc_current_view=static_cast<view_check_count1_class&>(kc_current_view_base);
	    {
	    }
	    break;
	}

	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    { /* Alternative( *, args ) -> [view_gen_unparsedefs_default_c: */
	    }
	    break;
	}
    }
}


void
impl_argument_Argument::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		const ID id = this->ID_1;
		const integer i = this->integer_1;
		kc::unparse(id, kc_printer, kc_current_view);
		{ kc_printer(kc_t("_"), kc_current_view); }
		kc::unparse(i, kc_printer, kc_current_view);
	    }
	    break;
	}
    }
}


void
impl_Ccode_option_CcodeOption::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case view_gen_nodetypes_h_enum: {
	    view_gen_nodetypes_h_class& kc_current_view=static_cast<view_gen_nodetypes_h_class&>(kc_current_view_base);
	    {
		const attributes a = this->attributes_1;
		kc::unparse(a, kc_printer, kc_current_view);
	    }
	    break;
	}
	case view_gen_initializephyla_c_enum: {
	    view_gen_initializephyla_c_class& kc_current_view=static_cast<view_gen_initializephyla_c_class&>(kc_current_view_base);
	    {
		const attributes attr = this->attributes_1;
		const Ctexts init = this->Ctexts_1;
		kc::unparse(attr, kc_printer, kc_current_view);
		kc::unparse(init, kc_printer, kc_current_view);
	    }
	    break;
	}
	case view_check_enum: {
	    view_check_class& kc_current_view=static_cast<view_check_class&>(kc_current_view_base);
	    {
		const Ctexts ct = this->Ctexts_1;
		kc::unparse(ct, kc_printer, kc_current_view);
	    }
	    break;
	}

	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    { /* Alternative( *, args ) -> [view_gen_unparsedefs_default_c: */
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}

void
impl_attributes::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    if(is_nil())
	nil_do_unparse(kc_printer, kc_current_view_base);
    else
	switch(kc_current_view_base) {
	case view_gen_copy_attributes_c_enum: {
	    view_gen_copy_attributes_c_class& kc_current_view=static_cast<view_gen_copy_attributes_c_class&>(kc_current_view_base);
	    if ((this->attribute_1->prod_sel() == sel_Attribute)) {
		const ID aid = phylum_cast<const impl_attribute_Attribute*>(this->attribute_1)->ID_2;
		const attributes ra = this->attributes_1;
		kc::unparse(ra, kc_printer, kc_current_view);
		{ kc_printer(kc_t("    p2->"), kc_current_view); }
		kc::unparse(aid, kc_printer, kc_current_view);
		{ kc_printer(kc_t(" = p1->"), kc_current_view); }
		kc::unparse(aid, kc_printer, kc_current_view);
		{ kc_printer(kc_t(";\
\n"), kc_current_view); }
	    } else
		    goto kc_unparsing_default;
	    break;
	}
	case view_gen_nodetypes_h_enum: {
	    view_gen_nodetypes_h_class& kc_current_view=static_cast<view_gen_nodetypes_h_class&>(kc_current_view_base);
	    if ((this->attribute_1->prod_sel() == sel_Attribute)) {
		const ID t = phylum_cast<const impl_attribute_Attribute*>(this->attribute_1)->ID_1;
		const ID id = phylum_cast<const impl_attribute_Attribute*>(this->attribute_1)->ID_2;
		const attributes ra = this->attributes_1;
		kc::unparse(ra, kc_printer, kc_current_view);
		{ kc_printer(kc_t("    "), kc_current_view); }
		kc::unparse(t, kc_printer, kc_current_view);
		{ kc_printer(kc_t(" "), kc_current_view); }
		kc::unparse(id, kc_printer, kc_current_view);
		{ kc_printer(kc_t(";\
\n"), kc_current_view); }
	    } else
		    goto kc_unparsing_default;
	    break;
	}
	case view_gen_initializephyla_c_enum: {
	    view_gen_initializephyla_c_class& kc_current_view=static_cast<view_gen_initializephyla_c_class&>(kc_current_view_base);
	    if ((this->attribute_1->prod_sel() == sel_Attribute) && (phylum_cast<const impl_attribute_Attribute*>(this->attribute_1)->attribute_initialisation_option_1->prod_sel() == sel_Yesattribute_initialisation)) {
		const ID aid = phylum_cast<const impl_attribute_Attribute*>(this->attribute_1)->ID_2;
		const Cexpression cexpr = phylum_cast<const impl_attribute_initialisation_option_Yesattribute_initialisation*>(phylum_cast<const impl_attribute_Attribute*>(this->attribute_1)->attribute_initialisation_option_1)->Cexpression_1;
		const attributes ra = this->attributes_1;
		ID selvar; 
		kc::unparse(ra, kc_printer, kc_current_view);
		selvar = Id(Str(mkcasestring("kc_x")));
		selvar->line = aid->line; 
		selvar->file = aid->file;

		dollarvarstack.push( selvar );
		dollarvarextstack.push( f_emptyId() );
		operatorstack.push( f_emptyId() );

		if(g_options.linedirec) 
		{
		    kc::unparse(pg_line, kc_printer, kc_current_view);
		    kc::unparse(aid->line, kc_printer, kc_current_view);
		    { kc_printer(kc_t(" \""), kc_current_view); }
		    PRINT(g_options.dir_line.c_str()); 
		    kc::unparse(aid->file, kc_printer, view_filename);
		    { kc_printer(kc_t("\"\n"), kc_current_view); }
		}
		{ kc_printer(kc_t("    kc_x->"), kc_current_view); }
		kc::unparse(aid, kc_printer, kc_current_view);
		{ kc_printer(kc_t(" = "), kc_current_view); }
		kc::unparse(cexpr, kc_printer, kc_current_view);
		{ kc_printer(kc_t(";\
\n"), kc_current_view); }

		dollarvarstack.pop();
		dollarvarextstack.pop();
		operatorstack.pop();

	    } else
		if ((this->attribute_1->prod_sel() == sel_Attribute) && (phylum_cast<const impl_attribute_Attribute*>(this->attribute_1)->attribute_initialisation_option_1->prod_sel() == sel_Noattribute_initialisation)) {
		const attributes ra = this->attributes_1;
		kc::unparse(ra, kc_printer, kc_current_view);
	    } else
		    goto kc_unparsing_default;
	    break;
	}

	default:
	kc_unparsing_default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    { /* Alternative( *, args ) -> [view_gen_unparsedefs_default_c: */
		for (attributes iterator_ = this; iterator_->attributes_1 != 0; iterator_ = iterator_->attributes_1)
		    iterator_->attribute_1->unparse(kc_printer, kc_current_view);
	    }
	    break;
	}
    }
}

void
impl_attributes::nil_do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case view_gen_copy_attributes_c_enum: {
	    view_gen_copy_attributes_c_class& kc_current_view=static_cast<view_gen_copy_attributes_c_class&>(kc_current_view_base);
	    {
	    }
	    break;
	}
	case view_gen_nodetypes_h_enum: {
	    view_gen_nodetypes_h_class& kc_current_view=static_cast<view_gen_nodetypes_h_class&>(kc_current_view_base);
	    {
	    }
	    break;
	}
	case view_gen_initializephyla_c_enum: {
	    view_gen_initializephyla_c_class& kc_current_view=static_cast<view_gen_initializephyla_c_class&>(kc_current_view_base);
	    {
	    }
	    break;
	}

	default:
	kc_unparsing_default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    { /* Alternative( *, args ) -> [view_gen_unparsedefs_default_c: */
	    }
	    break;
	}
    }
}


void
impl_attribute_Attribute::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    { /* Alternative( *, args ) -> [view_gen_unparsedefs_default_c: */
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


void
impl_attribute_initialisation_option_Yesattribute_initialisation::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    { /* Alternative( *, args ) -> [view_gen_unparsedefs_default_c: */
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


void
impl_attribute_initialisation_option_Noattribute_initialisation::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    { /* Alternative( *, args ) -> [view_gen_unparsedefs_default_c: */
	    }
	    break;
	}
    }
}

void
impl_Cexpression::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    if(is_nil())
	nil_do_unparse(kc_printer, kc_current_view_base);
    else
	switch(kc_current_view_base) {
	case view_gen_user_predicates_enum: {
	    view_gen_user_predicates_class& kc_current_view=static_cast<view_gen_user_predicates_class&>(kc_current_view_base);
	    {
		const Cexpression_elem ce = this->Cexpression_elem_1;
		const Cexpression ces = this->Cexpression_1;
		kc::unparse(ces, kc_printer, kc_current_view);
		kc::unparse(ce, kc_printer, kc_current_view);
	    }
	    break;
	}
	case view_gen_initializephyla_c_enum: {
	    view_gen_initializephyla_c_class& kc_current_view=static_cast<view_gen_initializephyla_c_class&>(kc_current_view_base);
	    {
		const Cexpression_elem ce = this->Cexpression_elem_1;
		const Cexpression ces = this->Cexpression_1;
		kc::unparse(ces, kc_printer, kc_current_view);
		kc::unparse(ce, kc_printer, kc_current_view);
	    }
	    break;
	}
	case view_error_enum: {
	    view_error_class& kc_current_view=static_cast<view_error_class&>(kc_current_view_base);
	    {
		const Cexpression_elem h = this->Cexpression_elem_1;
		const Cexpression t = this->Cexpression_1;
		kc::unparse(t, kc_printer, kc_current_view);
		kc::unparse(h, kc_printer, kc_current_view);
	    }
	    break;
	}

	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    { /* Alternative( *, args ) -> [view_gen_unparsedefs_default_c: */
		for (Cexpression iterator_ = this; iterator_->Cexpression_1 != 0; iterator_ = iterator_->Cexpression_1)
		    iterator_->Cexpression_elem_1->unparse(kc_printer, kc_current_view);
	    }
	    break;
	}
    }
}

void
impl_Cexpression::nil_do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case view_gen_user_predicates_enum: {
	    view_gen_user_predicates_class& kc_current_view=static_cast<view_gen_user_predicates_class&>(kc_current_view_base);
	    {
	    }
	    break;
	}
	case view_gen_initializephyla_c_enum: {
	    view_gen_initializephyla_c_class& kc_current_view=static_cast<view_gen_initializephyla_c_class&>(kc_current_view_base);
	    {
	    }
	    break;
	}
	case view_error_enum: {
	    view_error_class& kc_current_view=static_cast<view_error_class&>(kc_current_view_base);
	    {
	    }
	    break;
	}

	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    { /* Alternative( *, args ) -> [view_gen_unparsedefs_default_c: */
	    }
	    break;
	}
    }
}


void
impl_Cexpression_elem_CExpressionArray::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case view_gen_user_predicates_enum: {
	    view_gen_user_predicates_class& kc_current_view=static_cast<view_gen_user_predicates_class&>(kc_current_view_base);
	    {
		const Cexpression cexpr = this->Cexpression_1;
		{ kc_printer(kc_t("["), kc_current_view); }
		kc::unparse(cexpr, kc_printer, kc_current_view);
		{ kc_printer(kc_t("]"), kc_current_view); }
	    }
	    break;
	}
	case view_gen_initializephyla_c_enum: {
	    view_gen_initializephyla_c_class& kc_current_view=static_cast<view_gen_initializephyla_c_class&>(kc_current_view_base);
	    {
		const Cexpression cexpr = this->Cexpression_1;
		{ kc_printer(kc_t("["), kc_current_view); }
		kc::unparse(cexpr, kc_printer, kc_current_view);
		{ kc_printer(kc_t("]"), kc_current_view); }
	    }
	    break;
	}
	case view_error_enum: {
	    view_error_class& kc_current_view=static_cast<view_error_class&>(kc_current_view_base);
	    {
		const Cexpression ce = this->Cexpression_1;
		{ kc_printer(kc_t("["), kc_current_view); }
		kc::unparse(ce, kc_printer, kc_current_view);
		{ kc_printer(kc_t("]"), kc_current_view); }
	    }
	    break;
	}

	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    { /* Alternative( *, args ) -> [view_gen_unparsedefs_default_c: */
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


void
impl_Cexpression_elem_CExpressionPack::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case view_gen_user_predicates_enum: {
	    view_gen_user_predicates_class& kc_current_view=static_cast<view_gen_user_predicates_class&>(kc_current_view_base);
	    {
		const Cexpression cexpr = this->Cexpression_1;
		{ kc_printer(kc_t("("), kc_current_view); }
		kc::unparse(cexpr, kc_printer, kc_current_view);
		{ kc_printer(kc_t(")"), kc_current_view); }
	    }
	    break;
	}
	case view_gen_initializephyla_c_enum: {
	    view_gen_initializephyla_c_class& kc_current_view=static_cast<view_gen_initializephyla_c_class&>(kc_current_view_base);
	    {
		const Cexpression cexpr = this->Cexpression_1;
		{ kc_printer(kc_t("("), kc_current_view); }
		kc::unparse(cexpr, kc_printer, kc_current_view);
		{ kc_printer(kc_t(")"), kc_current_view); }
	    }
	    break;
	}
	case view_error_enum: {
	    view_error_class& kc_current_view=static_cast<view_error_class&>(kc_current_view_base);
	    {
		const Cexpression ce = this->Cexpression_1;
		{ kc_printer(kc_t("("), kc_current_view); }
		kc::unparse(ce, kc_printer, kc_current_view);
		{ kc_printer(kc_t(")"), kc_current_view); }
	    }
	    break;
	}

	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    { /* Alternative( *, args ) -> [view_gen_unparsedefs_default_c: */
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


void
impl_Cexpression_elem_CExpressionSQ::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case view_gen_user_predicates_enum: {
	    view_gen_user_predicates_class& kc_current_view=static_cast<view_gen_user_predicates_class&>(kc_current_view_base);
	    {
		const CexpressionSQ cesq = this->CexpressionSQ_1;
		{ kc_printer(kc_t("'"), kc_current_view); }
		kc::unparse(cesq, kc_printer, kc_current_view);
		{ kc_printer(kc_t("'"), kc_current_view); }
	    }
	    break;
	}
	case view_gen_initializephyla_c_enum: {
	    view_gen_initializephyla_c_class& kc_current_view=static_cast<view_gen_initializephyla_c_class&>(kc_current_view_base);
	    {
		const CexpressionSQ cesq = this->CexpressionSQ_1;
		{ kc_printer(kc_t("'"), kc_current_view); }
		kc::unparse(cesq, kc_printer, kc_current_view);
		{ kc_printer(kc_t("'"), kc_current_view); }
	    }
	    break;
	}
	case view_error_enum: {
	    view_error_class& kc_current_view=static_cast<view_error_class&>(kc_current_view_base);
	    {
		const CexpressionSQ cesq = this->CexpressionSQ_1;
		{ kc_printer(kc_t("'"), kc_current_view); }
		kc::unparse(cesq, kc_printer, kc_current_view);
		{ kc_printer(kc_t("'"), kc_current_view); }
	    }
	    break;
	}

	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    { /* Alternative( *, args ) -> [view_gen_unparsedefs_default_c: */
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


void
impl_Cexpression_elem_CExpressionDQ::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case view_gen_user_predicates_enum: {
	    view_gen_user_predicates_class& kc_current_view=static_cast<view_gen_user_predicates_class&>(kc_current_view_base);
	    {
		const CexpressionDQ cedq = this->CexpressionDQ_1;
		{ kc_printer(kc_t("\""), kc_current_view); }
		kc::unparse(cedq, kc_printer, kc_current_view);
		{ kc_printer(kc_t("\""), kc_current_view); }
	    }
	    break;
	}
	case view_gen_initializephyla_c_enum: {
	    view_gen_initializephyla_c_class& kc_current_view=static_cast<view_gen_initializephyla_c_class&>(kc_current_view_base);
	    {
		const CexpressionDQ cedq = this->CexpressionDQ_1;
		{ kc_printer(kc_t("\""), kc_current_view); }
		kc::unparse(cedq, kc_printer, kc_current_view);
		{ kc_printer(kc_t("\""), kc_current_view); }
	    }
	    break;
	}
	case view_error_enum: {
	    view_error_class& kc_current_view=static_cast<view_error_class&>(kc_current_view_base);
	    {
		const CexpressionDQ cedq = this->CexpressionDQ_1;
		{ kc_printer(kc_t("\""), kc_current_view); }
		kc::unparse(cedq, kc_printer, kc_current_view);
		{ kc_printer(kc_t("\""), kc_current_view); }
	    }
	    break;
	}

	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    { /* Alternative( *, args ) -> [view_gen_unparsedefs_default_c: */
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


void
impl_Cexpression_elem_CExpressionNl::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case view_gen_user_predicates_enum: {
	    view_gen_user_predicates_class& kc_current_view=static_cast<view_gen_user_predicates_class&>(kc_current_view_base);
	    {
		{ kc_printer(kc_t("\n"), kc_current_view); }
	    }
	    break;
	}
	case view_gen_initializephyla_c_enum: {
	    view_gen_initializephyla_c_class& kc_current_view=static_cast<view_gen_initializephyla_c_class&>(kc_current_view_base);
	    {
		{ kc_printer(kc_t("\n"), kc_current_view); }
	    }
	    break;
	}
	case view_error_enum: {
	    view_error_class& kc_current_view=static_cast<view_error_class&>(kc_current_view_base);
	    {
		{ kc_printer(kc_t(" "), kc_current_view); }
	    }
	    break;
	}

	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    { /* Alternative( *, args ) -> [view_gen_unparsedefs_default_c: */
	    }
	    break;
	}
    }
}


void
impl_Cexpression_elem_CExpressionDollarvar::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case view_gen_initializephyla_c_enum: {
	    view_gen_initializephyla_c_class& kc_current_view=static_cast<view_gen_initializephyla_c_class&>(kc_current_view_base);
	    {
		const INT i = this->INT_1;
		ID oid = f_emptyId(), dollarvar = dollarvarstack.top(), dollarvarext = dollarvarextstack.top();
		argument arg;
		bool nulvar = true;
		{
		    INT kc_selvar_0_1 = phylum_cast<INT>( i );
		    if ((kc_selvar_0_1->prod_sel() == sel_Int)) {
			const integer ii = phylum_cast<const impl_INT_Int*>(kc_selvar_0_1)->integer_1;

			if (ii->value != 0) {
			    nulvar = false;
			    oid = operatorstack.top();
			    arg = f_argumentofoperator( oid, i );
			}   
				} else
			kc_no_default_in_with( "", __LINE__, __FILE__ );
		}

		if (nulvar) 
		{
		    kc::unparse(dollarvar, kc_printer, kc_current_view);
		    kc::unparse(dollarvarext, kc_printer, kc_current_view);
		}
		else 
		{
		    kc::unparse(dollarvar, kc_printer, kc_current_view);
		    kc::unparse(dollarvarext, kc_printer, kc_current_view);
		    { kc_printer(kc_t("->"), kc_current_view); }
		    kc::unparse(arg, kc_printer, kc_current_view);
		    arg->free( false );  
		     }
	    }
	    break;
	}
	case view_error_enum: {
	    view_error_class& kc_current_view=static_cast<view_error_class&>(kc_current_view_base);
	    {
		const INT i = this->INT_1;
		{ kc_printer(kc_t("$"), kc_current_view); }
		kc::unparse(i, kc_printer, kc_current_view);
	    }
	    break;
	}

	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    { /* Alternative( *, args ) -> [view_gen_unparsedefs_default_c: */
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


void
impl_Cexpression_elem_CExpressionPart::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case view_gen_user_predicates_enum: {
	    view_gen_user_predicates_class& kc_current_view=static_cast<view_gen_user_predicates_class&>(kc_current_view_base);
	    {
		const casestring cs = this->casestring_1;
		std::map<string, path>::iterator p; char const *c=cs->name; std::string s;
#ifdef KIMWITUVERSIONMAJOR
#define kc_uviews uviews
#endif
		while (*c) {
		    s=f_getidentfromstring(&c);
		    p=gl_bindings.find(s);
		    if (p!=gl_bindings.end()) {
			path path_temp=p->second;
			{
			    path kc_selvar_0_1 = phylum_cast<path>(path_temp);
			    if ((kc_selvar_0_1->prod_sel() == sel_Conspath)) {
				const path r_p = (kc_selvar_0_1)->path_1;

				r_p->unparse(kc_printer, view_gen_cast);
				path_temp->unparse(kc_printer, *kc_uviews[gl_outer_view].view); 
					} else
				if ((kc_selvar_0_1->prod_sel() == sel_Nilpath)) {
				path_temp->unparse(kc_printer, *kc_uviews[gl_outer_view].view); 
					} else
				kc_no_default_in_with( "", __LINE__, __FILE__ );
			}
		    }
		    else {
			PRINT(s.c_str());
		    }
		} 
	    }
	    break;
	}
	case view_gen_initializephyla_c_enum: {
	    view_gen_initializephyla_c_class& kc_current_view=static_cast<view_gen_initializephyla_c_class&>(kc_current_view_base);
	    {
		const casestring cs = this->casestring_1;
		kc::unparse(cs, kc_printer, kc_current_view);
	    }
	    break;
	}
	case view_error_enum: {
	    view_error_class& kc_current_view=static_cast<view_error_class&>(kc_current_view_base);
	    {
		const casestring s = this->casestring_1;
		kc::unparse(s, kc_printer, kc_current_view);
	    }
	    break;
	}

	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    { /* Alternative( *, args ) -> [view_gen_unparsedefs_default_c: */
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}

void
impl_CexpressionDQ::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    if(is_nil())
	nil_do_unparse(kc_printer, kc_current_view_base);
    else
	switch(kc_current_view_base) {
	case view_output_collection_enum: {
	    view_output_collection_class& kc_current_view=static_cast<view_output_collection_class&>(kc_current_view_base);
	    {
		const CexpressionDQ_elem cedqe = this->CexpressionDQ_elem_1;
		const CexpressionDQ cedq = this->CexpressionDQ_1;
		kc::unparse(cedq, kc_printer, kc_current_view);
		kc::unparse(cedqe, kc_printer, kc_current_view);
	    }
	    break;
	}
	case view_gen_unpstr_c_enum: {
	    view_gen_unpstr_c_class& kc_current_view=static_cast<view_gen_unpstr_c_class&>(kc_current_view_base);
	    {
		const CexpressionDQ_elem cedqe = this->CexpressionDQ_elem_1;
		const CexpressionDQ cedq = this->CexpressionDQ_1;
		kc::unparse(cedq, kc_printer, kc_current_view);
		kc::unparse(cedqe, kc_printer, kc_current_view);
	    }
	    break;
	}
	case view_gen_initializephyla_c_enum: {
	    view_gen_initializephyla_c_class& kc_current_view=static_cast<view_gen_initializephyla_c_class&>(kc_current_view_base);
	    {
		const CexpressionDQ_elem cedqe = this->CexpressionDQ_elem_1;
		const CexpressionDQ cedq = this->CexpressionDQ_1;
		kc::unparse(cedq, kc_printer, kc_current_view);
		kc::unparse(cedqe, kc_printer, kc_current_view);
	    }
	    break;
	}
	case view_error_enum: {
	    view_error_class& kc_current_view=static_cast<view_error_class&>(kc_current_view_base);
	    {
		const CexpressionDQ_elem h = this->CexpressionDQ_elem_1;
		const CexpressionDQ t = this->CexpressionDQ_1;
		kc::unparse(t, kc_printer, kc_current_view);
		kc::unparse(h, kc_printer, kc_current_view);
	    }
	    break;
	}

	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    { /* Alternative( *, args ) -> [view_gen_unparsedefs_default_c: */
		for (CexpressionDQ iterator_ = this; iterator_->CexpressionDQ_1 != 0; iterator_ = iterator_->CexpressionDQ_1)
		    iterator_->CexpressionDQ_elem_1->unparse(kc_printer, kc_current_view);
	    }
	    break;
	}
    }
}

void
impl_CexpressionDQ::nil_do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case view_gen_unpstr_c_enum: {
	    view_gen_unpstr_c_class& kc_current_view=static_cast<view_gen_unpstr_c_class&>(kc_current_view_base);
	    {
	    }
	    break;
	}
	case view_gen_initializephyla_c_enum: {
	    view_gen_initializephyla_c_class& kc_current_view=static_cast<view_gen_initializephyla_c_class&>(kc_current_view_base);
	    {
	    }
	    break;
	}
	case view_error_enum: {
	    view_error_class& kc_current_view=static_cast<view_error_class&>(kc_current_view_base);
	    {
	    }
	    break;
	}

	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    { /* Alternative( *, args ) -> [view_gen_unparsedefs_default_c: */
	    }
	    break;
	}
    }
}


void
impl_CexpressionDQ_elem_CExpressionDQNl::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case view_output_collection_enum: {
	    view_output_collection_class& kc_current_view=static_cast<view_output_collection_class&>(kc_current_view_base);
	    {
		{ kc_printer(kc_t("\\\n\\n"), kc_current_view); }
	    }
	    break;
	}
	case view_gen_unpstr_c_enum: {
	    view_gen_unpstr_c_class& kc_current_view=static_cast<view_gen_unpstr_c_class&>(kc_current_view_base);
	    {
		{ kc_printer(kc_t("\\\n\\n"), kc_current_view); }
	    }
	    break;
	}
	case view_gen_initializephyla_c_enum: {
	    view_gen_initializephyla_c_class& kc_current_view=static_cast<view_gen_initializephyla_c_class&>(kc_current_view_base);
	    {
		{ kc_printer(kc_t("\n"), kc_current_view); }
	    }
	    break;
	}
	case view_error_enum: {
	    view_error_class& kc_current_view=static_cast<view_error_class&>(kc_current_view_base);
	    {
		{ kc_printer(kc_t(" "), kc_current_view); }
	    }
	    break;
	}

	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    { /* Alternative( *, args ) -> [view_gen_unparsedefs_default_c: */
	    }
	    break;
	}
    }
}


void
impl_CexpressionDQ_elem_CExpressionDQPart::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case view_output_collection_enum: {
	    view_output_collection_class& kc_current_view=static_cast<view_output_collection_class&>(kc_current_view_base);
	    {
		const casestring cs = this->casestring_1;
		kc::unparse(cs, kc_printer, kc_current_view);
	    }
	    break;
	}
	case view_gen_unpstr_c_enum: {
	    view_gen_unpstr_c_class& kc_current_view=static_cast<view_gen_unpstr_c_class&>(kc_current_view_base);
	    {
		const casestring cs = this->casestring_1;
		kc::unparse(cs, kc_printer, kc_current_view);
	    }
	    break;
	}
	case view_gen_initializephyla_c_enum: {
	    view_gen_initializephyla_c_class& kc_current_view=static_cast<view_gen_initializephyla_c_class&>(kc_current_view_base);
	    {
		const casestring cs = this->casestring_1;
		kc::unparse(cs, kc_printer, kc_current_view);
	    }
	    break;
	}
	case view_error_enum: {
	    view_error_class& kc_current_view=static_cast<view_error_class&>(kc_current_view_base);
	    {
		const casestring s = this->casestring_1;
		kc::unparse(s, kc_printer, kc_current_view);
	    }
	    break;
	}

	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    { /* Alternative( *, args ) -> [view_gen_unparsedefs_default_c: */
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}

void
impl_CexpressionSQ::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    if(is_nil())
	nil_do_unparse(kc_printer, kc_current_view_base);
    else
	switch(kc_current_view_base) {
	case view_gen_initializephyla_c_enum: {
	    view_gen_initializephyla_c_class& kc_current_view=static_cast<view_gen_initializephyla_c_class&>(kc_current_view_base);
	    {
		const CexpressionSQ_elem cesqe = this->CexpressionSQ_elem_1;
		const CexpressionSQ cesq = this->CexpressionSQ_1;
		kc::unparse(cesq, kc_printer, kc_current_view);
		kc::unparse(cesqe, kc_printer, kc_current_view);
	    }
	    break;
	}
	case view_error_enum: {
	    view_error_class& kc_current_view=static_cast<view_error_class&>(kc_current_view_base);
	    {
		const CexpressionSQ_elem h = this->CexpressionSQ_elem_1;
		const CexpressionSQ t = this->CexpressionSQ_1;
		kc::unparse(t, kc_printer, kc_current_view);
		kc::unparse(h, kc_printer, kc_current_view);
	    }
	    break;
	}

	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    { /* Alternative( *, args ) -> [view_gen_unparsedefs_default_c: */
		for (CexpressionSQ iterator_ = this; iterator_->CexpressionSQ_1 != 0; iterator_ = iterator_->CexpressionSQ_1)
		    iterator_->CexpressionSQ_elem_1->unparse(kc_printer, kc_current_view);
	    }
	    break;
	}
    }
}

void
impl_CexpressionSQ::nil_do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case view_gen_initializephyla_c_enum: {
	    view_gen_initializephyla_c_class& kc_current_view=static_cast<view_gen_initializephyla_c_class&>(kc_current_view_base);
	    {
	    }
	    break;
	}
	case view_error_enum: {
	    view_error_class& kc_current_view=static_cast<view_error_class&>(kc_current_view_base);
	    {
	    }
	    break;
	}

	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    { /* Alternative( *, args ) -> [view_gen_unparsedefs_default_c: */
	    }
	    break;
	}
    }
}


void
impl_CexpressionSQ_elem_CExpressionSQNl::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case view_gen_initializephyla_c_enum: {
	    view_gen_initializephyla_c_class& kc_current_view=static_cast<view_gen_initializephyla_c_class&>(kc_current_view_base);
	    {
		{ kc_printer(kc_t("\n"), kc_current_view); }
	    }
	    break;
	}
	case view_error_enum: {
	    view_error_class& kc_current_view=static_cast<view_error_class&>(kc_current_view_base);
	    {
		{ kc_printer(kc_t(" "), kc_current_view); }
	    }
	    break;
	}

	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    { /* Alternative( *, args ) -> [view_gen_unparsedefs_default_c: */
	    }
	    break;
	}
    }
}


void
impl_CexpressionSQ_elem_CExpressionSQPart::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case view_gen_initializephyla_c_enum: {
	    view_gen_initializephyla_c_class& kc_current_view=static_cast<view_gen_initializephyla_c_class&>(kc_current_view_base);
	    {
		const casestring cs = this->casestring_1;
		kc::unparse(cs, kc_printer, kc_current_view);
	    }
	    break;
	}
	case view_error_enum: {
	    view_error_class& kc_current_view=static_cast<view_error_class&>(kc_current_view_base);
	    {
		const casestring s = this->casestring_1;
		kc::unparse(s, kc_printer, kc_current_view);
	    }
	    break;
	}

	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    { /* Alternative( *, args ) -> [view_gen_unparsedefs_default_c: */
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}

void
impl_idCexpressions::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    if(is_nil())
	nil_do_unparse(kc_printer, kc_current_view_base);
    else
	switch(kc_current_view_base) {
	case view_gen_initializephyla_update_loop_c_enum: {
	    view_gen_initializephyla_update_loop_c_class& kc_current_view=static_cast<view_gen_initializephyla_update_loop_c_class&>(kc_current_view_base);
	    if ((this->idCexpression_1->prod_sel() == sel_IdCexpression)) {
		const ID tid = phylum_cast<const impl_idCexpression_IdCexpression*>(this->idCexpression_1)->ID_1;
		const Cexpression cexpr = phylum_cast<const impl_idCexpression_IdCexpression*>(this->idCexpression_1)->Cexpression_1;
		const idCexpressions t = this->idCexpressions_1;
		kc::unparse(t, kc_printer, kc_current_view);
		g_fe_selvar_nr++; 
			{ kc_printer(kc_t("kc_fe_selvar_"), kc_current_view); }
		kc::unparse(g_fe_selvar_nr, kc_printer, kc_current_view);
		{ kc_printer(kc_t(" = kc_fe_selvar_"), kc_current_view); }
		kc::unparse(g_fe_selvar_nr, kc_printer, kc_current_view);
		{ kc_printer(kc_t("->"), kc_current_view); }
		kc::unparse(tid, kc_printer, kc_current_view);
		{ kc_printer(kc_t("_1;\n"), kc_current_view); }
		if(g_options.linedirec) 
		{
		    kc::unparse(pg_line, kc_printer, kc_current_view);
		    kc::unparse(cexpr->line, kc_printer, kc_current_view);
		    { kc_printer(kc_t(" \""), kc_current_view); }
		    PRINT(g_options.dir_line.c_str()); 
		    kc::unparse(cexpr->file, kc_printer, view_filename);
		    { kc_printer(kc_t("\"\n"), kc_current_view); }
		}
	    } else
		    goto kc_unparsing_default;
	    break;
	}
	case view_gen_initializephyla_init_el_c_enum: {
	    view_gen_initializephyla_init_el_c_class& kc_current_view=static_cast<view_gen_initializephyla_init_el_c_class&>(kc_current_view_base);
	    if ((this->idCexpression_1->prod_sel() == sel_IdCexpression)) {
		const ID tid = phylum_cast<const impl_idCexpression_IdCexpression*>(this->idCexpression_1)->ID_1;
		const idCexpressions t = this->idCexpressions_1;
		ID element_type = f_listelementphylum( tid );
		ID selvar = cf_topselvar();

		kc::unparse(t, kc_printer, kc_current_view);
		g_fe_selvar_nr++; 
		kc::unparse(element_type, kc_printer, kc_current_view);
		{ kc_printer(kc_t(" "), kc_current_view); }
		kc::unparse(selvar, kc_printer, kc_current_view);
		{ kc_printer(kc_t("_"), kc_current_view); }
		kc::unparse(g_fe_selvar_nr, kc_printer, kc_current_view);
		{ kc_printer(kc_t(" = kc_fe_selvar_"), kc_current_view); }
		kc::unparse(g_fe_selvar_nr, kc_printer, kc_current_view);
		{ kc_printer(kc_t("->"), kc_current_view); }
		kc::unparse(element_type, kc_printer, kc_current_view);
		{ kc_printer(kc_t("_1;\
\n"), kc_current_view); }
	    } else
		    goto kc_unparsing_default;
	    break;
	}
	case view_gen_initializephyla_whiletest_c_enum: {
	    view_gen_initializephyla_whiletest_c_class& kc_current_view=static_cast<view_gen_initializephyla_whiletest_c_class&>(kc_current_view_base);
	    if ((this->idCexpression_1->prod_sel() == sel_IdCexpression) && (this->idCexpressions_1->prod_sel() == sel_NilidCexpressions)) {
		const ID tid = phylum_cast<const impl_idCexpression_IdCexpression*>(this->idCexpression_1)->ID_1;
		const idCexpressions t = this->idCexpressions_1;
		kc::unparse(t, kc_printer, kc_current_view);
		g_fe_selvar_nr++; 
			{ kc_printer(kc_t("    kc_fe_selvar_"), kc_current_view); }
		kc::unparse(g_fe_selvar_nr, kc_printer, kc_current_view);
		{ kc_printer(kc_t("->prod_sel() == sel_Cons"), kc_current_view); }
		kc::unparse(tid, kc_printer, kc_current_view);
		{ kc_printer(kc_t("\
\n"), kc_current_view); }
	    } else
		if ((this->idCexpression_1->prod_sel() == sel_IdCexpression)) {
		const ID tid = phylum_cast<const impl_idCexpression_IdCexpression*>(this->idCexpression_1)->ID_1;
		const idCexpressions t = this->idCexpressions_1;
		kc::unparse(t, kc_printer, kc_current_view);
		g_fe_selvar_nr++; 
			{ kc_printer(kc_t("    && kc_fe_selvar_"), kc_current_view); }
		kc::unparse(g_fe_selvar_nr, kc_printer, kc_current_view);
		{ kc_printer(kc_t("->prod_sel() == sel_Cons"), kc_current_view); }
		kc::unparse(tid, kc_printer, kc_current_view);
		{ kc_printer(kc_t("\
\n"), kc_current_view); }
	    } else
		    goto kc_unparsing_default;
	    break;
	}
	case view_gen_initializephyla_c_enum: {
	    view_gen_initializephyla_c_class& kc_current_view=static_cast<view_gen_initializephyla_c_class&>(kc_current_view_base);
	    if ((this->idCexpression_1->prod_sel() == sel_IdCexpression)) {
		const ID tid = phylum_cast<const impl_idCexpression_IdCexpression*>(this->idCexpression_1)->ID_1;
		const Cexpression cexpr = phylum_cast<const impl_idCexpression_IdCexpression*>(this->idCexpression_1)->Cexpression_1;
		const idCexpressions t = this->idCexpressions_1;
		kc::unparse(t, kc_printer, kc_current_view);
		g_fe_selvar_nr++; 
		   if (cexpr->line) 
		{
		    if(g_options.linedirec) 
		    {
			kc::unparse(pg_line, kc_printer, kc_current_view);
			kc::unparse(cexpr->line, kc_printer, kc_current_view);
			{ kc_printer(kc_t(" \""), kc_current_view); }
			PRINT(g_options.dir_line.c_str()); 
			kc::unparse(cexpr->file, kc_printer, view_filename);
			{ kc_printer(kc_t("\"\n"), kc_current_view); }
		    }
		}
		kc::unparse(tid, kc_printer, kc_current_view);
		{ kc_printer(kc_t(" kc_fe_selvar_"), kc_current_view); }
		kc::unparse(g_fe_selvar_nr, kc_printer, kc_current_view);
		{ kc_printer(kc_t(" = "), kc_current_view); }
		kc::unparse(cexpr, kc_printer, kc_current_view);
		{ kc_printer(kc_t(";\
\n"), kc_current_view); }
	    } else
		    goto kc_unparsing_default;
	    break;
	}
	case view_check_enum: {
	    view_check_class& kc_current_view=static_cast<view_check_class&>(kc_current_view_base);
	    {
		const idCexpression h = this->idCexpression_1;
		const idCexpressions t = this->idCexpressions_1;
		kc::unparse(t, kc_printer, kc_current_view);
		kc::unparse(h, kc_printer, kc_current_view);
	    }
	    break;
	}

	default:
	kc_unparsing_default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    { /* Alternative( *, args ) -> [view_gen_unparsedefs_default_c: */
		for (idCexpressions iterator_ = this; iterator_->idCexpressions_1 != 0; iterator_ = iterator_->idCexpressions_1)
		    iterator_->idCexpression_1->unparse(kc_printer, kc_current_view);
	    }
	    break;
	}
    }
}

void
impl_idCexpressions::nil_do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case view_gen_initializephyla_update_loop_c_enum: {
	    view_gen_initializephyla_update_loop_c_class& kc_current_view=static_cast<view_gen_initializephyla_update_loop_c_class&>(kc_current_view_base);
	    {
		g_fe_selvar_nr = 0; 
	    }
	    break;
	}
	case view_gen_initializephyla_init_el_c_enum: {
	    view_gen_initializephyla_init_el_c_class& kc_current_view=static_cast<view_gen_initializephyla_init_el_c_class&>(kc_current_view_base);
	    {
		g_fe_selvar_nr = 0; 
	    }
	    break;
	}
	case view_gen_initializephyla_whiletest_c_enum: {
	    view_gen_initializephyla_whiletest_c_class& kc_current_view=static_cast<view_gen_initializephyla_whiletest_c_class&>(kc_current_view_base);
	    {
		g_fe_selvar_nr = 0; 
	    }
	    break;
	}
	case view_gen_initializephyla_c_enum: {
	    view_gen_initializephyla_c_class& kc_current_view=static_cast<view_gen_initializephyla_c_class&>(kc_current_view_base);
	    {
		g_fe_selvar_nr = 0; 
	    }
	    break;
	}

	default:
	kc_unparsing_default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    { /* Alternative( *, args ) -> [view_gen_unparsedefs_default_c: */
	    }
	    break;
	}
    }
}


void
impl_idCexpression_IdCexpression::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case view_check_enum: {
	    view_check_class& kc_current_view=static_cast<view_check_class&>(kc_current_view_base);
	    {
		const ID t = this->ID_1;
		f_useoccurlistphylum( t ); 
	    }
	    break;
	}

	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    { /* Alternative( *, args ) -> [view_gen_unparsedefs_default_c: */
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}

void
impl_Ctexts::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    if(is_nil())
	nil_do_unparse(kc_printer, kc_current_view_base);
    else
	switch(kc_current_view_base) {
	case view_gen_initializephyla_c_enum: {
	    view_gen_initializephyla_c_class& kc_current_view=static_cast<view_gen_initializephyla_c_class&>(kc_current_view_base);
	    {
		const Ctext ct = this->Ctext_1;
		const Ctexts cts = this->Ctexts_1;
		ID selvar; 
		kc::unparse(cts, kc_printer, kc_current_view);
		selvar = Id(Str(mkcasestring("kc_x")));
		selvar->line = ct->line; 
		selvar->file = ct->file;

		dollarvarstack.push( selvar );
		dollarvarextstack.push( f_emptyId() );
		operatorstack.push( f_emptyId() );

		if(g_options.linedirec) 
		{
		    kc::unparse(pg_line, kc_printer, kc_current_view);
		    kc::unparse(ct->line, kc_printer, kc_current_view);
		    { kc_printer(kc_t(" \""), kc_current_view); }
		    PRINT(g_options.dir_line.c_str()); 
		    kc::unparse(ct->file, kc_printer, view_filename);
		    { kc_printer(kc_t("\"\n"), kc_current_view); }
		}
		kc::unparse(ct, kc_printer, kc_current_view);
		kc::unparse(g_emptystring, kc_printer, view_printer_outputfileline);

		dollarvarstack.pop();
		dollarvarextstack.pop();
		operatorstack.pop();

	    }
	    break;
	}

	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    { /* Alternative( *, args ) -> [view_gen_unparsedefs_default_c: */
		for (Ctexts iterator_ = this; iterator_->Ctexts_1 != 0; iterator_ = iterator_->Ctexts_1)
		    iterator_->Ctext_1->unparse(kc_printer, kc_current_view);
	    }
	    break;
	}
    }
}

void
impl_Ctexts::nil_do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case view_gen_initializephyla_c_enum: {
	    view_gen_initializephyla_c_class& kc_current_view=static_cast<view_gen_initializephyla_c_class&>(kc_current_view_base);
	    {
	    }
	    break;
	}

	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    { /* Alternative( *, args ) -> [view_gen_unparsedefs_default_c: */
	    }
	    break;
	}
    }
}

void
impl_includefiles::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    if(is_nil())
	nil_do_unparse(kc_printer, kc_current_view_base);
    else
	switch(kc_current_view_base) {

	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    { /* Alternative( *, args ) -> [view_gen_unparsedefs_default_c: */
		for (includefiles iterator_ = this; iterator_->includefiles_1 != 0; iterator_ = iterator_->includefiles_1)
		    iterator_->includefile_1->unparse(kc_printer, kc_current_view);
	    }
	    break;
	}
    }
}

void
impl_includefiles::nil_do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    { /* Alternative( *, args ) -> [view_gen_unparsedefs_default_c: */
	    }
	    break;
	}
    }
}


void
impl_includefile_IncludeFile::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    { /* Alternative( *, args ) -> [view_gen_unparsedefs_default_c: */
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}

void
impl_includedeclarations::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    if(is_nil())
	nil_do_unparse(kc_printer, kc_current_view_base);
    else
	switch(kc_current_view_base) {
	case view_do_gen_includes_enum: {
	    view_do_gen_includes_class& kc_current_view=static_cast<view_do_gen_includes_class&>(kc_current_view_base);
	    {
		const includedeclaration e = this->includedeclaration_1;
		const includedeclarations l = this->includedeclarations_1;
		kc::unparse(l, kc_printer, kc_current_view);
		kc::unparse(e, kc_printer, kc_current_view);
	    }
	    break;
	}
	case view_gen_includes_enum: {
	    view_gen_includes_class& kc_current_view=static_cast<view_gen_includes_class&>(kc_current_view_base);
	    {
		{ kc_printer(kc_t("namespace kc { }\
\nusing namespace kc;\
\n/* included stuff */\
\n"), kc_current_view); }
		kc::unparse(this, kc_printer, view_do_gen_includes);
		{ kc_printer(kc_t("/* end included stuff */\
\n\
\n"), kc_current_view); }
	    }
	    break;
	}

	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    { /* Alternative( *, args ) -> [view_gen_unparsedefs_default_c: */
		for (includedeclarations iterator_ = this; iterator_->includedeclarations_1 != 0; iterator_ = iterator_->includedeclarations_1)
		    iterator_->includedeclaration_1->unparse(kc_printer, kc_current_view);
	    }
	    break;
	}
    }
}

void
impl_includedeclarations::nil_do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case view_do_gen_includes_enum: {
	    view_do_gen_includes_class& kc_current_view=static_cast<view_do_gen_includes_class&>(kc_current_view_base);
	    {
	    }
	    break;
	}
	case view_gen_includes_enum: {
	    view_gen_includes_class& kc_current_view=static_cast<view_gen_includes_class&>(kc_current_view_base);
	    {
	    }
	    break;
	}

	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    { /* Alternative( *, args ) -> [view_gen_unparsedefs_default_c: */
	    }
	    break;
	}
    }
}


void
impl_includedeclaration_IncludeDeclaration::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case view_do_gen_includes_enum: {
	    view_do_gen_includes_class& kc_current_view=static_cast<view_do_gen_includes_class&>(kc_current_view_base);
	    {
		const casestring i = this->casestring_1;
		if(g_options.linedirec) 
		{
		    kc::unparse(pg_line, kc_printer, kc_current_view);
		    kc::unparse(this->line, kc_printer, kc_current_view);
		    { kc_printer(kc_t(" \""), kc_current_view); }
		    PRINT(g_options.dir_line.c_str()); 
		    kc::unparse(this->file, kc_printer, view_filename);
		    { kc_printer(kc_t("\"\n"), kc_current_view); }
		}
		kc::unparse(i, kc_printer, kc_current_view);
		kc::unparse(g_emptystring, kc_printer, view_printer_outputfileline);
	    }
	    break;
	}

	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    { /* Alternative( *, args ) -> [view_gen_unparsedefs_default_c: */
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}

void
impl_rwdeclarations::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    if(is_nil())
	nil_do_unparse(kc_printer, kc_current_view_base);
    else
	switch(kc_current_view_base) {
	case view_check_enum: {
	    view_check_class& kc_current_view=static_cast<view_check_class&>(kc_current_view_base);
	    {
		const rwdeclaration rwd = this->rwdeclaration_1;
		const rwdeclarations rrwd = this->rwdeclarations_1;
		kc::unparse(rrwd, kc_printer, kc_current_view);
		kc::unparse(rwd, kc_printer, kc_current_view);
	    }
	    break;
	}

	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    { /* Alternative( *, args ) -> [view_gen_unparsedefs_default_c: */
		for (rwdeclarations iterator_ = this; iterator_->rwdeclarations_1 != 0; iterator_ = iterator_->rwdeclarations_1)
		    iterator_->rwdeclaration_1->unparse(kc_printer, kc_current_view);
	    }
	    break;
	}
    }
}

void
impl_rwdeclarations::nil_do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case view_check_enum: {
	    view_check_class& kc_current_view=static_cast<view_check_class&>(kc_current_view_base);
	    {
	    }
	    break;
	}

	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    { /* Alternative( *, args ) -> [view_gen_unparsedefs_default_c: */
	    }
	    break;
	}
    }
}


void
impl_rwdeclaration_RwDeclaration::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case view_make_patternreps_enum: {
	    view_make_patternreps_class& kc_current_view=static_cast<view_make_patternreps_class&>(kc_current_view_base);
	    {
		const outmostpatterns op = this->outmostpatterns_1;
		const rewriteclauses rc = this->rewriteclauses_1;
		v_resetbindingidmarks();

		v_add_rewriterulesinfo_to_operator(
		    add_predicates_to_patternrepresentations( syn_outmostpatterns( op ) ), rc );

	    }
	    break;
	}
	case view_check_enum: {
	    view_check_class& kc_current_view=static_cast<view_check_class&>(kc_current_view_base);
	    {
		const outmostpatterns op = this->outmostpatterns_1;
		const rewriteclauses rc = this->rewriteclauses_1;
		outmostoperators.push( Niloperators() );
		dollarvarsallowed.push( DVAllowed() );
		phylumstack.push( f_emptyId() );
		variablesstack.push( Nilvariables());
		cl_scope++;

		kc::unparse(op, kc_printer, kc_current_view);
		kc::unparse(rc, kc_printer, kc_current_view);
		outmostoperators.top()->freelist();
		outmostoperators.pop(); phylumstack.pop();
		dollarvarsallowed.pop();
		v_reset_variables_type( variablesstack.top() );
		cl_scope--;
		variablesstack.top()->freelist();
		variablesstack.pop();

	    }
	    break;
	}

	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    { /* Alternative( *, args ) -> [view_gen_unparsedefs_default_c: */
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}

void
impl_rewriteclauses::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    if(is_nil())
	nil_do_unparse(kc_printer, kc_current_view_base);
    else
	switch(kc_current_view_base) {
	case view_check_enum: {
	    view_check_class& kc_current_view=static_cast<view_check_class&>(kc_current_view_base);
	    {
		const rewriteclause rc = this->rewriteclause_1;
		const rewriteclauses rcs = this->rewriteclauses_1;
		kc::unparse(rcs, kc_printer, kc_current_view);
		kc::unparse(rc, kc_printer, kc_current_view);
	    }
	    break;
	}

	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    { /* Alternative( *, args ) -> [view_gen_unparsedefs_default_c: */
		for (rewriteclauses iterator_ = this; iterator_->rewriteclauses_1 != 0; iterator_ = iterator_->rewriteclauses_1)
		    iterator_->rewriteclause_1->unparse(kc_printer, kc_current_view);
	    }
	    break;
	}
    }
}

void
impl_rewriteclauses::nil_do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case view_check_enum: {
	    view_check_class& kc_current_view=static_cast<view_check_class&>(kc_current_view_base);
	    {
	    }
	    break;
	}

	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    { /* Alternative( *, args ) -> [view_gen_unparsedefs_default_c: */
	    }
	    break;
	}
    }
}


void
impl_rewriteclause_RewriteClause::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case view_check_enum: {
	    view_check_class& kc_current_view=static_cast<view_check_class&>(kc_current_view_base);
	    {
		const viewnames vn = this->viewnames_1;
		kc::unparse(vn, kc_printer, view_check_r);
	    }
	    break;
	}

	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    { /* Alternative( *, args ) -> [view_gen_unparsedefs_default_c: */
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}

void
impl_patternchains::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    if(is_nil())
	nil_do_unparse(kc_printer, kc_current_view_base);
    else
	switch(kc_current_view_base) {
	case view_set_type_enum: {
	    view_set_type_class& kc_current_view=static_cast<view_set_type_class&>(kc_current_view_base);
	    {
		const patternchain h = this->patternchain_1;
		const patternchains t = this->patternchains_1;
		kc::unparse(t, kc_printer, kc_current_view);
		kc::unparse(h, kc_printer, kc_current_view);
	    }
	    break;
	}
	case view_check_enum: {
	    view_check_class& kc_current_view=static_cast<view_check_class&>(kc_current_view_base);
	    {
		const patternchain h = this->patternchain_1;
		const patternchains t = this->patternchains_1;
		kc::unparse(t, kc_printer, kc_current_view);
		kc::unparse(h, kc_printer, kc_current_view);
	    }
	    break;
	}

	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    { /* Alternative( *, args ) -> [view_gen_unparsedefs_default_c: */
		for (patternchains iterator_ = this; iterator_->patternchains_1 != 0; iterator_ = iterator_->patternchains_1)
		    iterator_->patternchain_1->unparse(kc_printer, kc_current_view);
	    }
	    break;
	}
    }
}

void
impl_patternchains::nil_do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case view_set_type_enum: {
	    view_set_type_class& kc_current_view=static_cast<view_set_type_class&>(kc_current_view_base);
	    {
	    }
	    break;
	}
	case view_check_enum: {
	    view_check_class& kc_current_view=static_cast<view_check_class&>(kc_current_view_base);
	    {
	    }
	    break;
	}

	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    { /* Alternative( *, args ) -> [view_gen_unparsedefs_default_c: */
	    }
	    break;
	}
    }
}

void
impl_patternchain::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    if(is_nil())
	nil_do_unparse(kc_printer, kc_current_view_base);
    else
	switch(kc_current_view_base) {
	case view_set_type_enum: {
	    view_set_type_class& kc_current_view=static_cast<view_set_type_class&>(kc_current_view_base);
	    {
		const patternchainitem h = this->patternchainitem_1;
		const patternchain t = this->patternchain_1;
		ID tmp_type = 0;
		phylumnames tmp_types = 0;
		{
		    phylumnames kc_selvar_0_1 = phylum_cast<phylumnames>( phylumnamesstack.top() );
		    if ((kc_selvar_0_1->prod_sel() == sel_Nilphylumnames)) {

			tmp_type = f_emptyId();
			tmp_types = Nilphylumnames();

		    } else
			if ((kc_selvar_0_1->prod_sel() == sel_Consphylumnames)) {
			const ID p_h = (kc_selvar_0_1)->ID_1;
			const phylumnames p_t = (kc_selvar_0_1)->phylumnames_1;

			tmp_type = p_h;
			tmp_types = p_t;

		    } else
			kc_no_default_in_with( "", __LINE__, __FILE__ );
		}
		phylumnamesstack.pop();
		phylumnamesstack.push( tmp_types );

		kc::unparse(t, kc_printer, kc_current_view);
		tmp_types = phylumnamesstack.top();
		phylumnamesstack.pop();
		phylumstack.push( tmp_type );
		if (! phylumstack.top()->eq( f_emptyId() )) {
		    h->type = phylumstack.top();

		}

		kc::unparse(h, kc_printer, kc_current_view);
		tmp_type = phylumstack.top();
		phylumstack.pop();
		phylumnamesstack.push( Consphylumnames( tmp_type, tmp_types ) );

	    }
	    break;
	}
	case view_check_enum: {
	    view_check_class& kc_current_view=static_cast<view_check_class&>(kc_current_view_base);
	    if ((this->patternchainitem_1->prod_sel() == sel_PatternchainitemOutmost) && (phylum_cast<const impl_patternchainitem_PatternchainitemOutmost*>(this->patternchainitem_1)->outmostpattern_1->prod_sel() == sel_OPDefault) && (this->patternchain_1->prod_sel() == sel_Conspatternchain) && ((this->patternchain_1)->patternchainitem_1->prod_sel() == sel_PatternchainitemOutmost) && (phylum_cast<const impl_patternchainitem_PatternchainitemOutmost*>((this->patternchain_1)->patternchainitem_1)->outmostpattern_1->prod_sel() == sel_OPDefault)) {
		const patternchainitem p = this->patternchainitem_1;
		v_report(NonFatal( FileLine( p->file, p->line ),
			Problem1S( "'default' can not be &-ed with (other) patterns")));

	    } else
		if ((this->patternchainitem_1->prod_sel() == sel_PatternchainitemOutmost) && (phylum_cast<const impl_patternchainitem_PatternchainitemOutmost*>(this->patternchainitem_1)->outmostpattern_1->prod_sel() == sel_OPDefault) && (this->patternchain_1->prod_sel() == sel_Nilpatternchain)) {
	    } else
		if ((this->patternchainitem_1->prod_sel() == sel_PatternchainitemOutmost) && (phylum_cast<const impl_patternchainitem_PatternchainitemOutmost*>(this->patternchainitem_1)->outmostpattern_1->prod_sel() == sel_OPDefault) && (this->patternchain_1->prod_sel() == sel_Conspatternchain)) {
		const patternchainitem p = this->patternchainitem_1;
		v_report(NonFatal( FileLine( p->file, p->line ),
			Problem1S( "'default' can not be &-ed with (other) patterns")));

	    } else
		if ((this->patternchain_1->prod_sel() == sel_Conspatternchain) && ((this->patternchain_1)->patternchainitem_1->prod_sel() == sel_PatternchainitemOutmost) && (phylum_cast<const impl_patternchainitem_PatternchainitemOutmost*>((this->patternchain_1)->patternchainitem_1)->outmostpattern_1->prod_sel() == sel_OPDefault)) {
		const patternchainitem p = (this->patternchain_1)->patternchainitem_1;
		v_report(NonFatal( FileLine( p->file, p->line ),
			Problem1S( "'default' can not be &-ed with (other) patterns")));

	    } else
	    {
		const patternchain p = this/**/;
		const patternchainitem h = this->patternchainitem_1;
		const patternchain t = this->patternchain_1;
		ID tmp_type = 0;
		phylumnames tmp_types = 0;
		{
		    phylumnames kc_selvar_0_1 = phylum_cast<phylumnames>( phylumnamesstack.top() );
		    if ((kc_selvar_0_1->prod_sel() == sel_Nilphylumnames)) {

			tmp_type = f_emptyId();
			tmp_types = Nilphylumnames();
			v_report(NonFatal( FileLine( p->file, p->line ),
				Problem1S( "more &-ed patterns than expressions")));

		    } else
			if ((kc_selvar_0_1->prod_sel() == sel_Consphylumnames)) {
			const ID p_h = (kc_selvar_0_1)->ID_1;
			const phylumnames p_t = (kc_selvar_0_1)->phylumnames_1;

			tmp_type = p_h;
			tmp_types = p_t;

		    } else
			kc_no_default_in_with( "", __LINE__, __FILE__ );
		}
		phylumnamesstack.pop();
		phylumnamesstack.push( tmp_types );

		kc::unparse(t, kc_printer, kc_current_view);
		tmp_types = phylumnamesstack.top();
		phylumnamesstack.pop();
		phylumstack.push( tmp_type ); 
		kc::unparse(h, kc_printer, kc_current_view);
		tmp_type = phylumstack.top();
		phylumstack.pop();
		phylumnamesstack.push( Consphylumnames( tmp_type, tmp_types ) );

	    }
	    break;
	}

	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    { /* Alternative( *, args ) -> [view_gen_unparsedefs_default_c: */
		for (patternchain iterator_ = this; iterator_->patternchain_1 != 0; iterator_ = iterator_->patternchain_1)
		    iterator_->patternchainitem_1->unparse(kc_printer, kc_current_view);
	    }
	    break;
	}
    }
}

void
impl_patternchain::nil_do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case view_set_type_enum: {
	    view_set_type_class& kc_current_view=static_cast<view_set_type_class&>(kc_current_view_base);
	    {
	    }
	    break;
	}
	case view_check_enum: {
	    view_check_class& kc_current_view=static_cast<view_check_class&>(kc_current_view_base);
	    {
		const patternchain p = this/**/;
		{
		    phylumnames kc_selvar_0_1 = phylum_cast<phylumnames>( phylumnamesstack.top() );
		    if ((kc_selvar_0_1->prod_sel() == sel_Nilphylumnames)) {
			/* EMPTY */ 
				} else
			if ((kc_selvar_0_1->prod_sel() == sel_Consphylumnames)) {
			const ID p_h = (kc_selvar_0_1)->ID_1;
			const phylumnames p_t = (kc_selvar_0_1)->phylumnames_1;

			v_report(NonFatal( FileLine( p->file, p->line ),
				Problem1S( "fewer &-ed patterns than expressions")));

		    } else
			kc_no_default_in_with( "", __LINE__, __FILE__ );
		}

	    }
	    break;
	}

	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    { /* Alternative( *, args ) -> [view_gen_unparsedefs_default_c: */
	    }
	    break;
	}
    }
}

void
impl_outmostpatterns::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    if(is_nil())
	nil_do_unparse(kc_printer, kc_current_view_base);
    else
	switch(kc_current_view_base) {
	case view_check_enum: {
	    view_check_class& kc_current_view=static_cast<view_check_class&>(kc_current_view_base);
	    {
		const outmostpattern p = this->outmostpattern_1;
		const outmostpatterns rp = this->outmostpatterns_1;
		kc::unparse(rp, kc_printer, kc_current_view);
		kc::unparse(p, kc_printer, kc_current_view);
	    }
	    break;
	}

	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    { /* Alternative( *, args ) -> [view_gen_unparsedefs_default_c: */
		for (outmostpatterns iterator_ = this; iterator_->outmostpatterns_1 != 0; iterator_ = iterator_->outmostpatterns_1)
		    iterator_->outmostpattern_1->unparse(kc_printer, kc_current_view);
	    }
	    break;
	}
    }
}

void
impl_outmostpatterns::nil_do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case view_check_enum: {
	    view_check_class& kc_current_view=static_cast<view_check_class&>(kc_current_view_base);
	    {
	    }
	    break;
	}

	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    { /* Alternative( *, args ) -> [view_gen_unparsedefs_default_c: */
	    }
	    break;
	}
    }
}


void
impl_patternchainitem_PatternchainitemDollarid::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    { /* Alternative( *, args ) -> [view_gen_unparsedefs_default_c: */
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


void
impl_patternchainitem_PatternchainitemGroup::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case view_set_type_enum: {
	    view_set_type_class& kc_current_view=static_cast<view_set_type_class&>(kc_current_view_base);
	    {
		const patternchains mp = this->patternchains_1;
	    }
	    break;
	}
	case view_check_enum: {
	    view_check_class& kc_current_view=static_cast<view_check_class&>(kc_current_view_base);
	    {
		const patternchainitem mpg = this/**/;
		const patternchains mp = this->patternchains_1;
		v_report( NonFatal(  FileLine( mpg->file, mpg->line ),
			Problem1S( "Internal Error: PatternchainitemGroup was not handled correctly" )));

	    }
	    break;
	}

	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    { /* Alternative( *, args ) -> [view_gen_unparsedefs_default_c: */
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


void
impl_patternchainitem_PatternchainitemOutmost::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case view_set_type_enum: {
	    view_set_type_class& kc_current_view=static_cast<view_set_type_class&>(kc_current_view_base);
	    {
		const outmostpattern p = this->outmostpattern_1;
		if (! phylumstack.top()->eq( f_emptyId() )) 
		{
		    p->type = phylumstack.top();

		}
	    }
	    break;
	}
	case view_check_enum: {
	    view_check_class& kc_current_view=static_cast<view_check_class&>(kc_current_view_base);
	    {
		const outmostpattern p = this->outmostpattern_1;
		if (inforeachcontext.top()!=0) 
		{
		    kc::unparse(p, kc_printer, view_check_is_var);
		}
		else
		{
		    kc::unparse(p, kc_printer, view_check_outmostopers_in_phylum);
		}
	    }
	    break;
	}

	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    { /* Alternative( *, args ) -> [view_gen_unparsedefs_default_c: */
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


void
impl_outmostpattern_OPDefault::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case view_check_is_var_enum: {
	    view_check_is_var_class& kc_current_view=static_cast<view_check_is_var_class&>(kc_current_view_base);
	    {
	    }
	    break;
	}
	case view_check_enum: {
	    view_check_class& kc_current_view=static_cast<view_check_class&>(kc_current_view_base);
	    {
	    }
	    break;
	}

	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    { /* Alternative( *, args ) -> [view_gen_unparsedefs_default_c: */
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


void
impl_outmostpattern_OPWildcard::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case view_check_is_var_enum: {
	    view_check_is_var_class& kc_current_view=static_cast<view_check_is_var_class&>(kc_current_view_base);
	    {
	    }
	    break;
	}
	case view_check_enum: {
	    view_check_class& kc_current_view=static_cast<view_check_class&>(kc_current_view_base);
	    {
	    }
	    break;
	}

	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    { /* Alternative( *, args ) -> [view_gen_unparsedefs_default_c: */
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


void
impl_outmostpattern_OPNonLeafVariable::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case view_check_is_var_enum: {
	    view_check_is_var_class& kc_current_view=static_cast<view_check_is_var_class&>(kc_current_view_base);
	    {
	    }
	    break;
	}
	case view_check_outmostopers_in_phylum_enum: {
	    view_check_outmostopers_in_phylum_class& kc_current_view=static_cast<view_check_outmostopers_in_phylum_class&>(kc_current_view_base);
	    {
		const ID v = this->ID_1;
		const outmostpattern p = this->outmostpattern_1;
		variables tmp = Consvariables( v, variablesstack.top() );
		ID tmp_pid = f_phylumofoutmostpattern( p );
		ID tmp_vid = f_phylumofpatternvariable( v );
		ID tmp_resid = tmp_pid->eq(f_emptyId() ) ? tmp_vid : tmp_pid;
		if ( phylumstack.top()->eq(f_emptyId()) ) {
		    phylumstack.pop();
		    phylumstack.push( tmp_resid );
		}
		variablesstack.pop(); variablesstack.push( tmp );
		v_extendoccur( v, ITPatternVariable( tmp_resid, mkinteger(cl_scope)));

		kc::unparse(p, kc_printer, view_check);
	    }
	    break;
	}
	case view_check_enum: {
	    view_check_class& kc_current_view=static_cast<view_check_class&>(kc_current_view_base);
	    {
		const ID v = this->ID_1;
		const outmostpattern p = this->outmostpattern_1;
		variables tmp = Consvariables( v, variablesstack.top() );
		variablesstack.pop(); variablesstack.push( tmp );
		v_extendoccur( v, ITPatternVariable( f_phylumofoutmostpattern( p ),
			mkinteger(cl_scope)));

		kc::unparse(p, kc_printer, kc_current_view);
	    }
	    break;
	}

	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    { /* Alternative( *, args ) -> [view_gen_unparsedefs_default_c: */
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


void
impl_outmostpattern_OPOperator::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case view_check_is_var_enum: {
	    view_check_is_var_class& kc_current_view=static_cast<view_check_is_var_class&>(kc_current_view_base);
	    {
	    }
	    break;
	}
	case view_check_outmostopers_in_phylum_enum: {
	    view_check_outmostopers_in_phylum_class& kc_current_view=static_cast<view_check_outmostopers_in_phylum_class&>(kc_current_view_base);
	    {
		const ID o = this->ID_1;
		const patterns p = this->patterns_1;
		if (f_useoccuroperator( o )) 
		{
		    if ( phylumstack.top()->eq( f_emptyId() )) {
			phylumstack.pop();
			phylumstack.push( f_phylumofoperator( o ) );
		    }		
		    		if (f_operatorinphylum( o, phylumstack.top())) 
		    {
			operators tmp = Consoperators( o, outmostoperators.top() );
			outmostoperators.pop();
			outmostoperators.push( tmp );
			argumentsstack.push( f_argumentsofoperator( o )->reverse());
			operatorstack.push( o );

			kc::unparse(p, kc_printer, view_check);
			if (! f_Nilarguments( argumentsstack.top() )) {
			    v_report(NonFatal( FileLine( o->file, o->line ),
				    Problem1S1ID( "too few subpatterns for operator", o )));
			}
			argumentsstack.pop();
			operatorstack.pop();

		    }
		    else {
			v_report(NonFatal( FileLine( o->file, o->line ),
				Problem1S1ID1S1ID( "outermost operator", o,
				    "not in expected phylum", phylumstack.top() )));
		    }		
		     }
	    }
	    break;
	}
	case view_check_enum: {
	    view_check_class& kc_current_view=static_cast<view_check_class&>(kc_current_view_base);
	    {
		const ID o = this->ID_1;
		const patterns p = this->patterns_1;
		if (f_useoccuroperator( o )) 
		{
		    if ( phylumstack.top()->eq( f_emptyId() )) {
			phylumstack.pop();
			phylumstack.push( f_phylumofoperator( o ) );
		    }		
		    {
			operators tmp = Consoperators( o, outmostoperators.top() );
			outmostoperators.pop();
			outmostoperators.push( tmp );
			argumentsstack.push( f_argumentsofoperator( o )->reverse());
			operatorstack.push( o );

			kc::unparse(p, kc_printer, kc_current_view);
			if (! f_Nilarguments( argumentsstack.top() )) {
			    v_report(NonFatal( FileLine( o->file, o->line ),
				    Problem1S1ID( "too few subpatterns for operator", o )));
			}
			argumentsstack.pop();
			operatorstack.pop();

		    }
		}
	    }
	    break;
	}

	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    { /* Alternative( *, args ) -> [view_gen_unparsedefs_default_c: */
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


void
impl_outmostpattern_OPOperatorWildcard::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case view_check_is_var_enum: {
	    view_check_is_var_class& kc_current_view=static_cast<view_check_is_var_class&>(kc_current_view_base);
	    {
		const ID i = this->ID_1;
		f_warnifnotvariable( i ); 
	    }
	    break;
	}
	case view_check_outmostopers_in_phylum_enum: {
	    view_check_outmostopers_in_phylum_class& kc_current_view=static_cast<view_check_outmostopers_in_phylum_class&>(kc_current_view_base);
	    {
		const ID o = this->ID_1;
		if (f_useoccuroperator( o )) {
		    if ( phylumstack.top()->eq(f_emptyId() )) {
			phylumstack.pop();
			phylumstack.push( f_phylumofoperator( o ) );
		    }
		    if (! f_operatorinphylum( o, phylumstack.top())) {
			v_report(NonFatal( FileLine( o->file, o->line ),
				Problem1S1ID1S1ID( "outermost operator", o,
				    "not in expected phylum",
				    phylumstack.top() )));
		    } else {
			operators tmp = Consoperators( o, outmostoperators.top() );
			outmostoperators.pop();
			outmostoperators.push( tmp );
		    }
		}

	    }
	    break;
	}
	case view_check_enum: {
	    view_check_class& kc_current_view=static_cast<view_check_class&>(kc_current_view_base);
	    {
		const ID o = this->ID_1;
		if (f_useoccuroperator( o )) {
		    if ( phylumstack.top()->eq( f_emptyId() )) {
			phylumstack.pop();
			phylumstack.push( f_phylumofoperator( o ) );
		    }
		    {	operators tmp = Consoperators( o, outmostoperators.top() );
			outmostoperators.pop();
			outmostoperators.push( tmp );
		    }
		}

	    }
	    break;
	}

	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    { /* Alternative( *, args ) -> [view_gen_unparsedefs_default_c: */
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


void
impl_pattern_PIntLiteral::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case view_check_enum: {
	    view_check_class& kc_current_view=static_cast<view_check_class&>(kc_current_view_base);
	    {
		const INT i = this->INT_1;
		if ((! f_hd_arguments( argumentsstack.top() )->eq(Id( Str( mkcasestring( "integer" ))))) &&
		    (! f_hd_arguments( argumentsstack.top() )->eq(Id( Str( mkcasestring( "real" ))))) ) {
		    v_report(NonFatal( FileLine( i->file, i->line ),
			    Problem1S( "unexpected int subterm" )));
		}

	    }
	    break;
	}

	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    { /* Alternative( *, args ) -> [view_gen_unparsedefs_default_c: */
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


void
impl_pattern_PStringLiteral::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case view_check_enum: {
	    view_check_class& kc_current_view=static_cast<view_check_class&>(kc_current_view_base);
	    {
		if ( (! f_hd_arguments( argumentsstack.top() )->eq(Id( Str( mkcasestring( "casestring" ))))) &&
		    (! f_hd_arguments( argumentsstack.top() )->eq(Id( Str( mkcasestring( "nocasestring" ))))))
		{
		    v_report(NonFatal( FileLine( operatorstack.top()->file, operatorstack.top()->line ),
			    Problem1S( "unexpected string subterm" )));
		}

	    }
	    break;
	}

	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    { /* Alternative( *, args ) -> [view_gen_unparsedefs_default_c: */
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


void
impl_pattern_PWildcard::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case view_check_enum: {
	    view_check_class& kc_current_view=static_cast<view_check_class&>(kc_current_view_base);
	    {
	    }
	    break;
	}

	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    { /* Alternative( *, args ) -> [view_gen_unparsedefs_default_c: */
	    }
	    break;
	}
    }
}


void
impl_pattern_PNonLeafVariable::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case view_check_enum: {
	    view_check_class& kc_current_view=static_cast<view_check_class&>(kc_current_view_base);
	    {
		const ID v = this->ID_1;
		const pattern p = this->pattern_1;
		variables tmp = Consvariables( v, variablesstack.top() );
		variablesstack.pop();
		variablesstack.push( tmp );
		v_extendoccur( v, ITPatternVariable( f_hd_arguments( argumentsstack.top() ),
			mkinteger(cl_scope) ));

		kc::unparse(p, kc_printer, kc_current_view);
	    }
	    break;
	}

	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    { /* Alternative( *, args ) -> [view_gen_unparsedefs_default_c: */
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


void
impl_pattern_POperator::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case view_check_enum: {
	    view_check_class& kc_current_view=static_cast<view_check_class&>(kc_current_view_base);
	    {
		const ID o = this->ID_1;
		const patterns p = this->patterns_1;
		if (f_useoccuroperator( o )) 
		{
		    if (f_Nilarguments( argumentsstack.top() )) {
			ID o = operatorstack.top();
			v_report(NonFatal( FileLine( o->file, o->line ),
				Problem1S1ID( "too many subpatterns for operator", o )));
		    } else if (f_operatorinphylum( o, f_hd_arguments( argumentsstack.top() ))) 
		    {
			argumentsstack.push( f_argumentsofoperator( o )->reverse());
			operatorstack.push( o );

			kc::unparse(p, kc_printer, kc_current_view);
			if (! f_Nilarguments( argumentsstack.top() )) {
			    v_report(NonFatal( FileLine( o->file, o->line ),
				    Problem1S1ID( "too few subpatterns for operator", o )));
			}
			argumentsstack.pop();
			operatorstack.pop();

		    }
		    else
		    {
			v_report(NonFatal( FileLine( o->file, o->line ),
				Problem1S1ID1S1ID( "operator", o, "not in phylum",
				    f_hd_arguments( argumentsstack.top() ) )));

		    }
		}
	    }
	    break;
	}

	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    { /* Alternative( *, args ) -> [view_gen_unparsedefs_default_c: */
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


void
impl_pattern_PVariable::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case view_check_enum: {
	    view_check_class& kc_current_view=static_cast<view_check_class&>(kc_current_view_base);
	    {
		const ID v = this->ID_1;
		variables tmp = Consvariables( v, variablesstack.top() );
		variablesstack.pop();
		variablesstack.push( tmp );
		v_extendoccur( v, ITPatternVariable( f_hd_arguments( argumentsstack.top() ),
			mkinteger(cl_scope) ));

	    }
	    break;
	}

	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    { /* Alternative( *, args ) -> [view_gen_unparsedefs_default_c: */
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}

void
impl_patterns::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    if(is_nil())
	nil_do_unparse(kc_printer, kc_current_view_base);
    else
	switch(kc_current_view_base) {
	case view_check_enum: {
	    view_check_class& kc_current_view=static_cast<view_check_class&>(kc_current_view_base);
	    {
		const pattern p = this->pattern_1;
		const patterns rp = this->patterns_1;
		kc::unparse(rp, kc_printer, kc_current_view);
		if (f_Nilarguments( argumentsstack.top() )) {
		    ID o = operatorstack.top();
		    v_report(NonFatal( FileLine( o->file, o->line ),
			    Problem1S1ID( "too many subpatterns for operator", o )));
		} else 
		{
		    arguments tmp;

		    kc::unparse(p, kc_printer, kc_current_view);
		    tmp = argumentsstack.top();
		    argumentsstack.pop();
		    argumentsstack.push( f_tl_arguments( tmp ));

		}
	    }
	    break;
	}

	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    { /* Alternative( *, args ) -> [view_gen_unparsedefs_default_c: */
		for (patterns iterator_ = this; iterator_->patterns_1 != 0; iterator_ = iterator_->patterns_1)
		    iterator_->pattern_1->unparse(kc_printer, kc_current_view);
	    }
	    break;
	}
    }
}

void
impl_patterns::nil_do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case view_check_enum: {
	    view_check_class& kc_current_view=static_cast<view_check_class&>(kc_current_view_base);
	    {
	    }
	    break;
	}

	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    { /* Alternative( *, args ) -> [view_gen_unparsedefs_default_c: */
	    }
	    break;
	}
    }
}


void
impl_term_TIntLiteral::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		const INT i = this->INT_1;
		kc::unparse(i, kc_printer, kc_current_view);
	    }
	    break;
	}
    }
}


void
impl_term_TStringLiteral::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		const CexpressionDQ str = this->CexpressionDQ_1;
		{ kc_printer(kc_t("\""), kc_current_view); }
		kc::unparse(str, kc_printer, kc_current_view);
		{ kc_printer(kc_t("\""), kc_current_view); }
	    }
	    break;
	}
    }
}


void
impl_term_TCTerm::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		const CexpressionSQ Cexpr = this->CexpressionSQ_1;
		kc::unparse(Cexpr, kc_printer, kc_current_view);
	    }
	    break;
	}
    }
}


void
impl_term_TMemberVarDot::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		const term t = this->term_1;
		const ID id = this->ID_1;
		kc::unparse(t, kc_printer, kc_current_view);
		{ kc_printer(kc_t("."), kc_current_view); }
		kc::unparse(id, kc_printer, kc_current_view);
	    }
	    break;
	}
    }
}


void
impl_term_TMemberVar::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		const term t = this->term_1;
		const ID id = this->ID_1;
		kc::unparse(t, kc_printer, kc_current_view);
		{ kc_printer(kc_t("->"), kc_current_view); }
		kc::unparse(id, kc_printer, kc_current_view);
	    }
	    break;
	}
    }
}


void
impl_term_TMethodDot::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		const term t = this->term_1;
		const ID id = this->ID_1;
		const terms ts = this->terms_1;
		kc::unparse(t, kc_printer, kc_current_view);
		{ kc_printer(kc_t("."), kc_current_view); }
		kc::unparse(id, kc_printer, kc_current_view);
		{ kc_printer(kc_t("("), kc_current_view); }
		kc::unparse(ts, kc_printer, kc_current_view);
		{ kc_printer(kc_t(")"), kc_current_view); }
	    }
	    break;
	}
    }
}


void
impl_term_TMethod::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		const term t = this->term_1;
		const ID id = this->ID_1;
		const terms ts = this->terms_1;
		kc::unparse(t, kc_printer, kc_current_view);
		{ kc_printer(kc_t("->"), kc_current_view); }
		kc::unparse(id, kc_printer, kc_current_view);
		{ kc_printer(kc_t("("), kc_current_view); }
		kc::unparse(ts, kc_printer, kc_current_view);
		{ kc_printer(kc_t(")"), kc_current_view); }
	    }
	    break;
	}
    }
}


void
impl_term_TOperator::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		const ID id = this->ID_1;
		const terms t = this->terms_1;
		kc::unparse(id, kc_printer, kc_current_view);
		{ kc_printer(kc_t("("), kc_current_view); }
		kc::unparse(t, kc_printer, kc_current_view);
		{ kc_printer(kc_t(")"), kc_current_view); }
	    }
	    break;
	}
    }
}


void
impl_term_TVariable::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		const ID id = this->ID_1;
		kc::unparse(id, kc_printer, kc_current_view);
	    }
	    break;
	}
    }
}

void
impl_terms::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    if(is_nil())
	nil_do_unparse(kc_printer, kc_current_view_base);
    else
	switch(kc_current_view_base) {

	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    if ((this->terms_1->prod_sel() == sel_Nilterms)) {
		const term t = this->term_1;
		kc::unparse(t, kc_printer, kc_current_view);
	    } else
	    {
		const term t = this->term_1;
		const terms r_t = this->terms_1;
		kc::unparse(r_t, kc_printer, kc_current_view);
		{ kc_printer(kc_t(", "), kc_current_view); }
		kc::unparse(t, kc_printer, kc_current_view);
	    }
	    break;
	}
    }
}

void
impl_terms::nil_do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
	    }
	    break;
	}
    }
}

void
impl_fnfiles::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    if(is_nil())
	nil_do_unparse(kc_printer, kc_current_view_base);
    else
	switch(kc_current_view_base) {

	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		const fnfile f = this->fnfile_1;
		const fnfiles r_f = this->fnfiles_1;
		kc::unparse(r_f, kc_printer, kc_current_view);
		{ kc_printer(kc_t("\t\""), kc_current_view); }
		kc::unparse(f, kc_printer, kc_current_view);
		{ kc_printer(kc_t("\"\n"), kc_current_view); }
	    }
	    break;
	}
    }
}

void
impl_fnfiles::nil_do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
	    }
	    break;
	}
    }
}


void
impl_fnfile_FnFile::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    { /* Alternative( *, args ) -> [view_gen_unparsedefs_default_c: */
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}

void
impl_fndeclarations::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    if(is_nil())
	nil_do_unparse(kc_printer, kc_current_view_base);
    else
	switch(kc_current_view_base) {
	case view_gen_fnk_c_enum: {
	    view_gen_fnk_c_class& kc_current_view=static_cast<view_gen_fnk_c_class&>(kc_current_view_base);
	    {
		const fndeclaration fnd = this->fndeclaration_1;
		const fndeclarations r_fnds = this->fndeclarations_1;
		kc::unparse(r_fnds, kc_printer, kc_current_view);
		kc::unparse(fnd, kc_printer, kc_current_view);
	    }
	    break;
	}
	case view_gen_fnkdecls_c_enum: {
	    view_gen_fnkdecls_c_class& kc_current_view=static_cast<view_gen_fnkdecls_c_class&>(kc_current_view_base);
	    {
		const fndeclaration fnd = this->fndeclaration_1;
		const fndeclarations r_fnds = this->fndeclarations_1;
		kc::unparse(r_fnds, kc_printer, kc_current_view);
		kc::unparse(fnd, kc_printer, kc_current_view);
	    }
	    break;
	}
	case view_gen_fnk_h_enum: {
	    view_gen_fnk_h_class& kc_current_view=static_cast<view_gen_fnk_h_class&>(kc_current_view_base);
	    {
		const fndeclaration fnd = this->fndeclaration_1;
		const fndeclarations r_fnds = this->fndeclarations_1;
		kc::unparse(r_fnds, kc_printer, kc_current_view);
		kc::unparse(fnd, kc_printer, kc_current_view);
	    }
	    break;
	}
	case view_gen_user_assignment_inis_enum: {
	    view_gen_user_assignment_inis_class& kc_current_view=static_cast<view_gen_user_assignment_inis_class&>(kc_current_view_base);
	    if ((this->fndeclaration_1->prod_sel() == sel_AcMemberDeclaration) && (phylum_cast<const impl_fndeclaration_AcMemberDeclaration*>(this->fndeclaration_1)->ac_declarator_1->prod_sel() == sel_AcDeclarator) && (phylum_cast<const impl_ac_declarator_AcDeclarator*>(phylum_cast<const impl_fndeclaration_AcMemberDeclaration*>(this->fndeclaration_1)->ac_declarator_1)->ac_direct_declarator_1->prod_sel() == sel_AcMemberDecl) && (this->fndeclarations_1->prod_sel() == sel_Nilfndeclarations)) {
		const ID a_id = phylum_cast<const impl_ac_direct_declarator_AcMemberDecl*>(phylum_cast<const impl_ac_declarator_AcDeclarator*>(phylum_cast<const impl_fndeclaration_AcMemberDeclaration*>(this->fndeclaration_1)->ac_declarator_1)->ac_direct_declarator_1)->ID_2;
		const ac_constant_expression_option a_cexpr = phylum_cast<const impl_fndeclaration_AcMemberDeclaration*>(this->fndeclaration_1)->ac_constant_expression_option_1;
		kc::unparse(a_id, kc_printer, kc_current_view);
		{ kc_printer(kc_t("("), kc_current_view); }
		kc::unparse(a_cexpr, kc_printer, kc_current_view);
		{ kc_printer(kc_t(")"), kc_current_view); }
	    } else
		if ((this->fndeclaration_1->prod_sel() == sel_AcMemberDeclaration) && (phylum_cast<const impl_fndeclaration_AcMemberDeclaration*>(this->fndeclaration_1)->ac_declarator_1->prod_sel() == sel_AcDeclarator) && (phylum_cast<const impl_ac_declarator_AcDeclarator*>(phylum_cast<const impl_fndeclaration_AcMemberDeclaration*>(this->fndeclaration_1)->ac_declarator_1)->ac_direct_declarator_1->prod_sel() == sel_AcMemberDecl)) {
		const ID a_id = phylum_cast<const impl_ac_direct_declarator_AcMemberDecl*>(phylum_cast<const impl_ac_declarator_AcDeclarator*>(phylum_cast<const impl_fndeclaration_AcMemberDeclaration*>(this->fndeclaration_1)->ac_declarator_1)->ac_direct_declarator_1)->ID_2;
		const ac_constant_expression_option a_cexpr = phylum_cast<const impl_fndeclaration_AcMemberDeclaration*>(this->fndeclaration_1)->ac_constant_expression_option_1;
		const fndeclarations rargs = this->fndeclarations_1;
		kc::unparse(a_id, kc_printer, kc_current_view);
		{ kc_printer(kc_t("("), kc_current_view); }
		kc::unparse(a_cexpr, kc_printer, kc_current_view);
		{ kc_printer(kc_t(")"), kc_current_view); }
		{ kc_printer(kc_t(", "), kc_current_view); }
		kc::unparse(rargs, kc_printer, kc_current_view);
	    } else
		    goto kc_unparsing_default;
	    break;
	}
	case view_gen_operatordefs_hash_c_enum: {
	    view_gen_operatordefs_hash_c_class& kc_current_view=static_cast<view_gen_operatordefs_hash_c_class&>(kc_current_view_base);
	    if ((this->fndeclaration_1->prod_sel() == sel_FnAcDeclaration) && (phylum_cast<const impl_fndeclaration_FnAcDeclaration*>(this->fndeclaration_1)->ac_declarator_1->prod_sel() == sel_AcDeclarator) && (phylum_cast<const impl_ac_declarator_AcDeclarator*>(phylum_cast<const impl_fndeclaration_FnAcDeclaration*>(this->fndeclaration_1)->ac_declarator_1)->ac_direct_declarator_1->prod_sel() == sel_AcQualifiedDeclProto) && (phylum_cast<const impl_ac_direct_declarator_AcQualifiedDeclProto*>(phylum_cast<const impl_ac_declarator_AcDeclarator*>(phylum_cast<const impl_fndeclaration_FnAcDeclaration*>(this->fndeclaration_1)->ac_declarator_1)->ac_direct_declarator_1)->ac_direct_declarator_1->prod_sel() == sel_AcDirectDeclId) && (phylum_cast<const impl_fndeclaration_FnAcDeclaration*>(this->fndeclaration_1)->fnclass_1->prod_sel() == sel_ConstructorFn)) {
		const fndeclaration decl = this->fndeclaration_1;
		const ID oid = phylum_cast<const impl_ac_direct_declarator_AcDirectDeclId*>(phylum_cast<const impl_ac_direct_declarator_AcQualifiedDeclProto*>(phylum_cast<const impl_ac_declarator_AcDeclarator*>(phylum_cast<const impl_fndeclaration_FnAcDeclaration*>(this->fndeclaration_1)->ac_declarator_1)->ac_direct_declarator_1)->ac_direct_declarator_1)->ID_1;
		const ac_parameter_type_list params = phylum_cast<const impl_ac_direct_declarator_AcQualifiedDeclProto*>(phylum_cast<const impl_ac_declarator_AcDeclarator*>(phylum_cast<const impl_fndeclaration_FnAcDeclaration*>(this->fndeclaration_1)->ac_declarator_1)->ac_direct_declarator_1)->ac_parameter_type_list_1;
		const fndeclarations tail = this->fndeclarations_1;
		kc::unparse(tail, kc_printer, kc_current_view);
		{ kc_printer(kc_t("impl_"), kc_current_view); }
		kc::unparse(gl_phylum, kc_printer, kc_current_view);
		if(gl_isnotlist)
		{
		    { kc_printer(kc_t("_"), kc_current_view); }
		    kc::unparse(oid, kc_printer, kc_current_view);
		}
		{ kc_printer(kc_t("*\n"), kc_current_view); }
		kc::unparse(oid, kc_printer, kc_current_view);
		{ kc_printer(kc_t("("), kc_current_view); }
		kc::unparse(gl_args, kc_printer, view_gen_fnarg_and_decls);
		if(gl_no_of_args && !f_no_params(params)) { PRINT(","); } 
		kc::unparse(decl->sorted, kc_printer, view_gen_fnk_c);
		{ kc_printer(kc_t(") {\
\n    "), kc_current_view); }
		kc::unparse(gl_args, kc_printer, view_gen_fnarg_asserts);
		kc::unparse(gl_phylum, kc_printer, kc_current_view);
		{ kc_printer(kc_t(" kc_x=new impl_"), kc_current_view); }
		kc::unparse(gl_phylum, kc_printer, kc_current_view);
		if(gl_isnotlist)
		{
		    { kc_printer(kc_t("_"), kc_current_view); }
		    kc::unparse(oid, kc_printer, kc_current_view);
		}
		{ kc_printer(kc_t("("), kc_current_view); }
		kc::unparse(gl_args, kc_printer, view_gen_argseqnr_rec);
		if(gl_no_of_args && !f_no_params(params)) { PRINT(","); } 
		kc::unparse(decl->sorted, kc_printer, view_gen_fnkargs);
		{ kc_printer(kc_t(");\
\n	KC_COLLECT_STATS0(KC_CREATE_STATS(sel_"), kc_current_view); }
		kc::unparse(oid, kc_printer, kc_current_view);
		{ kc_printer(kc_t("));\
\n    "), kc_current_view); }
		kc::unparse(gl_phylum, kc_printer, kc_current_view);
		{ kc_printer(kc_t(" unique_kc_x= hashtables["), kc_current_view); }
		kc::unparse(gl_sto, kc_printer, kc_current_view);
		{ kc_printer(kc_t("]->ht_check_insert(kc_x);\
\n    if(unique_kc_x!=kc_x) {\
\n    "), kc_current_view); }
		if(!g_options.smart_pointer) 
		{
		    { kc_printer(kc_t("	delete kc_x;\n"), kc_current_view); }
		}
		else 
		{
		    { kc_printer(kc_t("	// kc_x already deleted in ht_check_insert\n"), kc_current_view); }
		}
		{ kc_printer(kc_t("	kc_x=unique_kc_x;\
\n    } else {\
\n	KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_"), kc_current_view); }
		kc::unparse(oid, kc_printer, kc_current_view);
		{ kc_printer(kc_t("));\
\n	kc_x->post_create();\
\n"), kc_current_view); }
		if (f_something_to_initialize( gl_cco )) 
		{
		    { kc_printer(kc_t("		kc_x = kc_initialize_"), kc_current_view); }
		    kc::unparse(gl_phylum, kc_printer, kc_current_view);
		    { kc_printer(kc_t("(kc_x);\
\n"), kc_current_view); }
		}
		{ kc_printer(kc_t("   }\
\n    return static_cast<impl_"), kc_current_view); }
		kc::unparse(gl_phylum, kc_printer, kc_current_view);
		if(gl_isnotlist)
		{
		    { kc_printer(kc_t("_"), kc_current_view); }
		    kc::unparse(oid, kc_printer, kc_current_view);
		}
		{ kc_printer(kc_t("*>(kc_x);\
\n}\
\n\
\n"), kc_current_view); }
	    } else
	    {
		const fndeclaration head = this->fndeclaration_1;
		const fndeclarations tail = this->fndeclarations_1;
		kc::unparse(tail, kc_printer, kc_current_view);
	    }
	    break;
	}
	case view_gen_operatordefs_nonhash_c_enum: {
	    view_gen_operatordefs_nonhash_c_class& kc_current_view=static_cast<view_gen_operatordefs_nonhash_c_class&>(kc_current_view_base);
	    if ((this->fndeclaration_1->prod_sel() == sel_FnAcDeclaration) && (phylum_cast<const impl_fndeclaration_FnAcDeclaration*>(this->fndeclaration_1)->ac_declarator_1->prod_sel() == sel_AcDeclarator) && (phylum_cast<const impl_ac_declarator_AcDeclarator*>(phylum_cast<const impl_fndeclaration_FnAcDeclaration*>(this->fndeclaration_1)->ac_declarator_1)->ac_direct_declarator_1->prod_sel() == sel_AcQualifiedDeclProto) && (phylum_cast<const impl_ac_direct_declarator_AcQualifiedDeclProto*>(phylum_cast<const impl_ac_declarator_AcDeclarator*>(phylum_cast<const impl_fndeclaration_FnAcDeclaration*>(this->fndeclaration_1)->ac_declarator_1)->ac_direct_declarator_1)->ac_direct_declarator_1->prod_sel() == sel_AcDirectDeclId) && (phylum_cast<const impl_fndeclaration_FnAcDeclaration*>(this->fndeclaration_1)->fnclass_1->prod_sel() == sel_ConstructorFn)) {
		const fndeclaration decl = this->fndeclaration_1;
		const ID oid = phylum_cast<const impl_ac_direct_declarator_AcDirectDeclId*>(phylum_cast<const impl_ac_direct_declarator_AcQualifiedDeclProto*>(phylum_cast<const impl_ac_declarator_AcDeclarator*>(phylum_cast<const impl_fndeclaration_FnAcDeclaration*>(this->fndeclaration_1)->ac_declarator_1)->ac_direct_declarator_1)->ac_direct_declarator_1)->ID_1;
		const ac_parameter_type_list params = phylum_cast<const impl_ac_direct_declarator_AcQualifiedDeclProto*>(phylum_cast<const impl_ac_declarator_AcDeclarator*>(phylum_cast<const impl_fndeclaration_FnAcDeclaration*>(this->fndeclaration_1)->ac_declarator_1)->ac_direct_declarator_1)->ac_parameter_type_list_1;
		const fndeclarations tail = this->fndeclarations_1;
		kc::unparse(tail, kc_printer, kc_current_view);
		{ kc_printer(kc_t("impl_"), kc_current_view); }
		kc::unparse(gl_phylum, kc_printer, kc_current_view);
		if(gl_isnotlist)
		{
		    { kc_printer(kc_t("_"), kc_current_view); }
		    kc::unparse(oid, kc_printer, kc_current_view);
		}
		{ kc_printer(kc_t("*\n"), kc_current_view); }
		kc::unparse(oid, kc_printer, kc_current_view);
		{ kc_printer(kc_t("("), kc_current_view); }
		kc::unparse(gl_args, kc_printer, view_gen_fnarg_and_decls);
		if(gl_no_of_args>0 && !f_no_params(params)) { PRINT(","); } 
		kc::unparse(decl->sorted, kc_printer, view_gen_fnk_c);
		{ kc_printer(kc_t(") {\
\n    "), kc_current_view); }
		kc::unparse(gl_args, kc_printer, view_gen_fnarg_asserts);
		kc::unparse(gl_phylum, kc_printer, kc_current_view);
		{ kc_printer(kc_t(" kc_x = new impl_"), kc_current_view); }
		kc::unparse(gl_phylum, kc_printer, kc_current_view);
		if(gl_isnotlist)
		{
		    { kc_printer(kc_t("_"), kc_current_view); }
		    kc::unparse(oid, kc_printer, kc_current_view);
		}
		{ kc_printer(kc_t("("), kc_current_view); }
		kc::unparse(gl_args, kc_printer, view_gen_argseqnr_rec);
		if(gl_no_of_args && !f_no_params(params)) { PRINT(","); } 
		kc::unparse(decl->sorted, kc_printer, view_gen_fnkargs);
		{ kc_printer(kc_t(");\
\n	KC_COLLECT_STATS0(KC_CREATE_STATS(sel_"), kc_current_view); }
		kc::unparse(oid, kc_printer, kc_current_view);
		{ kc_printer(kc_t("));\
\n	KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_"), kc_current_view); }
		kc::unparse(oid, kc_printer, kc_current_view);
		{ kc_printer(kc_t("));\
\n	kc_x->post_create();\
\n    "), kc_current_view); }
		if (f_something_to_initialize( gl_cco )) 
		{
		    { kc_printer(kc_t("    kc_x = kc_initialize_"), kc_current_view); }
		    kc::unparse(gl_phylum, kc_printer, kc_current_view);
		    { kc_printer(kc_t("(kc_x);\
\n    "), kc_current_view); }
		}
		{ kc_printer(kc_t("    return static_cast<impl_"), kc_current_view); }
		kc::unparse(gl_phylum, kc_printer, kc_current_view);
		if(gl_isnotlist)
		{
		    { kc_printer(kc_t("_"), kc_current_view); }
		    kc::unparse(oid, kc_printer, kc_current_view);
		}
		{ kc_printer(kc_t("*>(kc_x);\
\n    "), kc_current_view); }
		{ kc_printer(kc_t("}\
\n\
\n    "), kc_current_view); }
	    } else
	    {
		const fndeclaration head = this->fndeclaration_1;
		const fndeclarations tail = this->fndeclarations_1;
		kc::unparse(tail, kc_printer, kc_current_view);
	    }
	    break;
	}
	case view_gen_operatordecls_h_enum: {
	    view_gen_operatordecls_h_class& kc_current_view=static_cast<view_gen_operatordecls_h_class&>(kc_current_view_base);
	    if ((this->fndeclaration_1->prod_sel() == sel_FnAcDeclaration) && (phylum_cast<const impl_fndeclaration_FnAcDeclaration*>(this->fndeclaration_1)->ac_declarator_1->prod_sel() == sel_AcDeclarator) && (phylum_cast<const impl_ac_declarator_AcDeclarator*>(phylum_cast<const impl_fndeclaration_FnAcDeclaration*>(this->fndeclaration_1)->ac_declarator_1)->ac_direct_declarator_1->prod_sel() == sel_AcQualifiedDeclProto) && (phylum_cast<const impl_fndeclaration_FnAcDeclaration*>(this->fndeclaration_1)->fnclass_1->prod_sel() == sel_ConstructorFn)) {
		const fndeclaration decl = this->fndeclaration_1;
		const ac_direct_declarator id = phylum_cast<const impl_ac_direct_declarator_AcQualifiedDeclProto*>(phylum_cast<const impl_ac_declarator_AcDeclarator*>(phylum_cast<const impl_fndeclaration_FnAcDeclaration*>(this->fndeclaration_1)->ac_declarator_1)->ac_direct_declarator_1)->ac_direct_declarator_1;
		const ac_parameter_type_list params = phylum_cast<const impl_ac_direct_declarator_AcQualifiedDeclProto*>(phylum_cast<const impl_ac_declarator_AcDeclarator*>(phylum_cast<const impl_fndeclaration_FnAcDeclaration*>(this->fndeclaration_1)->ac_declarator_1)->ac_direct_declarator_1)->ac_parameter_type_list_1;
		const fndeclarations tail = this->fndeclarations_1;
		kc::unparse(tail, kc_printer, kc_current_view);
		{ kc_printer(kc_t("class "), kc_current_view); }
		kc::unparse(id, kc_printer, view_gen_fn_pointer_name);
		{ kc_printer(kc_t("*\b "), kc_current_view); }
		kc::unparse(id, kc_printer, kc_current_view);
		{ kc_printer(kc_t(" ("), kc_current_view); }
		kc::unparse(gl_args, kc_printer, kc_current_view);
		if(gl_no_of_args && !f_no_params(params)) { PRINT(","); } 
		kc::unparse(decl->sorted, kc_printer, view_gen_fnk_h);
		{ kc_printer(kc_t(");\n"), kc_current_view); }
	    } else
	    {
		const fndeclaration head = this->fndeclaration_1;
		const fndeclarations tail = this->fndeclarations_1;
		kc::unparse(tail, kc_printer, kc_current_view);
	    }
	    break;
	}
	case view_count_nonstaticmembers_enum: {
	    view_count_nonstaticmembers_class& kc_current_view=static_cast<view_count_nonstaticmembers_class&>(kc_current_view_base);
	    if ((this->fndeclaration_1->prod_sel() == sel_AcMemberDeclaration) && (phylum_cast<const impl_fndeclaration_AcMemberDeclaration*>(this->fndeclaration_1)->ac_declaration_specifiers_1->prod_sel() == sel_Consac_declaration_specifiers) && ((phylum_cast<const impl_fndeclaration_AcMemberDeclaration*>(this->fndeclaration_1)->ac_declaration_specifiers_1)->ac_declaration_specifier_1->prod_sel() == sel_AcDeclSpecTypeSpec) && (phylum_cast<const impl_ac_declaration_specifier_AcDeclSpecTypeSpec*>((phylum_cast<const impl_fndeclaration_AcMemberDeclaration*>(this->fndeclaration_1)->ac_declaration_specifiers_1)->ac_declaration_specifier_1)->ac_type_specifier_1->prod_sel() == sel_AcTypeSpec) && (phylum_cast<const impl_fndeclaration_AcMemberDeclaration*>(this->fndeclaration_1)->ac_declarator_1->prod_sel() == sel_AcDeclarator) && (phylum_cast<const impl_ac_declarator_AcDeclarator*>(phylum_cast<const impl_fndeclaration_AcMemberDeclaration*>(this->fndeclaration_1)->ac_declarator_1)->ac_direct_declarator_1->prod_sel() == sel_AcMemberDecl) && (phylum_cast<const impl_fndeclaration_AcMemberDeclaration*>(this->fndeclaration_1)->fnclass_1->prod_sel() == sel_MemberFn)) {
		const fndeclaration fd = this->fndeclaration_1;
		const ID a_type = phylum_cast<const impl_ac_type_specifier_AcTypeSpec*>(phylum_cast<const impl_ac_declaration_specifier_AcDeclSpecTypeSpec*>((phylum_cast<const impl_fndeclaration_AcMemberDeclaration*>(this->fndeclaration_1)->ac_declaration_specifiers_1)->ac_declaration_specifier_1)->ac_type_specifier_1)->ID_1;
		const ID a_id = phylum_cast<const impl_ac_direct_declarator_AcMemberDecl*>(phylum_cast<const impl_ac_declarator_AcDeclarator*>(phylum_cast<const impl_fndeclaration_AcMemberDeclaration*>(this->fndeclaration_1)->ac_declarator_1)->ac_direct_declarator_1)->ID_2;
		const fndeclarations rfd = this->fndeclarations_1;
		kc::unparse(rfd, kc_printer, kc_current_view);
		gl_no_of_args++;
		gl_args=Consarguments(a_type, gl_args);
		gl_members=Consfndeclarations(fd, gl_members);
		gl_idents=Consac_identifier_list(a_id, gl_idents);

	    } else
	    {
		const fndeclarations rfd = this->fndeclarations_1;
		kc::unparse(rfd, kc_printer, kc_current_view);
	    }
	    break;
	}
	case view_count_attrs_enum: {
	    view_count_attrs_class& kc_current_view=static_cast<view_count_attrs_class&>(kc_current_view_base);
	    if ((this->fndeclaration_1->prod_sel() == sel_AcMemberDeclaration) && (phylum_cast<const impl_fndeclaration_AcMemberDeclaration*>(this->fndeclaration_1)->ac_declaration_specifiers_1->prod_sel() == sel_Consac_declaration_specifiers) && ((phylum_cast<const impl_fndeclaration_AcMemberDeclaration*>(this->fndeclaration_1)->ac_declaration_specifiers_1)->ac_declaration_specifier_1->prod_sel() == sel_AcDeclSpecTypeSpec) && (phylum_cast<const impl_ac_declaration_specifier_AcDeclSpecTypeSpec*>((phylum_cast<const impl_fndeclaration_AcMemberDeclaration*>(this->fndeclaration_1)->ac_declaration_specifiers_1)->ac_declaration_specifier_1)->ac_type_specifier_1->prod_sel() == sel_AcTypeSpec) && (phylum_cast<const impl_fndeclaration_AcMemberDeclaration*>(this->fndeclaration_1)->ac_declarator_1->prod_sel() == sel_AcDeclarator) && (phylum_cast<const impl_ac_declarator_AcDeclarator*>(phylum_cast<const impl_fndeclaration_AcMemberDeclaration*>(this->fndeclaration_1)->ac_declarator_1)->ac_direct_declarator_1->prod_sel() == sel_AcMemberDecl)) {
		const fndeclaration fd = this->fndeclaration_1;
		const ID a_type = phylum_cast<const impl_ac_type_specifier_AcTypeSpec*>(phylum_cast<const impl_ac_declaration_specifier_AcDeclSpecTypeSpec*>((phylum_cast<const impl_fndeclaration_AcMemberDeclaration*>(this->fndeclaration_1)->ac_declaration_specifiers_1)->ac_declaration_specifier_1)->ac_type_specifier_1)->ID_1;
		const ID a_id = phylum_cast<const impl_ac_direct_declarator_AcMemberDecl*>(phylum_cast<const impl_ac_declarator_AcDeclarator*>(phylum_cast<const impl_fndeclaration_AcMemberDeclaration*>(this->fndeclaration_1)->ac_declarator_1)->ac_direct_declarator_1)->ID_2;
		const fndeclarations rfd = this->fndeclarations_1;
		kc::unparse(rfd, kc_printer, kc_current_view);
		if (fd->is_attr) {
		    gl_no_of_args++;
		    gl_args=Consarguments(a_type, gl_args);
		    gl_members=Consfndeclarations(fd, gl_members);
		    gl_idents=Consac_identifier_list(a_id, gl_idents);
		} 
			} else
	    {
		const fndeclarations rfd = this->fndeclarations_1;
		kc::unparse(rfd, kc_printer, kc_current_view);
	    }
	    break;
	}
	case view_make_patternreps_enum: {
	    view_make_patternreps_class& kc_current_view=static_cast<view_make_patternreps_class&>(kc_current_view_base);
	    {
		const fndeclaration a_fnd = this->fndeclaration_1;
		const fndeclarations r_fnd = this->fndeclarations_1;
		kc::unparse(r_fnd, kc_printer, kc_current_view);
		kc::unparse(a_fnd, kc_printer, kc_current_view);
	    }
	    break;
	}
	case view_check_enum: {
	    view_check_class& kc_current_view=static_cast<view_check_class&>(kc_current_view_base);
	    {
		const fndeclaration fnd = this->fndeclaration_1;
		const fndeclarations fnds = this->fndeclarations_1;
		kc::unparse(fnds, kc_printer, kc_current_view);
		kc::unparse(fnd, kc_printer, kc_current_view);
	    }
	    break;
	}

	default:
	kc_unparsing_default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    { /* Alternative( *, args ) -> [view_gen_unparsedefs_default_c: */
		for (fndeclarations iterator_ = this; iterator_->fndeclarations_1 != 0; iterator_ = iterator_->fndeclarations_1)
		    iterator_->fndeclaration_1->unparse(kc_printer, kc_current_view);
	    }
	    break;
	}
    }
}

void
impl_fndeclarations::nil_do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case view_gen_fnk_c_enum: {
	    view_gen_fnk_c_class& kc_current_view=static_cast<view_gen_fnk_c_class&>(kc_current_view_base);
	    {
	    }
	    break;
	}
	case view_gen_fnkdecls_c_enum: {
	    view_gen_fnkdecls_c_class& kc_current_view=static_cast<view_gen_fnkdecls_c_class&>(kc_current_view_base);
	    {
		{ kc_printer(kc_t("\
\n#ifndef KC_TRACE_PROVIDED\
\n#define KC_TRACE_PROVIDED(COND,FILE,LINE,NODE) COND\
\n#endif\
\n\
\n"), kc_current_view); }
	    }
	    break;
	}
	case view_gen_fnk_h_enum: {
	    view_gen_fnk_h_class& kc_current_view=static_cast<view_gen_fnk_h_class&>(kc_current_view_base);
	    {
	    }
	    break;
	}
	case view_gen_operatordefs_hash_c_enum: {
	    view_gen_operatordefs_hash_c_class& kc_current_view=static_cast<view_gen_operatordefs_hash_c_class&>(kc_current_view_base);
	    {
	    }
	    break;
	}
	case view_gen_operatordefs_nonhash_c_enum: {
	    view_gen_operatordefs_nonhash_c_class& kc_current_view=static_cast<view_gen_operatordefs_nonhash_c_class&>(kc_current_view_base);
	    {
	    }
	    break;
	}
	case view_gen_operatordecls_h_enum: {
	    view_gen_operatordecls_h_class& kc_current_view=static_cast<view_gen_operatordecls_h_class&>(kc_current_view_base);
	    {
	    }
	    break;
	}
	case view_count_nonstaticmembers_enum: {
	    view_count_nonstaticmembers_class& kc_current_view=static_cast<view_count_nonstaticmembers_class&>(kc_current_view_base);
	    {
		gl_no_of_args = 0; gl_args = Nilarguments(); gl_members=Nilfndeclarations(); gl_idents=Nilac_identifier_list(); 
	    }
	    break;
	}
	case view_count_attrs_enum: {
	    view_count_attrs_class& kc_current_view=static_cast<view_count_attrs_class&>(kc_current_view_base);
	    {
		gl_no_of_args = 0; gl_args = Nilarguments(); gl_members=Nilfndeclarations(); gl_idents=Nilac_identifier_list(); 
	    }
	    break;
	}
	case view_make_patternreps_enum: {
	    view_make_patternreps_class& kc_current_view=static_cast<view_make_patternreps_class&>(kc_current_view_base);
	    {
	    }
	    break;
	}
	case view_check_enum: {
	    view_check_class& kc_current_view=static_cast<view_check_class&>(kc_current_view_base);
	    {
	    }
	    break;
	}

	default:
	kc_unparsing_default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    { /* Alternative( *, args ) -> [view_gen_unparsedefs_default_c: */
	    }
	    break;
	}
    }
}


void
impl_fndeclaration_AcMemberDeclaration::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case view_gen_member_dcl_h_enum: {
	    view_gen_member_dcl_h_class& kc_current_view=static_cast<view_gen_member_dcl_h_class&>(kc_current_view_base);
	    {
		const ac_declaration_specifiers fn_ds = this->ac_declaration_specifiers_1;
		const ac_declarator fn_d = this->ac_declarator_1;
		kc::unparse(fn_ds, kc_printer, kc_current_view);
		{ kc_printer(kc_t(" "), kc_current_view); }
		kc::unparse(fn_d, kc_printer, kc_current_view);
		{ kc_printer(kc_t(";\
\n"), kc_current_view); }
	    }
	    break;
	}
	case view_gen_fnk_c_enum: {
	    view_gen_fnk_c_class& kc_current_view=static_cast<view_gen_fnk_c_class&>(kc_current_view_base);
	    if ((this->ac_constant_expression_option_1->prod_sel() == sel_Noac_constant_expression) && (this->fnclass_1->prod_sel() == sel_StaticFn)) {
		const ac_declaration_specifiers fn_ds = this->ac_declaration_specifiers_1;
		const ac_declarator fn_d = this->ac_declarator_1;
		if(g_options.linedirec) 
		{
		    kc::unparse(pg_line, kc_printer, kc_current_view);
		    kc::unparse(this->last_line, kc_printer, kc_current_view);
		    { kc_printer(kc_t(" \""), kc_current_view); }
		    PRINT(g_options.dir_line.c_str()); 
		    kc::unparse(this->file, kc_printer, view_filename);
		    { kc_printer(kc_t("\"\n"), kc_current_view); }
		}
		kc::unparse(fn_ds, kc_printer, kc_current_view);
		{ kc_printer(kc_t(" "), kc_current_view); }
		kc::unparse(fn_d, kc_printer, kc_current_view);
		{ kc_printer(kc_t(";\
\n"), kc_current_view); }
	    } else
		if ((this->ac_constant_expression_option_1->prod_sel() == sel_Yesac_constant_expression) && (this->fnclass_1->prod_sel() == sel_StaticFn)) {
		const ac_declaration_specifiers fn_ds = this->ac_declaration_specifiers_1;
		const ac_declarator fn_d = this->ac_declarator_1;
		const ac_constant_expression expr = phylum_cast<const impl_ac_constant_expression_option_Yesac_constant_expression*>(this->ac_constant_expression_option_1)->ac_constant_expression_1;
		if(g_options.linedirec) 
		{
		    kc::unparse(pg_line, kc_printer, kc_current_view);
		    kc::unparse(this->last_line, kc_printer, kc_current_view);
		    { kc_printer(kc_t(" \""), kc_current_view); }
		    PRINT(g_options.dir_line.c_str()); 
		    kc::unparse(this->file, kc_printer, view_filename);
		    { kc_printer(kc_t("\"\n"), kc_current_view); }
		}
		kc::unparse(fn_ds, kc_printer, kc_current_view);
		{ kc_printer(kc_t(" "), kc_current_view); }
		kc::unparse(fn_d, kc_printer, kc_current_view);
		{ kc_printer(kc_t("="), kc_current_view); }
		kc::unparse(expr, kc_printer, kc_current_view);
		{ kc_printer(kc_t(";\
\n"), kc_current_view); }
	    } else
		if ((this->ac_constant_expression_option_1->prod_sel() == sel_Noac_constant_expression)) {
	    } else
		    goto kc_unparsing_default;
	    break;
	}
	case view_make_patternreps_enum: {
	    view_make_patternreps_class& kc_current_view=static_cast<view_make_patternreps_class&>(kc_current_view_base);
	    {
	    }
	    break;
	}
	case view_check_enum: {
	    view_check_class& kc_current_view=static_cast<view_check_class&>(kc_current_view_base);
	    if ((this->ac_declarator_1->prod_sel() == sel_AcDeclarator) && (phylum_cast<const impl_ac_declarator_AcDeclarator*>(this->ac_declarator_1)->ac_direct_declarator_1->prod_sel() == sel_AcMemberDecl) && (this->fnclass_1->prod_sel() == sel_StaticFn) && (KC_TRACE_PROVIDED((is_attr), "util.k", 672, this))) {
		const ID pid = phylum_cast<const impl_ac_direct_declarator_AcMemberDecl*>(phylum_cast<const impl_ac_declarator_AcDeclarator*>(this->ac_declarator_1)->ac_direct_declarator_1)->ID_1;
		const ID aid = phylum_cast<const impl_ac_direct_declarator_AcMemberDecl*>(phylum_cast<const impl_ac_declarator_AcDeclarator*>(this->ac_declarator_1)->ac_direct_declarator_1)->ID_2;
		v_report(NonFatal( FileLine(file, last_line) ,
			Problem1S1ID1S1ID( "attribute", aid,
			    "(with %attr) should not be static in phylum", pid)));

	    } else
		if ((this->ac_declarator_1->prod_sel() == sel_AcDeclarator) && (phylum_cast<const impl_ac_declarator_AcDeclarator*>(this->ac_declarator_1)->ac_direct_declarator_1->prod_sel() == sel_AcMemberDecl)) {
		const ID pid = phylum_cast<const impl_ac_direct_declarator_AcMemberDecl*>(phylum_cast<const impl_ac_declarator_AcDeclarator*>(this->ac_declarator_1)->ac_direct_declarator_1)->ID_1;
		const ID aid = phylum_cast<const impl_ac_direct_declarator_AcMemberDecl*>(phylum_cast<const impl_ac_declarator_AcDeclarator*>(this->ac_declarator_1)->ac_direct_declarator_1)->ID_2;
		{
		    ID kc_selvar_0_1 = phylum_cast<ID>(pid);
		    if ((kc_selvar_0_1->prod_sel() == sel_Id)) {
			const uniqID uid = phylum_cast<const impl_ID_Id*>(kc_selvar_0_1)->uniqID_1;
			{
			    IDtype kc_selvar_1_1 = phylum_cast<IDtype>( uid->type );
			    if ((kc_selvar_1_1->prod_sel() == sel_ITUnknown)) {

				v_report(NonFatal( FileLine(file, last_line),
					Problem1S1ID1S1ID( "attribute", aid,
					    "is not part of any phylum or operator; defined in", pid)));

			    } else
			    {

			    }
			}

		    } else
			kc_no_default_in_with( "", __LINE__, __FILE__ );
		}

		if (f_ispredefinedphylum(pid) && strcmp(f_strofID(pid), "abstract_phylum")!=0
		    && strcmp(f_strofID(pid), "abstract_list")!=0)
		v_report(NonFatal( FileLine(this->file, this->last_line) ,
			Problem1S1ID1S1ID( "attribute", aid,
			    "must not be defined in predefined phylum", pid)));

		if(!f_listelementphylum(f_phylumofoperator(pid))->eq(f_emptyId()))
		v_report(NonFatal( FileLine(file, last_line) ,
			Problem1S1ID1S1ID( "attribute", aid,
			    "must not be declared in list operator", pid)));

	    } else
	    {
	    }
	    break;
	}

	default:
	kc_unparsing_default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
	    }
	    break;
	}
    }
}


void
impl_fndeclaration_FnAcDeclaration::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case view_gen_member_dcl_h_enum: {
	    view_gen_member_dcl_h_class& kc_current_view=static_cast<view_gen_member_dcl_h_class&>(kc_current_view_base);
	    if ((this->ac_declarator_1->prod_sel() == sel_AcDeclarator) && (phylum_cast<const impl_ac_declarator_AcDeclarator*>(this->ac_declarator_1)->ac_direct_declarator_1->prod_sel() == sel_AcQualifiedDeclProto) && (phylum_cast<const impl_ac_direct_declarator_AcQualifiedDeclProto*>(phylum_cast<const impl_ac_declarator_AcDeclarator*>(this->ac_declarator_1)->ac_direct_declarator_1)->ac_direct_declarator_1->prod_sel() == sel_AcDirectDeclId) && (this->fnclass_1->prod_sel() == sel_ConstructorFn)) {
		const ac_declaration_specifiers fn_ds = this->ac_declaration_specifiers_1;
		const ac_declarator fn_d = this->ac_declarator_1;
		const ID oid = phylum_cast<const impl_ac_direct_declarator_AcDirectDeclId*>(phylum_cast<const impl_ac_direct_declarator_AcQualifiedDeclProto*>(phylum_cast<const impl_ac_declarator_AcDeclarator*>(this->ac_declarator_1)->ac_direct_declarator_1)->ac_direct_declarator_1)->ID_1;
		const ac_parameter_type_list params = phylum_cast<const impl_ac_direct_declarator_AcQualifiedDeclProto*>(phylum_cast<const impl_ac_declarator_AcDeclarator*>(this->ac_declarator_1)->ac_direct_declarator_1)->ac_parameter_type_list_1;
		const fnclass fnc = this->fnclass_1;
		bool is_ctor=false;
		{
		    fnclass kc_selvar_0_1 = phylum_cast<fnclass>(fnc);
		    if ((kc_selvar_0_1->prod_sel() == sel_ConstructorFn)) {
			is_ctor=true; 
				} else
		    {

		    }
		}

		kc::unparse(fn_ds, kc_printer, kc_current_view);
		{ kc_printer(kc_t(" "), kc_current_view); }
		if(!is_ctor) PRINT("~"); 
		kc::unparse(fn_d, kc_printer, view_gen_fn_pointer_name);
		{ kc_printer(kc_t("("), kc_current_view); }
		arguments args=f_argumentsofoperator(oid);
		if(is_ctor) 
		{
		    kc::unparse(args, kc_printer, view_count_args);
		    if (f_ispredefinedphylum(f_phylumofoperator(oid))) 
		    {
			kc::unparse(args, kc_printer, view_gen_fnarg_and_decls_predef);
		    }
		    else 
		    {
			kc::unparse(args, kc_printer, view_gen_fnarg_and_decls);
		    }
		    if(gl_no_of_args && !f_no_params(params)) { PRINT(","); } 
		    kc::unparse(params, kc_printer, view_gen_fnk_h);
		}
		{ kc_printer(kc_t(");\
\n"), kc_current_view); }
	    } else
		if ((this->ac_declarator_1->prod_sel() == sel_AcDeclarator) && (phylum_cast<const impl_ac_declarator_AcDeclarator*>(this->ac_declarator_1)->ac_direct_declarator_1->prod_sel() == sel_AcQualifiedDeclProto) && (phylum_cast<const impl_ac_direct_declarator_AcQualifiedDeclProto*>(phylum_cast<const impl_ac_declarator_AcDeclarator*>(this->ac_declarator_1)->ac_direct_declarator_1)->ac_direct_declarator_1->prod_sel() == sel_AcDirectDeclId) && (this->fnclass_1->prod_sel() == sel_DestructorFn)) {
		const ac_declaration_specifiers fn_ds = this->ac_declaration_specifiers_1;
		const ac_declarator fn_d = this->ac_declarator_1;
		const ID oid = phylum_cast<const impl_ac_direct_declarator_AcDirectDeclId*>(phylum_cast<const impl_ac_direct_declarator_AcQualifiedDeclProto*>(phylum_cast<const impl_ac_declarator_AcDeclarator*>(this->ac_declarator_1)->ac_direct_declarator_1)->ac_direct_declarator_1)->ID_1;
		const ac_parameter_type_list params = phylum_cast<const impl_ac_direct_declarator_AcQualifiedDeclProto*>(phylum_cast<const impl_ac_declarator_AcDeclarator*>(this->ac_declarator_1)->ac_direct_declarator_1)->ac_parameter_type_list_1;
		const fnclass fnc = this->fnclass_1;
		bool is_ctor=false;
		{
		    fnclass kc_selvar_0_1 = phylum_cast<fnclass>(fnc);
		    if ((kc_selvar_0_1->prod_sel() == sel_ConstructorFn)) {
			is_ctor=true; 
				} else
		    {

		    }
		}

		kc::unparse(fn_ds, kc_printer, kc_current_view);
		{ kc_printer(kc_t(" "), kc_current_view); }
		if(!is_ctor) PRINT("~"); 
		kc::unparse(fn_d, kc_printer, view_gen_fn_pointer_name);
		{ kc_printer(kc_t("("), kc_current_view); }
		arguments args=f_argumentsofoperator(oid);
		if(is_ctor) 
		{
		    kc::unparse(args, kc_printer, view_count_args);
		    if (f_ispredefinedphylum(f_phylumofoperator(oid))) 
		    {
			kc::unparse(args, kc_printer, view_gen_fnarg_and_decls_predef);
		    }
		    else 
		    {
			kc::unparse(args, kc_printer, view_gen_fnarg_and_decls);
		    }
		    if(gl_no_of_args && !f_no_params(params)) { PRINT(","); } 
		    kc::unparse(params, kc_printer, view_gen_fnk_h);
		}
		{ kc_printer(kc_t(");\
\n"), kc_current_view); }
	    } else
		if ((this->fnclass_1->prod_sel() == sel_ConvOperatorFn)) {
		const ac_declarator fn_d = this->ac_declarator_1;
		kc::unparse(fn_d, kc_printer, kc_current_view);
	    } else
	    {
		const ac_declaration_specifiers fn_ds = this->ac_declaration_specifiers_1;
		const ac_declarator fn_d = this->ac_declarator_1;
		kc::unparse(fn_ds, kc_printer, kc_current_view);
		{ kc_printer(kc_t(" "), kc_current_view); }
		kc::unparse(fn_d, kc_printer, kc_current_view);
	    }
	    break;
	}
	case view_gen_fnk_c_enum: {
	    view_gen_fnk_c_class& kc_current_view=static_cast<view_gen_fnk_c_class&>(kc_current_view_base);
	    if ((this->ac_declarator_1->prod_sel() == sel_AcDeclarator) && (phylum_cast<const impl_ac_declarator_AcDeclarator*>(this->ac_declarator_1)->ac_direct_declarator_1->prod_sel() == sel_AcQualifiedDeclProto) && (phylum_cast<const impl_ac_direct_declarator_AcQualifiedDeclProto*>(phylum_cast<const impl_ac_declarator_AcDeclarator*>(this->ac_declarator_1)->ac_direct_declarator_1)->ac_direct_declarator_1->prod_sel() == sel_AcDirectDeclId) && (this->fnclass_1->prod_sel() == sel_ConstructorFn)) {
		const ac_declaration_specifiers fn_ds = this->ac_declaration_specifiers_1;
		const ac_declarator fn_d = this->ac_declarator_1;
		const ID oid = phylum_cast<const impl_ac_direct_declarator_AcDirectDeclId*>(phylum_cast<const impl_ac_direct_declarator_AcQualifiedDeclProto*>(phylum_cast<const impl_ac_declarator_AcDeclarator*>(this->ac_declarator_1)->ac_direct_declarator_1)->ac_direct_declarator_1)->ID_1;
		const ac_parameter_type_list params = phylum_cast<const impl_ac_direct_declarator_AcQualifiedDeclProto*>(phylum_cast<const impl_ac_declarator_AcDeclarator*>(this->ac_declarator_1)->ac_direct_declarator_1)->ac_parameter_type_list_1;
		const ac_opt_base_init_list base_init = this->ac_opt_base_init_list_1;
		const Ctext ct = this->Ctext_1;
		const fnclass fnc = this->fnclass_1;

		gl_return_ID = 0;
		gl_return_type = "";
		gl_star_count = f_stars_of_declarator( fn_d );
		gl_function = f_strofID(f_id_of_ctor_dtor_decl(fn_d));
		gl_operator=oid;
		bool is_ctor=false;
		{
		    fnclass kc_selvar_0_1 = phylum_cast<fnclass>(fnc);
		    if ((kc_selvar_0_1->prod_sel() == sel_ConstructorFn)) {
			is_ctor=true; 
				} else
		    {

		    }
		}

		kc::unparse(fn_d, kc_printer, view_gen_fn_pointer_name);
		{ kc_printer(kc_t("::"), kc_current_view); }
		if(!is_ctor) { PRINT("~"); } 
		kc::unparse(fn_d, kc_printer, view_gen_fn_pointer_name);
		{ kc_printer(kc_t("("), kc_current_view); }
		arguments args=f_argumentsofoperator(oid);
		if(is_ctor) 
		{
		    kc::unparse(args, kc_printer, view_count_args);
		    if (f_ispredefinedphylum(f_phylumofoperator(oid))) 
		    {
			kc::unparse(args, kc_printer, view_gen_fnarg_and_decls_predef);
		    }
		    else 
		    {
			kc::unparse(args, kc_printer, view_gen_fnarg_and_decls);
		    }
		    if(gl_no_of_args && !f_no_params(params)) { PRINT(","); } 
		    kc::unparse(this->sorted, kc_printer, kc_current_view);
		}
		{ kc_printer(kc_t(")"), kc_current_view); }
		kc::unparse(base_init, kc_printer, kc_current_view);
		{ kc_printer(kc_t("\n"), kc_current_view); }
		if(g_options.linedirec) 
		{
		    kc::unparse(pg_line, kc_printer, kc_current_view);
		    kc::unparse(ct->line, kc_printer, kc_current_view);
		    { kc_printer(kc_t(" \""), kc_current_view); }
		    PRINT(g_options.dir_line.c_str()); 
		    kc::unparse(ct->file, kc_printer, view_filename);
		    { kc_printer(kc_t("\"\n"), kc_current_view); }
		}
		{ kc_printer(kc_t("{"), kc_current_view); }
		if(is_ctor) 
		{
		    if (f_ispredefinedphylum(f_phylumofoperator(oid))) 
		    {
			kc::unparse(args, kc_printer, view_gen_assignments_predef);
		    }
		    else if(The_abstract_phylum_decl->subphylum(0)->eq(oid)) 
		    {
			if(g_options.smart_pointer) 
			{
			    { kc_printer(kc_t("_ref=0;\
\n		"), kc_current_view); }
			}
		    }
		    else 
		    {
			kc::unparse(args, kc_printer, view_gen_assignments);
		    }
		}
		kc::unparse(ct, kc_printer, view_gen_initializephyla_c);
		{ kc_printer(kc_t("\n"), kc_current_view); }
		if(g_options.linedirec) 
		{
		    kc::unparse(pg_line, kc_printer, kc_current_view);
		    kc::unparse(this->last_line, kc_printer, kc_current_view);
		    { kc_printer(kc_t(" \""), kc_current_view); }
		    PRINT(g_options.dir_line.c_str()); 
		    kc::unparse(this->file, kc_printer, view_filename);
		    { kc_printer(kc_t("\"\n"), kc_current_view); }
		}
		{ kc_printer(kc_t("}"), kc_current_view); }
		kc::unparse(g_emptystring, kc_printer, view_printer_outputfileline);
		{ kc_printer(kc_t("\
\n"), kc_current_view); }
		gl_return_type = "";
		gl_return_ID = 0;
		gl_star_count = 0;
		gl_function = "";

	    } else
		if ((this->ac_declarator_1->prod_sel() == sel_AcDeclarator) && (phylum_cast<const impl_ac_declarator_AcDeclarator*>(this->ac_declarator_1)->ac_direct_declarator_1->prod_sel() == sel_AcQualifiedDeclProto) && (phylum_cast<const impl_ac_direct_declarator_AcQualifiedDeclProto*>(phylum_cast<const impl_ac_declarator_AcDeclarator*>(this->ac_declarator_1)->ac_direct_declarator_1)->ac_direct_declarator_1->prod_sel() == sel_AcDirectDeclId) && (this->fnclass_1->prod_sel() == sel_DestructorFn)) {
		const ac_declaration_specifiers fn_ds = this->ac_declaration_specifiers_1;
		const ac_declarator fn_d = this->ac_declarator_1;
		const ID oid = phylum_cast<const impl_ac_direct_declarator_AcDirectDeclId*>(phylum_cast<const impl_ac_direct_declarator_AcQualifiedDeclProto*>(phylum_cast<const impl_ac_declarator_AcDeclarator*>(this->ac_declarator_1)->ac_direct_declarator_1)->ac_direct_declarator_1)->ID_1;
		const ac_parameter_type_list params = phylum_cast<const impl_ac_direct_declarator_AcQualifiedDeclProto*>(phylum_cast<const impl_ac_declarator_AcDeclarator*>(this->ac_declarator_1)->ac_direct_declarator_1)->ac_parameter_type_list_1;
		const ac_opt_base_init_list base_init = this->ac_opt_base_init_list_1;
		const Ctext ct = this->Ctext_1;
		const fnclass fnc = this->fnclass_1;

		gl_return_ID = 0;
		gl_return_type = "";
		gl_star_count = f_stars_of_declarator( fn_d );
		gl_function = f_strofID(f_id_of_ctor_dtor_decl(fn_d));
		gl_operator=oid;
		bool is_ctor=false;
		{
		    fnclass kc_selvar_0_1 = phylum_cast<fnclass>(fnc);
		    if ((kc_selvar_0_1->prod_sel() == sel_ConstructorFn)) {
			is_ctor=true; 
				} else
		    {

		    }
		}

		kc::unparse(fn_d, kc_printer, view_gen_fn_pointer_name);
		{ kc_printer(kc_t("::"), kc_current_view); }
		if(!is_ctor) { PRINT("~"); } 
		kc::unparse(fn_d, kc_printer, view_gen_fn_pointer_name);
		{ kc_printer(kc_t("("), kc_current_view); }
		arguments args=f_argumentsofoperator(oid);
		if(is_ctor) 
		{
		    kc::unparse(args, kc_printer, view_count_args);
		    if (f_ispredefinedphylum(f_phylumofoperator(oid))) 
		    {
			kc::unparse(args, kc_printer, view_gen_fnarg_and_decls_predef);
		    }
		    else 
		    {
			kc::unparse(args, kc_printer, view_gen_fnarg_and_decls);
		    }
		    if(gl_no_of_args && !f_no_params(params)) { PRINT(","); } 
		    kc::unparse(this->sorted, kc_printer, kc_current_view);
		}
		{ kc_printer(kc_t(")"), kc_current_view); }
		kc::unparse(base_init, kc_printer, kc_current_view);
		{ kc_printer(kc_t("\n"), kc_current_view); }
		if(g_options.linedirec) 
		{
		    kc::unparse(pg_line, kc_printer, kc_current_view);
		    kc::unparse(ct->line, kc_printer, kc_current_view);
		    { kc_printer(kc_t(" \""), kc_current_view); }
		    PRINT(g_options.dir_line.c_str()); 
		    kc::unparse(ct->file, kc_printer, view_filename);
		    { kc_printer(kc_t("\"\n"), kc_current_view); }
		}
		{ kc_printer(kc_t("{"), kc_current_view); }
		if(is_ctor) 
		{
		    if (f_ispredefinedphylum(f_phylumofoperator(oid))) 
		    {
			kc::unparse(args, kc_printer, view_gen_assignments_predef);
		    }
		    else if(The_abstract_phylum_decl->subphylum(0)->eq(oid)) 
		    {
			if(g_options.smart_pointer) 
			{
			    { kc_printer(kc_t("_ref=0;\
\n		"), kc_current_view); }
			}
		    }
		    else 
		    {
			kc::unparse(args, kc_printer, view_gen_assignments);
		    }
		}
		kc::unparse(ct, kc_printer, view_gen_initializephyla_c);
		{ kc_printer(kc_t("\n"), kc_current_view); }
		if(g_options.linedirec) 
		{
		    kc::unparse(pg_line, kc_printer, kc_current_view);
		    kc::unparse(this->last_line, kc_printer, kc_current_view);
		    { kc_printer(kc_t(" \""), kc_current_view); }
		    PRINT(g_options.dir_line.c_str()); 
		    kc::unparse(this->file, kc_printer, view_filename);
		    { kc_printer(kc_t("\"\n"), kc_current_view); }
		}
		{ kc_printer(kc_t("}"), kc_current_view); }
		kc::unparse(g_emptystring, kc_printer, view_printer_outputfileline);
		{ kc_printer(kc_t("\
\n"), kc_current_view); }
		gl_return_type = "";
		gl_return_ID = 0;
		gl_star_count = 0;
		gl_function = "";

	    } else
		if ((this->fnclass_1->prod_sel() == sel_ConvOperatorFn)) {
		const ac_declaration_specifiers fn_ds = this->ac_declaration_specifiers_1;
		const ac_declarator fn_d = this->ac_declarator_1;
		const Ctext ct = this->Ctext_1;
		const ID fn_name = this->ID_1;
		const fnclass fnc = this->fnclass_1;

		gl_return_ID = 0;
		gl_return_type = "";
		gl_star_count = f_stars_of_declarator( fn_d );
		gl_function = f_strofID( fn_name );

		kc::unparse(fn_d, kc_printer, view_gen_fn_pointer_name);
		{ kc_printer(kc_t("()"), kc_current_view); }
		kc::unparse(fn_d, kc_printer, view_gen_opt_const);
		{ kc_printer(kc_t("\n"), kc_current_view); }
		if(g_options.linedirec) 
		{
		    kc::unparse(pg_line, kc_printer, kc_current_view);
		    kc::unparse(ct->line, kc_printer, kc_current_view);
		    { kc_printer(kc_t(" \""), kc_current_view); }
		    PRINT(g_options.dir_line.c_str()); 
		    kc::unparse(ct->file, kc_printer, view_filename);
		    { kc_printer(kc_t("\"\n"), kc_current_view); }
		}
		{ kc_printer(kc_t("{"), kc_current_view); }
		kc::unparse(ct, kc_printer, view_gen_initializephyla_c);
		{ kc_printer(kc_t("\n"), kc_current_view); }
		if(g_options.linedirec) 
		{
		    kc::unparse(pg_line, kc_printer, kc_current_view);
		    kc::unparse(this->last_line, kc_printer, kc_current_view);
		    { kc_printer(kc_t(" \""), kc_current_view); }
		    PRINT(g_options.dir_line.c_str()); 
		    kc::unparse(this->file, kc_printer, view_filename);
		    { kc_printer(kc_t("\"\n"), kc_current_view); }
		}
		{ kc_printer(kc_t("}"), kc_current_view); }
		kc::unparse(g_emptystring, kc_printer, view_printer_outputfileline);
		{ kc_printer(kc_t("\
\n"), kc_current_view); }
		gl_return_type = "";
		gl_return_ID = 0;
		gl_star_count = 0;
		gl_function = "";

	    } else
	    {
		const ac_declaration_specifiers fn_ds = this->ac_declaration_specifiers_1;
		const ac_declarator fn_d = this->ac_declarator_1;
		const Ctext ct = this->Ctext_1;
		const ID fn_name = this->ID_1;
		const fnclass fnc = this->fnclass_1;

		gl_return_ID = f_ID_of_ac_declaration_specifiers( fn_ds );
		gl_return_type = f_strofID( gl_return_ID );
		gl_star_count = f_stars_of_declarator( fn_d );
		gl_function = f_strofID( fn_name );
		if (strcmp(gl_function, "main")==0) PRINT("} // namespace kc\n");

		kc::unparse(fnc, kc_printer, kc_current_view);
		kc::unparse(fn_ds, kc_printer, kc_current_view);
		{ kc_printer(kc_t(" "), kc_current_view); }
		kc::unparse(fn_d, kc_printer, view_gen_fn_pointer_name);
		{ kc_printer(kc_t("("), kc_current_view); }
		kc::unparse(this->sorted, kc_printer, kc_current_view);
		{ kc_printer(kc_t(")"), kc_current_view); }
		kc::unparse(fn_d, kc_printer, view_gen_opt_const);
		{ kc_printer(kc_t("\n"), kc_current_view); }
		if(g_options.linedirec) 
		{
		    kc::unparse(pg_line, kc_printer, kc_current_view);
		    kc::unparse(ct->line, kc_printer, kc_current_view);
		    { kc_printer(kc_t(" \""), kc_current_view); }
		    PRINT(g_options.dir_line.c_str()); 
		    kc::unparse(ct->file, kc_printer, view_filename);
		    { kc_printer(kc_t("\"\n"), kc_current_view); }
		}
		{ kc_printer(kc_t("{"), kc_current_view); }
		kc::unparse(ct, kc_printer, view_gen_initializephyla_c);
		{ kc_printer(kc_t("\n"), kc_current_view); }
		if(g_options.linedirec) 
		{
		    kc::unparse(pg_line, kc_printer, kc_current_view);
		    kc::unparse(this->last_line, kc_printer, kc_current_view);
		    { kc_printer(kc_t(" \""), kc_current_view); }
		    PRINT(g_options.dir_line.c_str()); 
		    kc::unparse(this->file, kc_printer, view_filename);
		    { kc_printer(kc_t("\"\n"), kc_current_view); }
		}
		{ kc_printer(kc_t("}"), kc_current_view); }
		kc::unparse(g_emptystring, kc_printer, view_printer_outputfileline);
		{ kc_printer(kc_t("\
\n"), kc_current_view); }
		gl_return_type = "";
		gl_return_ID = 0;
		gl_star_count = 0;
		if (strcmp(gl_function, "main")==0) PRINT("namespace kc {\r\n");
		gl_function = "";

	    }
	    break;
	}
	case view_gen_fnkdecls_c_enum: {
	    view_gen_fnkdecls_c_class& kc_current_view=static_cast<view_gen_fnkdecls_c_class&>(kc_current_view_base);
	    if ((this->fnclass_1->prod_sel() == sel_GlobalFn)) {
	    } else
		if ((this->fnclass_1->prod_sel() == sel_MemberFn)) {
	    } else
		if ((this->fnclass_1->prod_sel() == sel_ConstructorFn)) {
	    } else
		if ((this->fnclass_1->prod_sel() == sel_DestructorFn)) {
	    } else
		if ((this->fnclass_1->prod_sel() == sel_ConvOperatorFn)) {
	    } else
		if ((this->fnclass_1->prod_sel() == sel_StaticFn)) {
		const ac_declaration_specifiers fn_ds = this->ac_declaration_specifiers_1;
		const ac_declarator fn_d = this->ac_declarator_1;
		const fnclass fn_c = this->fnclass_1;
		kc::unparse(fn_c, kc_printer, kc_current_view);
		kc::unparse(fn_ds, kc_printer, kc_current_view);
		{ kc_printer(kc_t(" "), kc_current_view); }
		kc::unparse(fn_d, kc_printer, view_gen_fn_pointer_name);
		{ kc_printer(kc_t(" ("), kc_current_view); }
		kc::unparse(this->sorted, kc_printer, kc_current_view);
		{ kc_printer(kc_t(");\
\n"), kc_current_view); }
	    } else
		    goto kc_unparsing_default;
	    break;
	}
	case view_gen_fnk_h_enum: {
	    view_gen_fnk_h_class& kc_current_view=static_cast<view_gen_fnk_h_class&>(kc_current_view_base);
	    if ((this->ID_1->prod_sel() == sel_Id) && (phylum_cast<const impl_ID_Id*>(this->ID_1)->uniqID_1->prod_sel() == sel_Str) && (kc_strcmp(phylum_cast<const impl_uniqID_Str*>(phylum_cast<const impl_ID_Id*>(this->ID_1)->uniqID_1)->casestring_1->name, kc_t("main"))==0) && (this->fnclass_1->prod_sel() == sel_GlobalFn)) {
	    } else
		if ((this->fnclass_1->prod_sel() == sel_GlobalFn)) {
		const ac_declaration_specifiers fn_ds = this->ac_declaration_specifiers_1;
		const ac_declarator fn_d = this->ac_declarator_1;
		kc::unparse(fn_ds, kc_printer, kc_current_view);
		{ kc_printer(kc_t(" "), kc_current_view); }
		kc::unparse(fn_d, kc_printer, view_gen_fn_pointer_name);
		{ kc_printer(kc_t(" ("), kc_current_view); }
		kc::unparse(this->sorted, kc_printer, kc_current_view);
		{ kc_printer(kc_t(");\
\n"), kc_current_view); }
	    } else
		if ((this->fnclass_1->prod_sel() == sel_StaticFn)) {
	    } else
		if ((this->fnclass_1->prod_sel() == sel_MemberFn)) {
	    } else
		if ((this->fnclass_1->prod_sel() == sel_ConstructorFn)) {
	    } else
		if ((this->fnclass_1->prod_sel() == sel_DestructorFn)) {
	    } else
		if ((this->fnclass_1->prod_sel() == sel_ConvOperatorFn)) {
	    } else
		    goto kc_unparsing_default;
	    break;
	}
	case view_make_patternreps_enum: {
	    view_make_patternreps_class& kc_current_view=static_cast<view_make_patternreps_class&>(kc_current_view_base);
	    {
		const Ctext ct = this->Ctext_1;
		kc::unparse(ct, kc_printer, kc_current_view);
	    }
	    break;
	}
	case view_check_enum: {
	    view_check_class& kc_current_view=static_cast<view_check_class&>(kc_current_view_base);
	    if ((this->ac_declaration_specifiers_1->prod_sel() == sel_Nilac_declaration_specifiers) && (this->ac_declarator_1->prod_sel() == sel_AcDeclarator) && (phylum_cast<const impl_ac_declarator_AcDeclarator*>(this->ac_declarator_1)->ac_pointer_option_1->prod_sel() == sel_Nopointer) && (phylum_cast<const impl_ac_declarator_AcDeclarator*>(this->ac_declarator_1)->ac_ref_option_1->prod_sel() == sel_AcNoRef) && (phylum_cast<const impl_ac_declarator_AcDeclarator*>(this->ac_declarator_1)->ac_direct_declarator_1->prod_sel() == sel_AcQualifiedDeclProto) && (phylum_cast<const impl_ac_direct_declarator_AcQualifiedDeclProto*>(phylum_cast<const impl_ac_declarator_AcDeclarator*>(this->ac_declarator_1)->ac_direct_declarator_1)->ac_class_qualifier_list_1->prod_sel() == sel_Nilac_class_qualifier_list) && (phylum_cast<const impl_ac_direct_declarator_AcQualifiedDeclProto*>(phylum_cast<const impl_ac_declarator_AcDeclarator*>(this->ac_declarator_1)->ac_direct_declarator_1)->ac_direct_declarator_1->prod_sel() == sel_AcDirectDeclId) && (phylum_cast<const impl_ac_direct_declarator_AcQualifiedDeclProto*>(phylum_cast<const impl_ac_declarator_AcDeclarator*>(this->ac_declarator_1)->ac_direct_declarator_1)->ac_type_qualifier_1->prod_sel() == sel_AcNoQualifier) && (this->ac_declaration_list_1->prod_sel() == sel_Nilac_declaration_list) && (this->fnclass_1->prod_sel() == sel_ConstructorFn)) {
		const ID pid = phylum_cast<const impl_ac_direct_declarator_AcDirectDeclId*>(phylum_cast<const impl_ac_direct_declarator_AcQualifiedDeclProto*>(phylum_cast<const impl_ac_declarator_AcDeclarator*>(this->ac_declarator_1)->ac_direct_declarator_1)->ac_direct_declarator_1)->ID_1;
		const Ctext ct = this->Ctext_1;
		kc::unparse(ct, kc_printer, kc_current_view);
		{
		    ID kc_selvar_0_1 = phylum_cast<ID>(pid);
		    if ((kc_selvar_0_1->prod_sel() == sel_Id)) {
			const uniqID uid = phylum_cast<const impl_ID_Id*>(kc_selvar_0_1)->uniqID_1;
			{
			    IDtype kc_selvar_1_1 = phylum_cast<IDtype>( uid->type );
			    if ((kc_selvar_1_1->prod_sel() == sel_ITUnknown)) {

				v_report(Warning( FileLine(file, last_line),
					Problem1S1ID( "constructor does not belong to phylum or operator:",
					    pid)));

			    } else
			    {

			    }
			}

		    } else
			kc_no_default_in_with( "", __LINE__, __FILE__ );
		}

	    } else
		if ((this->ac_declarator_1->prod_sel() == sel_AcDeclarator) && (phylum_cast<const impl_ac_declarator_AcDeclarator*>(this->ac_declarator_1)->ac_pointer_option_1->prod_sel() == sel_Nopointer) && (phylum_cast<const impl_ac_declarator_AcDeclarator*>(this->ac_declarator_1)->ac_ref_option_1->prod_sel() == sel_AcNoRef) && (phylum_cast<const impl_ac_declarator_AcDeclarator*>(this->ac_declarator_1)->ac_direct_declarator_1->prod_sel() == sel_AcQualifiedDeclProto) && (phylum_cast<const impl_ac_direct_declarator_AcQualifiedDeclProto*>(phylum_cast<const impl_ac_declarator_AcDeclarator*>(this->ac_declarator_1)->ac_direct_declarator_1)->ac_class_qualifier_list_1->prod_sel() == sel_Nilac_class_qualifier_list) && (phylum_cast<const impl_ac_direct_declarator_AcQualifiedDeclProto*>(phylum_cast<const impl_ac_declarator_AcDeclarator*>(this->ac_declarator_1)->ac_direct_declarator_1)->ac_direct_declarator_1->prod_sel() == sel_AcDirectDeclId) && (phylum_cast<const impl_ac_direct_declarator_AcQualifiedDeclProto*>(phylum_cast<const impl_ac_declarator_AcDeclarator*>(this->ac_declarator_1)->ac_direct_declarator_1)->ac_parameter_type_list_1->prod_sel() == sel_AcParList) && (phylum_cast<const impl_ac_parameter_type_list_AcParList*>(phylum_cast<const impl_ac_direct_declarator_AcQualifiedDeclProto*>(phylum_cast<const impl_ac_declarator_AcDeclarator*>(this->ac_declarator_1)->ac_direct_declarator_1)->ac_parameter_type_list_1)->ac_parameter_list_1->prod_sel() == sel_Nilac_parameter_list) && (phylum_cast<const impl_ac_direct_declarator_AcQualifiedDeclProto*>(phylum_cast<const impl_ac_declarator_AcDeclarator*>(this->ac_declarator_1)->ac_direct_declarator_1)->ac_type_qualifier_1->prod_sel() == sel_AcNoQualifier) && (this->ac_declaration_list_1->prod_sel() == sel_Nilac_declaration_list) && (this->ac_opt_base_init_list_1->prod_sel() == sel_AcNoBaseInit) && (this->fnclass_1->prod_sel() == sel_DestructorFn)) {
		const ID pid = phylum_cast<const impl_ac_direct_declarator_AcDirectDeclId*>(phylum_cast<const impl_ac_direct_declarator_AcQualifiedDeclProto*>(phylum_cast<const impl_ac_declarator_AcDeclarator*>(this->ac_declarator_1)->ac_direct_declarator_1)->ac_direct_declarator_1)->ID_1;
		const Ctext ct = this->Ctext_1;
		kc::unparse(ct, kc_printer, kc_current_view);
		{
		    ID kc_selvar_0_1 = phylum_cast<ID>(pid);
		    if ((kc_selvar_0_1->prod_sel() == sel_Id)) {
			const uniqID uid = phylum_cast<const impl_ID_Id*>(kc_selvar_0_1)->uniqID_1;
			{
			    IDtype kc_selvar_1_1 = phylum_cast<IDtype>( uid->type );
			    if ((kc_selvar_1_1->prod_sel() == sel_ITUnknown)) {

				v_report(Warning( FileLine(file, last_line),
					Problem1S1ID( "destructor does not belong to phylum or operator:",
					    pid)));

			    } else
			    {

			    }
			}

		    } else
			kc_no_default_in_with( "", __LINE__, __FILE__ );
		}

	    } else
	    {
		const Ctext ct = this->Ctext_1;
		kc::unparse(ct, kc_printer, kc_current_view);
	    }
	    break;
	}

	default:
	kc_unparsing_default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    { /* Alternative( *, args ) -> [view_gen_unparsedefs_default_c: */
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


void
impl_fnclass_ConvOperatorFn::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    { /* Alternative( *, args ) -> [view_gen_unparsedefs_default_c: */
	    }
	    break;
	}
    }
}


void
impl_fnclass_DestructorFn::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    { /* Alternative( *, args ) -> [view_gen_unparsedefs_default_c: */
	    }
	    break;
	}
    }
}


void
impl_fnclass_ConstructorFn::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    { /* Alternative( *, args ) -> [view_gen_unparsedefs_default_c: */
	    }
	    break;
	}
    }
}


void
impl_fnclass_MemberFn::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    { /* Alternative( *, args ) -> [view_gen_unparsedefs_default_c: */
	    }
	    break;
	}
    }
}


void
impl_fnclass_StaticFn::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		{ kc_printer(kc_t("static "), kc_current_view); }
	    }
	    break;
	}
    }
}


void
impl_fnclass_GlobalFn::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case view_gen_fnk_c_enum: {
	    view_gen_fnk_c_class& kc_current_view=static_cast<view_gen_fnk_c_class&>(kc_current_view_base);
	    {
	    }
	    break;
	}

	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    { /* Alternative( *, args ) -> [view_gen_unparsedefs_default_c: */
	    }
	    break;
	}
    }
}

void
impl_Ctext::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    if(is_nil())
	nil_do_unparse(kc_printer, kc_current_view_base);
    else
	switch(kc_current_view_base) {
	case view_gen_initializephyla_c_enum: {
	    view_gen_initializephyla_c_class& kc_current_view=static_cast<view_gen_initializephyla_c_class&>(kc_current_view_base);
	    {
		gl_print_line_directive = false;
		Ctext inversion_ = this->reverse();
		for (Ctext iterator_ = inversion_; iterator_->Ctext_1 != 0; iterator_ = iterator_->Ctext_1)
		iterator_->Ctext_elem_1->unparse(kc_printer, kc_current_view);
		inversion_->freelist();

	    }
	    break;
	}

	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    { /* Alternative( *, args ) -> [view_gen_unparsedefs_default_c: */
		for (Ctext iterator_ = this; iterator_->Ctext_1 != 0; iterator_ = iterator_->Ctext_1)
		    iterator_->Ctext_elem_1->unparse(kc_printer, kc_current_view);
	    }
	    break;
	}
    }
}

void
impl_Ctext::nil_do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case view_gen_initializephyla_c_enum: {
	    view_gen_initializephyla_c_class& kc_current_view=static_cast<view_gen_initializephyla_c_class&>(kc_current_view_base);
	    {
	    }
	    break;
	}

	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    { /* Alternative( *, args ) -> [view_gen_unparsedefs_default_c: */
	    }
	    break;
	}
    }
}


void
impl_Ctext_elem_CTextWithexpression::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case view_make_patternreps_enum: {
	    view_make_patternreps_class& kc_current_view=static_cast<view_make_patternreps_class&>(kc_current_view_base);
	    {
		const withcases wc = this->withcases_1;
		kc::unparse(wc, kc_printer, kc_current_view);
		check_with_patterns(wc->wcinfo); 
	    }
	    break;
	}
	case view_gen_initializephyla_c_enum: {
	    view_gen_initializephyla_c_class& kc_current_view=static_cast<view_gen_initializephyla_c_class&>(kc_current_view_base);
	    {
		const Ctext_elem ctw = this/**/;
		const withexpressions wexpr = this->withexpressions_1;
		const withcases wcs = this->withcases_1;
		const contextinfo in_foreach_context = this->contextinfo_1;
		if (wcs->wcinfo) 
		{

		    ID selvar;
		    int p;
		    patternchain fe_pc = 0;
		    withcasesinfo rewr_wcinfo = rewrite_withcasesinfo(wcs->wcinfo);
		    {
			contextinfo kc_selvar_0_1 = phylum_cast<contextinfo>(in_foreach_context);
			if ((kc_selvar_0_1->prod_sel() == sel_NotInForeachContext)) {

			    selvar = f_mkselvar("kc_selvar_", g_ctext_level);
			    selvar->line = ctw->line; 
			    selvar->file = ctw->file;
			    cf_pushselvar( selvar );
			    inforeachcontext.push(0);

			} else
			    if ((kc_selvar_0_1->prod_sel() == sel_InForeachContext)) {
			    const patternchain mp = phylum_cast<const impl_contextinfo_InForeachContext*>(kc_selvar_0_1)->patternchain_1;

			    selvar = cf_topselvar(); 
			    inforeachcontext.push(1);
			    fe_pc = mp;

			} else
			    kc_no_default_in_with( "", __LINE__, __FILE__ );
		    }

		    { kc_printer(kc_t("{\
\n"), kc_current_view); }
		    if (! inforeachcontext.top()) 
		    {
			kc::unparse(wexpr, kc_printer, kc_current_view);
		    }
		    if (! inforeachcontext.top()) {
			dollarvarstack.push( selvar );
			dollarvarextstack.push( Id(Str(mkcasestring("_1"))) );
		    } else if ((p = pos_of_sole_dollar_or_pattern_in_patternchain(fe_pc)) >= 0) {
			dollarvarstack.push( selvar );
			dollarvarextstack.push( f_mkselvar("_", p) );
		    }

		    kc::unparse(rewr_wcinfo, kc_printer, view_gen_withcases_and_default);
		    if (! inforeachcontext.top()) {
			cf_popselvar();
			dollarvarstack.pop();
			dollarvarextstack.pop();
		    } else if (p >= 0) {
			dollarvarstack.pop();
			dollarvarextstack.pop();
		    }
		    inforeachcontext.pop();

		    { kc_printer(kc_t("}\
\n"), kc_current_view); }
		    gl_print_line_directive = true; 
		     }
		else { v_report(NonFatal( FileLine( this->file, this->line ), Problem1S( "internal error: no info for withcases of CTextWithexpression" )));
		} 
	    }
	    break;
	}
	case view_check_enum: {
	    view_check_class& kc_current_view=static_cast<view_check_class&>(kc_current_view_base);
	    {
		const withexpressions we = this->withexpressions_1;
		const withcases wc = this->withcases_1;
		const contextinfo in_foreach_context = this->contextinfo_1;

		withexpressionsstack.push( we );
		{
		    contextinfo kc_selvar_0_1 = phylum_cast<contextinfo>(in_foreach_context);
		    if ((kc_selvar_0_1->prod_sel() == sel_NotInForeachContext)) {

			inforeachcontext.push(0);
			phylumnamesstack.push( we->type );

		    } else
			if ((kc_selvar_0_1->prod_sel() == sel_InForeachContext)) {

			inforeachcontext.push(1);

		    } else
			kc_no_default_in_with( "", __LINE__, __FILE__ );
		}
		if (we->length() == 1) {
		    dollarvarsallowed.push( DVAllowed() );
		} else {
		    dollarvarsallowed.push( DVDisallowed() );
		}

		kc::unparse(wc, kc_printer, kc_current_view);
		kc::unparse(wc, kc_printer, view_set_type);
		we->type = phylumnamesstack.top();
		withexpressionsstack.pop();
		dollarvarsallowed.pop();

		kc::unparse(we, kc_printer, kc_current_view);
		if (! inforeachcontext.top() ) {
		    phylumnamesstack.pop();
		}
		inforeachcontext.pop();

	    }
	    break;
	}

	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    { /* Alternative( *, args ) -> [view_gen_unparsedefs_default_c: */
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


void
impl_Ctext_elem_CTextForeachexpression::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case view_make_patternreps_enum: {
	    view_make_patternreps_class& kc_current_view=static_cast<view_make_patternreps_class&>(kc_current_view_base);
	    {
		const Ctext ct = this->Ctext_1;
		const foreach_after fa = this->foreach_after_1;
		kc::unparse(ct, kc_printer, kc_current_view);
		kc::unparse(fa, kc_printer, kc_current_view);
	    }
	    break;
	}
	case view_gen_initializephyla_c_enum: {
	    view_gen_initializephyla_c_class& kc_current_view=static_cast<view_gen_initializephyla_c_class&>(kc_current_view_base);
	    {
		const idCexpressions idcexpr = this->idCexpressions_1;
		const Ctext ct = this->Ctext_1;
		const foreach_after fa = this->foreach_after_1;

		ID selvar = f_mkselvar("kc_selvar_", g_ctext_level);
		selvar->line = this->line; 
		selvar->file = this->file;
		cf_pushselvar( selvar );

		{ kc_printer(kc_t("{\
\n"), kc_current_view); }
		kc::unparse(idcexpr, kc_printer, kc_current_view);
		kc::unparse(g_emptystring, kc_printer, view_printer_outputfileline);
		{ kc_printer(kc_t("while(\
\n"), kc_current_view); }
		kc::unparse(idcexpr, kc_printer, view_gen_initializephyla_whiletest_c);
		{ kc_printer(kc_t("    ) {\
\n"), kc_current_view); }
		kc::unparse(idcexpr, kc_printer, view_gen_initializephyla_init_el_c);
		{ kc_printer(kc_t("{\n"), kc_current_view); }
		if(g_options.linedirec) 
		{
		    kc::unparse(pg_line, kc_printer, kc_current_view);
		    kc::unparse(ct->line, kc_printer, kc_current_view);
		    { kc_printer(kc_t(" \""), kc_current_view); }
		    PRINT(g_options.dir_line.c_str()); 
		    kc::unparse(ct->file, kc_printer, view_filename);
		    { kc_printer(kc_t("\"\n"), kc_current_view); }
		}
		kc::unparse(ct, kc_printer, kc_current_view);
		kc::unparse(g_emptystring, kc_printer, view_printer_outputfileline);
		{ kc_printer(kc_t("}\
\n"), kc_current_view); }
		kc::unparse(idcexpr, kc_printer, view_gen_initializephyla_update_loop_c);
		kc::unparse(g_emptystring, kc_printer, view_printer_outputfileline);
		{ kc_printer(kc_t("}\
\n"), kc_current_view); }
		cf_popselvar();
		selvar = Id(Str(mkcasestring("kc_fe_selvar")));
		selvar->line = fa->line; 
		selvar->file = fa->file;
		cf_pushselvar( selvar );

		kc::unparse(fa, kc_printer, kc_current_view);
		{ kc_printer(kc_t("}\
\n"), kc_current_view); }
		cf_popselvar();
		gl_print_line_directive = true;

	    }
	    break;
	}
	case view_check_enum: {
	    view_check_class& kc_current_view=static_cast<view_check_class&>(kc_current_view_base);
	    {
		const idCexpressions ide = this->idCexpressions_1;
		const Ctext ct = this->Ctext_1;
		const foreach_after fa = this->foreach_after_1;
		phylumnames tmp = f_phylumnames_foreachwith_vars( ide );
		phylumnamesstack.push( tmp );

		kc::unparse(ide, kc_printer, kc_current_view);
		kc::unparse(ct, kc_printer, kc_current_view);
		phylumnamesstack.pop();


		kc::unparse(fa, kc_printer, kc_current_view);
	    }
	    break;
	}

	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    { /* Alternative( *, args ) -> [view_gen_unparsedefs_default_c: */
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


void
impl_Ctext_elem_CTextCbody::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case view_make_patternreps_enum: {
	    view_make_patternreps_class& kc_current_view=static_cast<view_make_patternreps_class&>(kc_current_view_base);
	    {
		const Ctext ct = this->Ctext_1;
		kc::unparse(ct, kc_printer, kc_current_view);
	    }
	    break;
	}
	case view_gen_initializephyla_c_enum: {
	    view_gen_initializephyla_c_class& kc_current_view=static_cast<view_gen_initializephyla_c_class&>(kc_current_view_base);
	    {
		const Ctext ct = this->Ctext_1;
		if (gl_print_line_directive) 
		{
		    if(g_options.linedirec) 
		    {
			kc::unparse(pg_line, kc_printer, kc_current_view);
			kc::unparse(this->line, kc_printer, kc_current_view);
			{ kc_printer(kc_t(" \""), kc_current_view); }
			PRINT(g_options.dir_line.c_str()); 
			kc::unparse(this->file, kc_printer, view_filename);
			{ kc_printer(kc_t("\"\n"), kc_current_view); }
		    }
		    gl_print_line_directive = false; 
		     }
		{ kc_printer(kc_t("{"), kc_current_view); }
		kc::unparse(ct, kc_printer, kc_current_view);
		{ kc_printer(kc_t("}"), kc_current_view); }
		if (gl_print_line_directive) 
		{
		    { kc_printer(kc_t("\
\n"), kc_current_view); }
		}
	    }
	    break;
	}
	case view_check_enum: {
	    view_check_class& kc_current_view=static_cast<view_check_class&>(kc_current_view_base);
	    {
		const Ctext ct = this->Ctext_1;
		kc::unparse(ct, kc_printer, kc_current_view);
	    }
	    break;
	}

	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    { /* Alternative( *, args ) -> [view_gen_unparsedefs_default_c: */
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


void
impl_Ctext_elem_CTextCexpressionSQ::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case view_gen_initializephyla_c_enum: {
	    view_gen_initializephyla_c_class& kc_current_view=static_cast<view_gen_initializephyla_c_class&>(kc_current_view_base);
	    {
		const CexpressionSQ cesq = this->CexpressionSQ_1;
		if (gl_print_line_directive) 
		{
		    if(g_options.linedirec) 
		    {
			kc::unparse(pg_line, kc_printer, kc_current_view);
			kc::unparse(this->line, kc_printer, kc_current_view);
			{ kc_printer(kc_t(" \""), kc_current_view); }
			PRINT(g_options.dir_line.c_str()); 
			kc::unparse(this->file, kc_printer, view_filename);
			{ kc_printer(kc_t("\"\n"), kc_current_view); }
		    }
		    gl_print_line_directive = false; 
		     }
		{ kc_printer(kc_t("'"), kc_current_view); }
		kc::unparse(cesq, kc_printer, kc_current_view);
		{ kc_printer(kc_t("'"), kc_current_view); }
	    }
	    break;
	}
	case view_check_enum: {
	    view_check_class& kc_current_view=static_cast<view_check_class&>(kc_current_view_base);
	    {
	    }
	    break;
	}

	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    { /* Alternative( *, args ) -> [view_gen_unparsedefs_default_c: */
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


void
impl_Ctext_elem_CTextCexpressionDQ::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case view_gen_initializephyla_c_enum: {
	    view_gen_initializephyla_c_class& kc_current_view=static_cast<view_gen_initializephyla_c_class&>(kc_current_view_base);
	    {
		const CexpressionDQ cedq = this->CexpressionDQ_1;
		if (gl_print_line_directive) 
		{
		    if(g_options.linedirec) 
		    {
			kc::unparse(pg_line, kc_printer, kc_current_view);
			kc::unparse(this->line, kc_printer, kc_current_view);
			{ kc_printer(kc_t(" \""), kc_current_view); }
			PRINT(g_options.dir_line.c_str()); 
			kc::unparse(this->file, kc_printer, view_filename);
			{ kc_printer(kc_t("\"\n"), kc_current_view); }
		    }
		    gl_print_line_directive = false; 
		     }
		{ kc_printer(kc_t("\""), kc_current_view); }
		kc::unparse(cedq, kc_printer, kc_current_view);
		{ kc_printer(kc_t("\""), kc_current_view); }
	    }
	    break;
	}
	case view_check_enum: {
	    view_check_class& kc_current_view=static_cast<view_check_class&>(kc_current_view_base);
	    {
	    }
	    break;
	}

	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    { /* Alternative( *, args ) -> [view_gen_unparsedefs_default_c: */
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


void
impl_Ctext_elem_CTextNl::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case view_gen_initializephyla_c_enum: {
	    view_gen_initializephyla_c_class& kc_current_view=static_cast<view_gen_initializephyla_c_class&>(kc_current_view_base);
	    {
		const integer i = this->integer_1;
		charruns nl_string = Newlines(); 
		 if (gl_print_line_directive) 
		{
		    if(g_options.linedirec) 
		    {
			kc::unparse(pg_line, kc_printer, kc_current_view);
			kc::unparse(this->line, kc_printer, kc_current_view);
			{ kc_printer(kc_t(" \""), kc_current_view); }
			PRINT(g_options.dir_line.c_str()); 
			kc::unparse(this->file, kc_printer, view_filename);
			{ kc_printer(kc_t("\"\n"), kc_current_view); }
		    }
		    gl_print_line_directive = false; 
		     nl_string->set(i->value - 1); 
		     }
		else 
		{
		    nl_string->set(i->value); 
		     }
		kc::unparse(nl_string, kc_printer, kc_current_view);
	    }
	    break;
	}
	case view_check_enum: {
	    view_check_class& kc_current_view=static_cast<view_check_class&>(kc_current_view_base);
	    {
	    }
	    break;
	}

	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    { /* Alternative( *, args ) -> [view_gen_unparsedefs_default_c: */
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


void
impl_Ctext_elem_CTextDollarVar::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case view_gen_initializephyla_c_enum: {
	    view_gen_initializephyla_c_class& kc_current_view=static_cast<view_gen_initializephyla_c_class&>(kc_current_view_base);
	    {
		const INT i = this->INT_1;
		ID oid = f_emptyId(), dollarvar = dollarvarstack.top(), dollarvarext = dollarvarextstack.top();
		argument arg;
		bool nulvar = true;
		{
		    INT kc_selvar_0_1 = phylum_cast<INT>( i );
		    if ((kc_selvar_0_1->prod_sel() == sel_Int)) {
			const integer ii = phylum_cast<const impl_INT_Int*>(kc_selvar_0_1)->integer_1;

			if (ii->value != 0) {
			    nulvar = false;
			    oid = operatorstack.top();
			    arg = f_argumentofoperator( oid, i );
			}   
				} else
			kc_no_default_in_with( "", __LINE__, __FILE__ );
		}

		if (nulvar) 
		{
		    kc::unparse(dollarvar, kc_printer, kc_current_view);
		    kc::unparse(dollarvarext, kc_printer, kc_current_view);
		}
		else 
		{
		    kc::unparse(dollarvar, kc_printer, kc_current_view);
		    kc::unparse(dollarvarext, kc_printer, kc_current_view);
		    { kc_printer(kc_t("->"), kc_current_view); }
		    kc::unparse(arg, kc_printer, kc_current_view);
		    arg->free( false );  
		     }
	    }
	    break;
	}
	case view_check_enum: {
	    view_check_class& kc_current_view=static_cast<view_check_class&>(kc_current_view_base);
	    if ((this->INT_1->prod_sel() == sel_Int)) {
		const INT i = this->INT_1;
		const integer iv = phylum_cast<const impl_INT_Int*>(this->INT_1)->integer_1;
		if (  f_DvIsDisallowed( dollarvarsallowed.top() )) {
		    v_report(NonFatal( FileLine( i->file, i->line ),
			    Problem1S1INT(
				"illegal dollar variable (not allowed in &-ed pattern context)", i )));
		} else if (!outmostoperators.empty()) {
		    v_check_dollarvar_attribute_in_operators( i, Nilunpattributes(),
			outmostoperators.top() );
		} else if (iv->value != 0) {
		    v_report(NonFatal( FileLine( i->file, i->line ),
			    Problem1S1INT( "illegal dollar variable", i )));
		}

	    } else
		    goto kc_unparsing_default;
	    break;
	}

	default:
	kc_unparsing_default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    { /* Alternative( *, args ) -> [view_gen_unparsedefs_default_c: */
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


void
impl_Ctext_elem_CTextLine::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case view_gen_initializephyla_c_enum: {
	    view_gen_initializephyla_c_class& kc_current_view=static_cast<view_gen_initializephyla_c_class&>(kc_current_view_base);
	    {
		const casestring cs = this->casestring_1;
		if (gl_print_line_directive) 
		{
		    if(g_options.linedirec) 
		    {
			kc::unparse(pg_line, kc_printer, kc_current_view);
			kc::unparse(this->line, kc_printer, kc_current_view);
			{ kc_printer(kc_t(" \""), kc_current_view); }
			PRINT(g_options.dir_line.c_str()); 
			kc::unparse(this->file, kc_printer, view_filename);
			{ kc_printer(kc_t("\"\n"), kc_current_view); }
		    }
		    gl_print_line_directive = false; 
		     }
		kc::unparse(cs, kc_printer, kc_current_view);
	    }
	    break;
	}
	case view_check_enum: {
	    view_check_class& kc_current_view=static_cast<view_check_class&>(kc_current_view_base);
	    {
	    }
	    break;
	}

	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    { /* Alternative( *, args ) -> [view_gen_unparsedefs_default_c: */
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


void
impl_foreach_after_ForeachAfter::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case view_make_patternreps_enum: {
	    view_make_patternreps_class& kc_current_view=static_cast<view_make_patternreps_class&>(kc_current_view_base);
	    {
		const Ctext ct = this->Ctext_1;
		kc::unparse(ct, kc_printer, kc_current_view);
	    }
	    break;
	}
	case view_gen_initializephyla_c_enum: {
	    view_gen_initializephyla_c_class& kc_current_view=static_cast<view_gen_initializephyla_c_class&>(kc_current_view_base);
	    {
		const Ctext ct = this->Ctext_1;
		{ kc_printer(kc_t("{\n"), kc_current_view); }
		if(g_options.linedirec) 
		{
		    kc::unparse(pg_line, kc_printer, kc_current_view);
		    kc::unparse(ct->line, kc_printer, kc_current_view);
		    { kc_printer(kc_t(" \""), kc_current_view); }
		    PRINT(g_options.dir_line.c_str()); 
		    kc::unparse(ct->file, kc_printer, view_filename);
		    { kc_printer(kc_t("\"\n"), kc_current_view); }
		}
		kc::unparse(ct, kc_printer, kc_current_view);
		kc::unparse(g_emptystring, kc_printer, view_printer_outputfileline);
		{ kc_printer(kc_t("}\
\n"), kc_current_view); }
	    }
	    break;
	}
	case view_check_enum: {
	    view_check_class& kc_current_view=static_cast<view_check_class&>(kc_current_view_base);
	    {
		const patternchain mp = this->patternchain_1;
		const idCexpressions ide = this->idCexpressions_1;
		const Ctext ct = this->Ctext_1;
		phylumnames tmp = f_phylumnames_foreachwith_listvars( ide );
		phylumnamesstack.push( tmp );

		kc::unparse(ct, kc_printer, kc_current_view);
		phylumnamesstack.pop();


	    }
	    break;
	}

	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    { /* Alternative( *, args ) -> [view_gen_unparsedefs_default_c: */
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


void
impl_foreach_after_NoForeachAfter::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case view_make_patternreps_enum: {
	    view_make_patternreps_class& kc_current_view=static_cast<view_make_patternreps_class&>(kc_current_view_base);
	    {
	    }
	    break;
	}
	case view_gen_initializephyla_c_enum: {
	    view_gen_initializephyla_c_class& kc_current_view=static_cast<view_gen_initializephyla_c_class&>(kc_current_view_base);
	    {
	    }
	    break;
	}
	case view_check_enum: {
	    view_check_class& kc_current_view=static_cast<view_check_class&>(kc_current_view_base);
	    {
	    }
	    break;
	}

	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    { /* Alternative( *, args ) -> [view_gen_unparsedefs_default_c: */
	    }
	    break;
	}
    }
}


void
impl_contextinfo_NotInForeachContext::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    { /* Alternative( *, args ) -> [view_gen_unparsedefs_default_c: */
	    }
	    break;
	}
    }
}


void
impl_contextinfo_InForeachContext::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    { /* Alternative( *, args ) -> [view_gen_unparsedefs_default_c: */
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}

void
impl_withexpressions::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    if(is_nil())
	nil_do_unparse(kc_printer, kc_current_view_base);
    else
	switch(kc_current_view_base) {
	case view_gen_initializephyla_c_enum: {
	    view_gen_initializephyla_c_class& kc_current_view=static_cast<view_gen_initializephyla_c_class&>(kc_current_view_base);
	    {
		const withexpression h = this->withexpression_1;
		const withexpressions t = this->withexpressions_1;
		ID selvar = cf_topselvar(); 
		kc::unparse(t, kc_printer, kc_current_view);
		g_withexpr_nr++;

		if (h->line) 
		{
		    if(g_options.linedirec) 
		    {
			kc::unparse(pg_line, kc_printer, kc_current_view);
			kc::unparse(h->line, kc_printer, kc_current_view);
			{ kc_printer(kc_t(" \""), kc_current_view); }
			PRINT(g_options.dir_line.c_str()); 
			kc::unparse(h->file, kc_printer, view_filename);
			{ kc_printer(kc_t("\"\n"), kc_current_view); }
		    }
		}
		assertCond( ! (h->type->eq( f_emptyId())) ); 
		kc::unparse(h->type, kc_printer, kc_current_view);
		{ kc_printer(kc_t(" "), kc_current_view); }
		kc::unparse(selvar, kc_printer, kc_current_view);
		{ kc_printer(kc_t("_"), kc_current_view); }
		kc::unparse(g_withexpr_nr, kc_printer, kc_current_view);
		{ kc_printer(kc_t(" = phylum_cast<"), kc_current_view); }
		kc::unparse(h->type, kc_printer, kc_current_view);
		{ kc_printer(kc_t(">("), kc_current_view); }
		kc::unparse(h, kc_printer, kc_current_view);
		{ kc_printer(kc_t(");\
\n"), kc_current_view); }
	    }
	    break;
	}
	case view_check_enum: {
	    view_check_class& kc_current_view=static_cast<view_check_class&>(kc_current_view_base);
	    {
		const withexpression h = this->withexpression_1;
		const withexpressions t = this->withexpressions_1;
		ID tmp_type = 0;
		phylumnames tmp_types = 0;
		t->type = phylumnamesstack.top();
		{
		    phylumnames kc_selvar_0_1 = phylum_cast<phylumnames>( t->type );
		    if ((kc_selvar_0_1->prod_sel() == sel_Nilphylumnames)) {

			tmp_type = f_emptyId();
			tmp_types = Nilphylumnames();

		    } else
			if ((kc_selvar_0_1->prod_sel() == sel_Consphylumnames)) {
			const ID p_h = (kc_selvar_0_1)->ID_1;
			const phylumnames p_t = (kc_selvar_0_1)->phylumnames_1;

			tmp_type = p_h;
			tmp_types = p_t;

		    } else
			kc_no_default_in_with( "", __LINE__, __FILE__ );
		}
		phylumnamesstack.pop();
		phylumnamesstack.push( tmp_types );

		kc::unparse(t, kc_printer, kc_current_view);
		h->type = tmp_type;
		if (tmp_type->eq( f_emptyId())) {
		    v_report(NonFatal( FileLine( h->file, h->line ),
			    Problem1S1we( "could not infer type of with-expression argument:", h )));
		}

	    }
	    break;
	}

	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    { /* Alternative( *, args ) -> [view_gen_unparsedefs_default_c: */
		for (withexpressions iterator_ = this; iterator_->withexpressions_1 != 0; iterator_ = iterator_->withexpressions_1)
		    iterator_->withexpression_1->unparse(kc_printer, kc_current_view);
	    }
	    break;
	}
    }
}

void
impl_withexpressions::nil_do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case view_gen_initializephyla_c_enum: {
	    view_gen_initializephyla_c_class& kc_current_view=static_cast<view_gen_initializephyla_c_class&>(kc_current_view_base);
	    {
		g_withexpr_nr = 0; 
	    }
	    break;
	}
	case view_check_enum: {
	    view_check_class& kc_current_view=static_cast<view_check_class&>(kc_current_view_base);
	    {
	    }
	    break;
	}

	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    { /* Alternative( *, args ) -> [view_gen_unparsedefs_default_c: */
	    }
	    break;
	}
    }
}


void
impl_withexpression_WECexpression::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case view_gen_initializephyla_c_enum: {
	    view_gen_initializephyla_c_class& kc_current_view=static_cast<view_gen_initializephyla_c_class&>(kc_current_view_base);
	    {
		const Cexpression cexpr = this->Cexpression_1;
		kc::unparse(cexpr, kc_printer, kc_current_view);
	    }
	    break;
	}
	case view_error_enum: {
	    view_error_class& kc_current_view=static_cast<view_error_class&>(kc_current_view_base);
	    {
		const Cexpression ce = this->Cexpression_1;
		kc::unparse(ce, kc_printer, kc_current_view);
	    }
	    break;
	}

	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    { /* Alternative( *, args ) -> [view_gen_unparsedefs_default_c: */
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


void
impl_withexpression_WEVariable::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case view_gen_initializephyla_c_enum: {
	    view_gen_initializephyla_c_class& kc_current_view=static_cast<view_gen_initializephyla_c_class&>(kc_current_view_base);
	    {
		const ID id = this->ID_1;
		kc::unparse(id, kc_printer, kc_current_view);
	    }
	    break;
	}
	case view_error_enum: {
	    view_error_class& kc_current_view=static_cast<view_error_class&>(kc_current_view_base);
	    {
		const ID i = this->ID_1;
		kc::unparse(i, kc_printer, kc_current_view);
	    }
	    break;
	}

	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    { /* Alternative( *, args ) -> [view_gen_unparsedefs_default_c: */
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}

void
impl_withcases::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    if(is_nil())
	nil_do_unparse(kc_printer, kc_current_view_base);
    else
	switch(kc_current_view_base) {
	case view_make_patternreps_enum: {
	    view_make_patternreps_class& kc_current_view=static_cast<view_make_patternreps_class&>(kc_current_view_base);
	    {
		const withcase wc = this->withcase_1;
		const withcases r_wcs = this->withcases_1;
		kc::unparse(wc, kc_printer, kc_current_view);
		kc::unparse(r_wcs, kc_printer, kc_current_view);
		this->wcinfo = r_wcs->wcinfo;
		{
		    withcasesinfo kc_fe_selvar_1 =  wc->wcinfo ;

		    while(
			    kc_fe_selvar_1->prod_sel() == sel_Conswithcasesinfo
			) {
			withcaseinfo kc_selvar_0_1 = kc_fe_selvar_1->withcaseinfo_1;
			{
			    {
				{
				    const withcaseinfo wci = kc_selvar_0_1;

				    this->wcinfo = insertin_withcasesinfo( wci, this->wcinfo );

				}
			    }

			}
			kc_fe_selvar_1 = kc_fe_selvar_1->withcasesinfo_1;

		    }
		}

	    }
	    break;
	}
	case view_set_type_enum: {
	    view_set_type_class& kc_current_view=static_cast<view_set_type_class&>(kc_current_view_base);
	    {
		const withcase wc = this->withcase_1;
		const withcases wcs = this->withcases_1;
		kc::unparse(wcs, kc_printer, kc_current_view);
		kc::unparse(wc, kc_printer, kc_current_view);
	    }
	    break;
	}
	case view_check_enum: {
	    view_check_class& kc_current_view=static_cast<view_check_class&>(kc_current_view_base);
	    {
		const withcase wc = this->withcase_1;
		const withcases wcs = this->withcases_1;
		kc::unparse(wcs, kc_printer, kc_current_view);
		kc::unparse(wc, kc_printer, kc_current_view);
	    }
	    break;
	}

	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    { /* Alternative( *, args ) -> [view_gen_unparsedefs_default_c: */
		for (withcases iterator_ = this; iterator_->withcases_1 != 0; iterator_ = iterator_->withcases_1)
		    iterator_->withcase_1->unparse(kc_printer, kc_current_view);
	    }
	    break;
	}
    }
}

void
impl_withcases::nil_do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case view_make_patternreps_enum: {
	    view_make_patternreps_class& kc_current_view=static_cast<view_make_patternreps_class&>(kc_current_view_base);
	    {
		this->wcinfo = Nilwithcasesinfo(); 
	    }
	    break;
	}
	case view_set_type_enum: {
	    view_set_type_class& kc_current_view=static_cast<view_set_type_class&>(kc_current_view_base);
	    {
	    }
	    break;
	}
	case view_check_enum: {
	    view_check_class& kc_current_view=static_cast<view_check_class&>(kc_current_view_base);
	    {
	    }
	    break;
	}

	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    { /* Alternative( *, args ) -> [view_gen_unparsedefs_default_c: */
	    }
	    break;
	}
    }
}


void
impl_withcase_Withcase::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case view_make_patternreps_enum: {
	    view_make_patternreps_class& kc_current_view=static_cast<view_make_patternreps_class&>(kc_current_view_base);
	    {
		const patternchains mp = this->patternchains_1;
		const Ctext ct = this->Ctext_1;
		kc::unparse(ct, kc_printer, kc_current_view);
		v_resetbindingidmarks();

		this->wcinfo = f_withcasesinfo( add_predicates_to_patternrepresentations(
			syn_patternchains( mp ) ), ct );

	    }
	    break;
	}
	case view_set_type_enum: {
	    view_set_type_class& kc_current_view=static_cast<view_set_type_class&>(kc_current_view_base);
	    {
		const patternchains mp = this->patternchains_1;
		kc::unparse(mp, kc_printer, kc_current_view);
	    }
	    break;
	}
	case view_check_enum: {
	    view_check_class& kc_current_view=static_cast<view_check_class&>(kc_current_view_base);
	    {
		const patternchains mp = this->patternchains_1;
		const Ctext ct = this->Ctext_1;
		outmostoperators.push( Niloperators() );
		variablesstack.push( Nilvariables());
		cl_scope++;

		kc::unparse(mp, kc_printer, kc_current_view);
		kc::unparse(ct, kc_printer, kc_current_view);
		outmostoperators.top()->freelist();
		outmostoperators.pop();
		v_reset_variables_type( variablesstack.top() );
		cl_scope--;
		variablesstack.top()->freelist();
		variablesstack.pop();

	    }
	    break;
	}

	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    { /* Alternative( *, args ) -> [view_gen_unparsedefs_default_c: */
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}

void
impl_unparsedeclarations::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    if(is_nil())
	nil_do_unparse(kc_printer, kc_current_view_base);
    else
	switch(kc_current_view_base) {
	case view_checklanguagenames_enum: {
	    view_checklanguagenames_class& kc_current_view=static_cast<view_checklanguagenames_class&>(kc_current_view_base);
	    {
		const unparsedeclaration ud = this->unparsedeclaration_1;
		const unparsedeclarations uds = this->unparsedeclarations_1;
		kc::unparse(uds, kc_printer, kc_current_view);
		kc::unparse(ud, kc_printer, kc_current_view);
	    }
	    break;
	}
	case view_check_viewnames_enum: {
	    view_check_viewnames_class& kc_current_view=static_cast<view_check_viewnames_class&>(kc_current_view_base);
	    {
		const unparsedeclaration ud = this->unparsedeclaration_1;
		const unparsedeclarations uds = this->unparsedeclarations_1;
		kc::unparse(uds, kc_printer, kc_current_view);
		kc::unparse(ud, kc_printer, kc_current_view);
	    }
	    break;
	}
	case view_check_enum: {
	    view_check_class& kc_current_view=static_cast<view_check_class&>(kc_current_view_base);
	    {
		const unparsedeclaration ud = this->unparsedeclaration_1;
		const unparsedeclarations uds = this->unparsedeclarations_1;
		kc::unparse(uds, kc_printer, kc_current_view);
		kc::unparse(ud, kc_printer, kc_current_view);
	    }
	    break;
	}

	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    { /* Alternative( *, args ) -> [view_gen_unparsedefs_default_c: */
		for (unparsedeclarations iterator_ = this; iterator_->unparsedeclarations_1 != 0; iterator_ = iterator_->unparsedeclarations_1)
		    iterator_->unparsedeclaration_1->unparse(kc_printer, kc_current_view);
	    }
	    break;
	}
    }
}

void
impl_unparsedeclarations::nil_do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case view_checklanguagenames_enum: {
	    view_checklanguagenames_class& kc_current_view=static_cast<view_checklanguagenames_class&>(kc_current_view_base);
	    {
	    }
	    break;
	}
	case view_check_viewnames_enum: {
	    view_check_viewnames_class& kc_current_view=static_cast<view_check_viewnames_class&>(kc_current_view_base);
	    {
	    }
	    break;
	}
	case view_check_enum: {
	    view_check_class& kc_current_view=static_cast<view_check_class&>(kc_current_view_base);
	    {
	    }
	    break;
	}

	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    { /* Alternative( *, args ) -> [view_gen_unparsedefs_default_c: */
	    }
	    break;
	}
    }
}


void
impl_unparsedeclaration_UnparseDeclaration::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case view_checklanguagenames_enum: {
	    view_checklanguagenames_class& kc_current_view=static_cast<view_checklanguagenames_class&>(kc_current_view_base);
	    {
		const unparseclauses uc = this->unparseclauses_1;
		kc::unparse(uc, kc_printer, kc_current_view);
	    }
	    break;
	}
	case view_make_patternreps_enum: {
	    view_make_patternreps_class& kc_current_view=static_cast<view_make_patternreps_class&>(kc_current_view_base);
	    {
		const outmostpatterns op = this->outmostpatterns_1;
		const unparseclauses uc = this->unparseclauses_1;
		kc::unparse(uc, kc_printer, kc_current_view);
		v_resetbindingidmarks();

		this->patternreps = syn_outmostpatterns( op );
		this->patternreps = add_predicates_to_patternrepresentations(this->patternreps);
		v_add_unparsedeclsinfo_to_operator( this->patternreps, uc );

	    }
	    break;
	}
	case view_check_viewnames_enum: {
	    view_check_viewnames_class& kc_current_view=static_cast<view_check_viewnames_class&>(kc_current_view_base);
	    {
		const unparseclauses uc = this->unparseclauses_1;
		kc::unparse(uc, kc_printer, kc_current_view);
	    }
	    break;
	}
	case view_check_enum: {
	    view_check_class& kc_current_view=static_cast<view_check_class&>(kc_current_view_base);
	    {
		const outmostpatterns op = this->outmostpatterns_1;
		const unparseclauses uc = this->unparseclauses_1;
		outmostoperators.push( Niloperators() );
		dollarvarsallowed.push( DVAllowed() );
		phylumstack.push( f_emptyId() );
		variablesstack.push( Nilvariables());
		cl_scope++;

		kc::unparse(op, kc_printer, kc_current_view);
		kc::unparse(uc, kc_printer, kc_current_view);
		outmostoperators.top()->freelist();
		outmostoperators.pop();
		dollarvarsallowed.pop();
		phylumstack.pop();
		v_reset_variables_type( variablesstack.top() );
		cl_scope--;
		variablesstack.top()->freelist();
		variablesstack.pop();

	    }
	    break;
	}

	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    { /* Alternative( *, args ) -> [view_gen_unparsedefs_default_c: */
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}

void
impl_unparseclauses::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    if(is_nil())
	nil_do_unparse(kc_printer, kc_current_view_base);
    else
	switch(kc_current_view_base) {
	case view_checklanguagenames_enum: {
	    view_checklanguagenames_class& kc_current_view=static_cast<view_checklanguagenames_class&>(kc_current_view_base);
	    {
		const unparseclause uc = this->unparseclause_1;
		const unparseclauses ucs = this->unparseclauses_1;
		kc::unparse(ucs, kc_printer, kc_current_view);
		kc::unparse(uc, kc_printer, kc_current_view);
	    }
	    break;
	}
	case view_make_patternreps_enum: {
	    view_make_patternreps_class& kc_current_view=static_cast<view_make_patternreps_class&>(kc_current_view_base);
	    {
		const unparseclause a_uc = this->unparseclause_1;
		const unparseclauses r_uc = this->unparseclauses_1;
		kc::unparse(r_uc, kc_printer, kc_current_view);
		kc::unparse(a_uc, kc_printer, kc_current_view);
	    }
	    break;
	}
	case view_check_viewnames_enum: {
	    view_check_viewnames_class& kc_current_view=static_cast<view_check_viewnames_class&>(kc_current_view_base);
	    {
		const unparseclause uc = this->unparseclause_1;
		const unparseclauses ucs = this->unparseclauses_1;
		kc::unparse(ucs, kc_printer, kc_current_view);
		kc::unparse(uc, kc_printer, kc_current_view);
	    }
	    break;
	}
	case view_check_enum: {
	    view_check_class& kc_current_view=static_cast<view_check_class&>(kc_current_view_base);
	    {
		const unparseclause uc = this->unparseclause_1;
		const unparseclauses ucs = this->unparseclauses_1;
		kc::unparse(ucs, kc_printer, kc_current_view);
		kc::unparse(uc, kc_printer, kc_current_view);
	    }
	    break;
	}

	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    { /* Alternative( *, args ) -> [view_gen_unparsedefs_default_c: */
		for (unparseclauses iterator_ = this; iterator_->unparseclauses_1 != 0; iterator_ = iterator_->unparseclauses_1)
		    iterator_->unparseclause_1->unparse(kc_printer, kc_current_view);
	    }
	    break;
	}
    }
}

void
impl_unparseclauses::nil_do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case view_checklanguagenames_enum: {
	    view_checklanguagenames_class& kc_current_view=static_cast<view_checklanguagenames_class&>(kc_current_view_base);
	    {
	    }
	    break;
	}
	case view_make_patternreps_enum: {
	    view_make_patternreps_class& kc_current_view=static_cast<view_make_patternreps_class&>(kc_current_view_base);
	    {
	    }
	    break;
	}
	case view_check_viewnames_enum: {
	    view_check_viewnames_class& kc_current_view=static_cast<view_check_viewnames_class&>(kc_current_view_base);
	    {
	    }
	    break;
	}
	case view_check_enum: {
	    view_check_class& kc_current_view=static_cast<view_check_class&>(kc_current_view_base);
	    {
	    }
	    break;
	}

	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    { /* Alternative( *, args ) -> [view_gen_unparsedefs_default_c: */
	    }
	    break;
	}
    }
}


void
impl_unparseclause_UnparseClause::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case view_checklanguagenames_enum: {
	    view_checklanguagenames_class& kc_current_view=static_cast<view_checklanguagenames_class&>(kc_current_view_base);
	    {
		const unparseitems ui = this->unparseitems_1;
		kc::unparse(ui, kc_printer, kc_current_view);
	    }
	    break;
	}
	case view_gen_unparsedefs_other_c_enum: {
	    view_gen_unparsedefs_other_c_class& kc_current_view=static_cast<view_gen_unparsedefs_other_c_class&>(kc_current_view_base);
	    {
		const unparseitems ui = this->unparseitems_1;
		kc::unparse(ui, kc_printer, kc_current_view);
	    }
	    break;
	}
	case view_gen_unparsedefs_default_c_enum: {
	    view_gen_unparsedefs_default_c_class& kc_current_view=static_cast<view_gen_unparsedefs_default_c_class&>(kc_current_view_base);
	    {
		const unparseitems ui = this->unparseitems_1;
		kc::unparse(ui, kc_printer, kc_current_view);
	    }
	    break;
	}
	case view_make_patternreps_enum: {
	    view_make_patternreps_class& kc_current_view=static_cast<view_make_patternreps_class&>(kc_current_view_base);
	    {
		const unparseitems u_i = this->unparseitems_1;
		kc::unparse(u_i, kc_printer, kc_current_view);
	    }
	    break;
	}
	case view_check_viewnames_enum: {
	    view_check_viewnames_class& kc_current_view=static_cast<view_check_viewnames_class&>(kc_current_view_base);
	    {
		const unparseitems ui = this->unparseitems_1;
		The_current_unparseitems=ui; 
		kc::unparse(ui, kc_printer, kc_current_view);
		The_current_unparseitems=NULL; 
	    }
	    break;
	}
	case view_check_enum: {
	    view_check_class& kc_current_view=static_cast<view_check_class&>(kc_current_view_base);
	    {
		const viewnames vn = this->viewnames_1;
		const unparseitems ui = this->unparseitems_1;
		kc::unparse(vn, kc_printer, view_check_u);
		kc::unparse(ui, kc_printer, kc_current_view);
	    }
	    break;
	}

	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    { /* Alternative( *, args ) -> [view_gen_unparsedefs_default_c: */
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}

void
impl_viewnames::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    if(is_nil())
	nil_do_unparse(kc_printer, kc_current_view_base);
    else
	switch(kc_current_view_base) {
	case view_rview_class_def_enum: {
	    view_rview_class_def_class& kc_current_view=static_cast<view_rview_class_def_class&>(kc_current_view_base);
	    {
		const viewnames node = this/**/;
		const ID vn = this->ID_1;
		const viewnames r_vn = this->viewnames_1;
		kc::unparse(r_vn, kc_printer, kc_current_view);
		if(!node->is_extern) 
		{
		    { kc_printer(kc_t("struct "), kc_current_view); }
		    if(g_options.dllexports!="") {
			PRINT(g_options.dllexports.c_str());
			PRINT(" ");
		    } 
		    kc::unparse(vn, kc_printer, kc_current_view);
		    { kc_printer(kc_t("_class: rview_class {\
\n	"), kc_current_view); }
		    kc::unparse(vn, kc_printer, kc_current_view);
		    { kc_printer(kc_t("_class():rview_class("), kc_current_view); }
		    kc::unparse(vn, kc_printer, kc_current_view);
		    { kc_printer(kc_t("_enum){}\
\n};\
\nextern "), kc_current_view); }
		    kc::unparse(vn, kc_printer, kc_current_view);
		    { kc_printer(kc_t("_class "), kc_current_view); }
		    kc::unparse(vn, kc_printer, kc_current_view);
		    { kc_printer(kc_t(";\
\n"), kc_current_view); }
		}
		else 
		{
		    { kc_printer(kc_t("class "), kc_current_view); }
		    if(g_options.dllexports!="") {
			PRINT(g_options.dllexports.c_str());
			PRINT(" ");
		    } 
		    kc::unparse(vn, kc_printer, kc_current_view);
		    { kc_printer(kc_t("_baseclass: public rview_class {\
\n\rprotected:\v\
\n	"), kc_current_view); }
		    kc::unparse(vn, kc_printer, kc_current_view);
		    { kc_printer(kc_t("_baseclass():rview_class("), kc_current_view); }
		    kc::unparse(vn, kc_printer, kc_current_view);
		    { kc_printer(kc_t("_enum){}\
\n};\
\n// class "), kc_current_view); }
		    kc::unparse(vn, kc_printer, kc_current_view);
		    { kc_printer(kc_t("_class is defined externally\
\n"), kc_current_view); }
		}
	    }
	    break;
	}
	case view_uview_class_def_enum: {
	    view_uview_class_def_class& kc_current_view=static_cast<view_uview_class_def_class&>(kc_current_view_base);
	    {
		const viewnames node = this/**/;
		const ID vn = this->ID_1;
		const viewnames r_vn = this->viewnames_1;
		kc::unparse(r_vn, kc_printer, kc_current_view);
		if(!node->is_extern) 
		{
		    { kc_printer(kc_t("struct "), kc_current_view); }
		    if(g_options.dllexports!="") {
			PRINT(g_options.dllexports.c_str());
			PRINT(" ");
		    } 
		    kc::unparse(vn, kc_printer, kc_current_view);
		    { kc_printer(kc_t("_class: uview_class {\
\n	"), kc_current_view); }
		    kc::unparse(vn, kc_printer, kc_current_view);
		    { kc_printer(kc_t("_class():uview_class("), kc_current_view); }
		    kc::unparse(vn, kc_printer, kc_current_view);
		    { kc_printer(kc_t("_enum){}\
\n};\
\nextern "), kc_current_view); }
		    kc::unparse(vn, kc_printer, kc_current_view);
		    { kc_printer(kc_t("_class "), kc_current_view); }
		    kc::unparse(vn, kc_printer, kc_current_view);
		    { kc_printer(kc_t(";\
\n"), kc_current_view); }
		}
		else 
		{
		    { kc_printer(kc_t("class "), kc_current_view); }
		    if(g_options.dllexports!="") {
			PRINT(g_options.dllexports.c_str());
			PRINT(" ");
		    } 
		    kc::unparse(vn, kc_printer, kc_current_view);
		    { kc_printer(kc_t("_baseclass: public uview_class {\
\n\rprotected:\v\
\n	"), kc_current_view); }
		    kc::unparse(vn, kc_printer, kc_current_view);
		    { kc_printer(kc_t("_baseclass():uview_class("), kc_current_view); }
		    kc::unparse(vn, kc_printer, kc_current_view);
		    { kc_printer(kc_t("_enum){}\
\n};\
\n// class "), kc_current_view); }
		    kc::unparse(vn, kc_printer, kc_current_view);
		    { kc_printer(kc_t("_class is defined externally\
\n"), kc_current_view); }
		}
	    }
	    break;
	}
	case view_gen_viewvars_c_enum: {
	    view_gen_viewvars_c_class& kc_current_view=static_cast<view_gen_viewvars_c_class&>(kc_current_view_base);
	    if ((this->viewnames_1->prod_sel() == sel_Nilviewnames)) {
		const viewnames node = this/**/;
		const ID vn = this->ID_1;
		if(!node->is_extern) 
		{
		    kc::unparse(vn, kc_printer, kc_current_view);
		    { kc_printer(kc_t("_class "), kc_current_view); }
		    kc::unparse(vn, kc_printer, kc_current_view);
		    { kc_printer(kc_t(";\
\n"), kc_current_view); }
		}
	    } else
	    {
		const viewnames node = this/**/;
		const ID vn = this->ID_1;
		const viewnames r_vn = this->viewnames_1;
		kc::unparse(r_vn, kc_printer, kc_current_view);
		if(!node->is_extern) 
		{
		    kc::unparse(vn, kc_printer, kc_current_view);
		    { kc_printer(kc_t("_class "), kc_current_view); }
		    kc::unparse(vn, kc_printer, kc_current_view);
		    { kc_printer(kc_t(";\
\n"), kc_current_view); }
		}
	    }
	    break;
	}
	case view_gen_unpk_c_enum: {
	    view_gen_unpk_c_class& kc_current_view=static_cast<view_gen_unpk_c_class&>(kc_current_view_base);
	    {
		const viewnames node = this/**/;
		const ID vn = this->ID_1;
		const viewnames r_vn = this->viewnames_1;
		kc::unparse(r_vn, kc_printer, kc_current_view);
		if(!node->is_extern) 
		{
		    { kc_printer(kc_t("{\""), kc_current_view); }
		    kc::unparse(vn, kc_printer, kc_current_view);
		    { kc_printer(kc_t("\",&"), kc_current_view); }
		    kc::unparse(vn, kc_printer, kc_current_view);
		    { kc_printer(kc_t("},\
\n	"), kc_current_view); }
		}
		else
		{
		    { kc_printer(kc_t("{\""), kc_current_view); }
		    kc::unparse(vn, kc_printer, kc_current_view);
		    { kc_printer(kc_t("\", 0},\
\n	"), kc_current_view); }
		}
	    }
	    break;
	}
	case view_uview_def_enum: {
	    view_uview_def_class& kc_current_view=static_cast<view_uview_def_class&>(kc_current_view_base);
	    {
		const ID vn = this->ID_1;
		const viewnames r_vn = this->viewnames_1;
		kc::unparse(r_vn, kc_printer, kc_current_view);
		kc::unparse(vn, kc_printer, kc_current_view);
		{ kc_printer(kc_t("_enum"), kc_current_view); }
		{ kc_printer(kc_t(",\n\t"), kc_current_view); }
	    }
	    break;
	}
	case view_gen_unparsedecls_h_enum: {
	    view_gen_unparsedecls_h_class& kc_current_view=static_cast<view_gen_unparsedecls_h_class&>(kc_current_view_base);
	    if ((this->viewnames_1->prod_sel() == sel_Nilviewnames)) {
		const ID vn = this->ID_1;
		{ kc_printer(kc_t("\t"), kc_current_view); }
		kc::unparse(vn, kc_printer, kc_current_view);
	    } else
	    {
		const ID vn = this->ID_1;
		const viewnames r_vn = this->viewnames_1;
		kc::unparse(r_vn, kc_printer, kc_current_view);
		{ kc_printer(kc_t(",\n\t"), kc_current_view); }
		kc::unparse(vn, kc_printer, kc_current_view);
	    }
	    break;
	}
	case view_gen_rewritek_c_enum: {
	    view_gen_rewritek_c_class& kc_current_view=static_cast<view_gen_rewritek_c_class&>(kc_current_view_base);
	    {
		const viewnames node = this/**/;
		const ID vn = this->ID_1;
		const viewnames r_vn = this->viewnames_1;
		kc::unparse(r_vn, kc_printer, kc_current_view);
		if(!node->is_extern) 
		{
		    { kc_printer(kc_t("{\""), kc_current_view); }
		    kc::unparse(vn, kc_printer, kc_current_view);
		    { kc_printer(kc_t("\",&"), kc_current_view); }
		    kc::unparse(vn, kc_printer, kc_current_view);
		    { kc_printer(kc_t("},\
\n	"), kc_current_view); }
		}
		else
		{
		    { kc_printer(kc_t("{\""), kc_current_view); }
		    kc::unparse(vn, kc_printer, kc_current_view);
		    { kc_printer(kc_t("\", 0},\
\n	"), kc_current_view); }
		}
	    }
	    break;
	}
	case view_gen_rewritek_h_enum: {
	    view_gen_rewritek_h_class& kc_current_view=static_cast<view_gen_rewritek_h_class&>(kc_current_view_base);
	    {
		const ID vn = this->ID_1;
		const viewnames r_vn = this->viewnames_1;
		kc::unparse(r_vn, kc_printer, kc_current_view);
		kc::unparse(vn, kc_printer, kc_current_view);
		{ kc_printer(kc_t("_enum"), kc_current_view); }
		{ kc_printer(kc_t(",\n\t"), kc_current_view); }
	    }
	    break;
	}
	case view_check_r_enum: {
	    view_check_r_class& kc_current_view=static_cast<view_check_r_class&>(kc_current_view_base);
	    {
		const ID vn = this->ID_1;
		const viewnames vns = this->viewnames_1;
		kc::unparse(vns, kc_printer, kc_current_view);
		if (pg_rviewshavebeendefined)
		f_useoccurrviewname( vn );
		else
		v_extendoccur_nowarning( vn, ITUserRView() );
		v_add_to_rviewnames( vn );

	    }
	    break;
	}
	case view_check_u_enum: {
	    view_check_u_class& kc_current_view=static_cast<view_check_u_class&>(kc_current_view_base);
	    {
		const ID vn = this->ID_1;
		const viewnames vns = this->viewnames_1;
		kc::unparse(vns, kc_printer, kc_current_view);
		if (pg_uviewshavebeendefined)
		f_useoccuruviewname( vn );
		else
		v_extendoccur_nowarning( vn, ITUserUView() );
		v_add_to_uviewnames( vn );

	    }
	    break;
	}

	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    { /* Alternative( *, args ) -> [view_gen_unparsedefs_default_c: */
		for (viewnames iterator_ = this; iterator_->viewnames_1 != 0; iterator_ = iterator_->viewnames_1)
		    iterator_->ID_1->unparse(kc_printer, kc_current_view);
	    }
	    break;
	}
    }
}

void
impl_viewnames::nil_do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case view_gen_viewvars_c_enum: {
	    view_gen_viewvars_c_class& kc_current_view=static_cast<view_gen_viewvars_c_class&>(kc_current_view_base);
	    {
	    }
	    break;
	}
	case view_gen_unpk_c_enum: {
	    view_gen_unpk_c_class& kc_current_view=static_cast<view_gen_unpk_c_class&>(kc_current_view_base);
	    {
	    }
	    break;
	}
	case view_uview_def_enum: {
	    view_uview_def_class& kc_current_view=static_cast<view_uview_def_class&>(kc_current_view_base);
	    {
	    }
	    break;
	}
	case view_gen_unparsedecls_h_enum: {
	    view_gen_unparsedecls_h_class& kc_current_view=static_cast<view_gen_unparsedecls_h_class&>(kc_current_view_base);
	    {
	    }
	    break;
	}
	case view_gen_rewritek_c_enum: {
	    view_gen_rewritek_c_class& kc_current_view=static_cast<view_gen_rewritek_c_class&>(kc_current_view_base);
	    {
	    }
	    break;
	}
	case view_gen_rewritek_h_enum: {
	    view_gen_rewritek_h_class& kc_current_view=static_cast<view_gen_rewritek_h_class&>(kc_current_view_base);
	    {
	    }
	    break;
	}
	case view_check_r_enum: {
	    view_check_r_class& kc_current_view=static_cast<view_check_r_class&>(kc_current_view_base);
	    {
	    }
	    break;
	}
	case view_check_u_enum: {
	    view_check_u_class& kc_current_view=static_cast<view_check_u_class&>(kc_current_view_base);
	    {
	    }
	    break;
	}

	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    { /* Alternative( *, args ) -> [view_gen_unparsedefs_default_c: */
	    }
	    break;
	}
    }
}

void
impl_unparseitems::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    if(is_nil())
	nil_do_unparse(kc_printer, kc_current_view_base);
    else
	switch(kc_current_view_base) {
	case view_output_collection_enum: {
	    view_output_collection_class& kc_current_view=static_cast<view_output_collection_class&>(kc_current_view_base);
	    if ((this->unparseitems_1->prod_sel() == sel_Nilunparseitems)) {
		const unparseitem head = this->unparseitem_1;
		kc::unparse(head, kc_printer, kc_current_view);
	    } else
	    {
		const unparseitem head = this->unparseitem_1;
		const unparseitems tail = this->unparseitems_1;
		kc::unparse(head, kc_printer, kc_current_view);
		{ kc_printer(kc_t(" "), kc_current_view); }
		kc::unparse(tail, kc_printer, kc_current_view);
	    }
	    break;
	}
	case view_checklanguagenames_enum: {
	    view_checklanguagenames_class& kc_current_view=static_cast<view_checklanguagenames_class&>(kc_current_view_base);
	    {
		const unparseitem ui = this->unparseitem_1;
		const unparseitems uis = this->unparseitems_1;
		kc::unparse(uis, kc_printer, kc_current_view);
		kc::unparse(ui, kc_printer, kc_current_view);
	    }
	    break;
	}
	case view_gen_unparsedefs_other_c_enum: {
	    view_gen_unparsedefs_other_c_class& kc_current_view=static_cast<view_gen_unparsedefs_other_c_class&>(kc_current_view_base);
	    {
		const unparseitem a_ui = this->unparseitem_1;
		const unparseitems r_ui = this->unparseitems_1;
		kc::unparse(r_ui, kc_printer, kc_current_view);
		kc::unparse(a_ui, kc_printer, kc_current_view);
	    }
	    break;
	}
	case view_gen_unparsedefs_default_c_enum: {
	    view_gen_unparsedefs_default_c_class& kc_current_view=static_cast<view_gen_unparsedefs_default_c_class&>(kc_current_view_base);
	    {
		const unparseitem a_ui = this->unparseitem_1;
		const unparseitems r_ui = this->unparseitems_1;
		kc::unparse(r_ui, kc_printer, kc_current_view);
		kc::unparse(a_ui, kc_printer, kc_current_view);
	    }
	    break;
	}
	case view_make_patternreps_enum: {
	    view_make_patternreps_class& kc_current_view=static_cast<view_make_patternreps_class&>(kc_current_view_base);
	    {
		const unparseitem a_ui = this->unparseitem_1;
		const unparseitems r_ui = this->unparseitems_1;
		kc::unparse(r_ui, kc_printer, kc_current_view);
		kc::unparse(a_ui, kc_printer, kc_current_view);
	    }
	    break;
	}
	case view_check_viewnames_enum: {
	    view_check_viewnames_class& kc_current_view=static_cast<view_check_viewnames_class&>(kc_current_view_base);
	    {
		const unparseitem ui = this->unparseitem_1;
		const unparseitems uis = this->unparseitems_1;
		kc::unparse(uis, kc_printer, kc_current_view);
		kc::unparse(ui, kc_printer, kc_current_view);
	    }
	    break;
	}
	case view_check_enum: {
	    view_check_class& kc_current_view=static_cast<view_check_class&>(kc_current_view_base);
	    {
		const unparseitem ui = this->unparseitem_1;
		const unparseitems uis = this->unparseitems_1;
		kc::unparse(uis, kc_printer, kc_current_view);
		kc::unparse(ui, kc_printer, kc_current_view);
	    }
	    break;
	}

	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    { /* Alternative( *, args ) -> [view_gen_unparsedefs_default_c: */
		for (unparseitems iterator_ = this; iterator_->unparseitems_1 != 0; iterator_ = iterator_->unparseitems_1)
		    iterator_->unparseitem_1->unparse(kc_printer, kc_current_view);
	    }
	    break;
	}
    }
}

void
impl_unparseitems::nil_do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case view_output_collection_enum: {
	    view_output_collection_class& kc_current_view=static_cast<view_output_collection_class&>(kc_current_view_base);
	    {
		{ kc_printer(kc_t("\t\"\""), kc_current_view); }
	    }
	    break;
	}
	case view_checklanguagenames_enum: {
	    view_checklanguagenames_class& kc_current_view=static_cast<view_checklanguagenames_class&>(kc_current_view_base);
	    {
	    }
	    break;
	}
	case view_gen_unparsedefs_other_c_enum: {
	    view_gen_unparsedefs_other_c_class& kc_current_view=static_cast<view_gen_unparsedefs_other_c_class&>(kc_current_view_base);
	    {
	    }
	    break;
	}
	case view_gen_unparsedefs_default_c_enum: {
	    view_gen_unparsedefs_default_c_class& kc_current_view=static_cast<view_gen_unparsedefs_default_c_class&>(kc_current_view_base);
	    {
	    }
	    break;
	}
	case view_make_patternreps_enum: {
	    view_make_patternreps_class& kc_current_view=static_cast<view_make_patternreps_class&>(kc_current_view_base);
	    {
	    }
	    break;
	}
	case view_check_viewnames_enum: {
	    view_check_viewnames_class& kc_current_view=static_cast<view_check_viewnames_class&>(kc_current_view_base);
	    {
	    }
	    break;
	}
	case view_check_enum: {
	    view_check_class& kc_current_view=static_cast<view_check_class&>(kc_current_view_base);
	    {
	    }
	    break;
	}

	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    { /* Alternative( *, args ) -> [view_gen_unparsedefs_default_c: */
	    }
	    break;
	}
    }
}


void
impl_unparseitem_UViewVarDecl::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case view_gen_unparsedefs_other_c_enum: {
	    view_gen_unparsedefs_other_c_class& kc_current_view=static_cast<view_gen_unparsedefs_other_c_class&>(kc_current_view_base);
	    if ((this->Cexpression_1->prod_sel() == sel_NilCexpression)) {
		const ID type = this->ID_1;
		const ID name = this->ID_2;
		{ kc_printer(kc_t("\t"), kc_current_view); }
		kc::unparse(type, kc_printer, kc_current_view);
		{ kc_printer(kc_t("_class "), kc_current_view); }
		kc::unparse(name, kc_printer, kc_current_view);
		{ kc_printer(kc_t(";\
\n"), kc_current_view); }
	    } else
	    {
		const ID type = this->ID_1;
		const ID name = this->ID_2;
		const Cexpression expr = this->Cexpression_1;
		{ kc_printer(kc_t("\t"), kc_current_view); }
		kc::unparse(type, kc_printer, kc_current_view);
		{ kc_printer(kc_t("_class "), kc_current_view); }
		kc::unparse(name, kc_printer, kc_current_view);
		kc::unparse(expr, kc_printer, view_gen_initializephyla_c);
		{ kc_printer(kc_t(";\
\n"), kc_current_view); }
	    }
	    break;
	}
	case view_gen_unparsedefs_default_c_enum: {
	    view_gen_unparsedefs_default_c_class& kc_current_view=static_cast<view_gen_unparsedefs_default_c_class&>(kc_current_view_base);
	    if ((this->Cexpression_1->prod_sel() == sel_NilCexpression)) {
		const ID type = this->ID_1;
		const ID name = this->ID_2;
		{ kc_printer(kc_t("\t"), kc_current_view); }
		kc::unparse(type, kc_printer, kc_current_view);
		{ kc_printer(kc_t("_class "), kc_current_view); }
		kc::unparse(name, kc_printer, kc_current_view);
		{ kc_printer(kc_t(";\
\n"), kc_current_view); }
	    } else
	    {
		const ID type = this->ID_1;
		const ID name = this->ID_2;
		const Cexpression expr = this->Cexpression_1;
		{ kc_printer(kc_t("\t"), kc_current_view); }
		kc::unparse(type, kc_printer, kc_current_view);
		{ kc_printer(kc_t("_class "), kc_current_view); }
		kc::unparse(name, kc_printer, kc_current_view);
		kc::unparse(expr, kc_printer, view_gen_initializephyla_c);
		{ kc_printer(kc_t(";\
\n"), kc_current_view); }
	    }
	    break;
	}
	case view_check_viewnames_enum: {
	    view_check_viewnames_class& kc_current_view=static_cast<view_check_viewnames_class&>(kc_current_view_base);
	    {
		const ID vno = this->ID_1;
		kc::unparse(vno, kc_printer, kc_current_view);
	    }
	    break;
	}

	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    { /* Alternative( *, args ) -> [view_gen_unparsedefs_default_c: */
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


void
impl_unparseitem_UnpBody::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case view_checklanguagenames_enum: {
	    view_checklanguagenames_class& kc_current_view=static_cast<view_checklanguagenames_class&>(kc_current_view_base);
	    if ((this->languageoption_1->prod_sel() == sel_NoLanguagename)) {
		const unparseitems items = this->unparseitems_1;
		kc::unparse(items, kc_printer, kc_current_view);
	    } else
		if ((this->languageoption_1->prod_sel() == sel_LanguageList)) {
		const languagenames qual = phylum_cast<const impl_languageoption_LanguageList*>(this->languageoption_1)->languagenames_1;
		const unparseitems items = this->unparseitems_1;
		f_useoccurlanguagename(qual); 
		kc::unparse(items, kc_printer, kc_current_view);
	    } else
		    goto kc_unparsing_default;
	    break;
	}
	case view_gen_unparsedefs_other_c_enum: {
	    view_gen_unparsedefs_other_c_class& kc_current_view=static_cast<view_gen_unparsedefs_other_c_class&>(kc_current_view_base);
	    {
		const languageoption lang = this->languageoption_1;
		const unparseitems a_unparseitems = this->unparseitems_1;
		kc::unparse(lang, kc_printer, kc_current_view);
		{ kc_printer(kc_t("{\
\n"), kc_current_view); }
		kc::unparse(a_unparseitems, kc_printer, kc_current_view);
		{ kc_printer(kc_t(" }\
\n"), kc_current_view); }
	    }
	    break;
	}
	case view_gen_unparsedefs_default_c_enum: {
	    view_gen_unparsedefs_default_c_class& kc_current_view=static_cast<view_gen_unparsedefs_default_c_class&>(kc_current_view_base);
	    {
		const languageoption lang = this->languageoption_1;
		const unparseitems a_unparseitems = this->unparseitems_1;
		kc::unparse(lang, kc_printer, kc_current_view);
		{ kc_printer(kc_t("{\
\n"), kc_current_view); }
		kc::unparse(a_unparseitems, kc_printer, kc_current_view);
		{ kc_printer(kc_t(" }\
\n"), kc_current_view); }
	    }
	    break;
	}
	case view_make_patternreps_enum: {
	    view_make_patternreps_class& kc_current_view=static_cast<view_make_patternreps_class&>(kc_current_view_base);
	    {
		const unparseitems ui = this->unparseitems_1;
		kc::unparse(ui, kc_printer, kc_current_view);
	    }
	    break;
	}
	case view_check_enum: {
	    view_check_class& kc_current_view=static_cast<view_check_class&>(kc_current_view_base);
	    {
		const unparseitems ui = this->unparseitems_1;
		kc::unparse(ui, kc_printer, kc_current_view);
	    }
	    break;
	}

	default:
	kc_unparsing_default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    { /* Alternative( *, args ) -> [view_gen_unparsedefs_default_c: */
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


void
impl_unparseitem_UnpCtext::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case view_checklanguagenames_enum: {
	    view_checklanguagenames_class& kc_current_view=static_cast<view_checklanguagenames_class&>(kc_current_view_base);
	    if ((this->languageoption_1->prod_sel() == sel_NoLanguagename)) {
	    } else
		if ((this->languageoption_1->prod_sel() == sel_LanguageList)) {
		const languagenames qual = phylum_cast<const impl_languageoption_LanguageList*>(this->languageoption_1)->languagenames_1;
		f_useoccurlanguagename(qual); 
			} else
		    goto kc_unparsing_default;
	    break;
	}
	case view_gen_unparsedefs_other_c_enum: {
	    view_gen_unparsedefs_other_c_class& kc_current_view=static_cast<view_gen_unparsedefs_other_c_class&>(kc_current_view_base);
	    {
		const languageoption lang = this->languageoption_1;
		const Ctext ct = this->Ctext_1;
		kc::unparse(lang, kc_printer, kc_current_view);
		if(lang->prod_sel()==sel_LanguageList) 
		{
		    { kc_printer(kc_t("{\n"), kc_current_view); }
		}
		if(g_options.linedirec) 
		{
		    kc::unparse(pg_line, kc_printer, kc_current_view);
		    kc::unparse(ct->line, kc_printer, kc_current_view);
		    { kc_printer(kc_t(" \""), kc_current_view); }
		    PRINT(g_options.dir_line.c_str()); 
		    kc::unparse(ct->file, kc_printer, view_filename);
		    { kc_printer(kc_t("\"\n"), kc_current_view); }
		}
		kc::unparse(ct, kc_printer, view_gen_initializephyla_c);
		kc::unparse(g_emptystring, kc_printer, view_printer_outputfileline);
		if(lang->prod_sel()==sel_LanguageList) 
		{
		    { kc_printer(kc_t("}\n"), kc_current_view); }
		}
	    }
	    break;
	}
	case view_gen_unparsedefs_default_c_enum: {
	    view_gen_unparsedefs_default_c_class& kc_current_view=static_cast<view_gen_unparsedefs_default_c_class&>(kc_current_view_base);
	    {
		const languageoption lang = this->languageoption_1;
		const Ctext ct = this->Ctext_1;
		kc::unparse(lang, kc_printer, kc_current_view);
		if(lang->prod_sel()==sel_LanguageList) 
		{
		    { kc_printer(kc_t("{\n"), kc_current_view); }
		}
		if(g_options.linedirec) 
		{
		    kc::unparse(pg_line, kc_printer, kc_current_view);
		    kc::unparse(ct->line, kc_printer, kc_current_view);
		    { kc_printer(kc_t(" \""), kc_current_view); }
		    PRINT(g_options.dir_line.c_str()); 
		    kc::unparse(ct->file, kc_printer, view_filename);
		    { kc_printer(kc_t("\"\n"), kc_current_view); }
		}
		kc::unparse(ct, kc_printer, view_gen_initializephyla_c);
		kc::unparse(g_emptystring, kc_printer, view_printer_outputfileline);
		if(lang->prod_sel()==sel_LanguageList) 
		{
		    { kc_printer(kc_t("}\n"), kc_current_view); }
		}
	    }
	    break;
	}
	case view_make_patternreps_enum: {
	    view_make_patternreps_class& kc_current_view=static_cast<view_make_patternreps_class&>(kc_current_view_base);
	    {
		const Ctext ct = this->Ctext_1;
		kc::unparse(ct, kc_printer, kc_current_view);
	    }
	    break;
	}
	case view_check_enum: {
	    view_check_class& kc_current_view=static_cast<view_check_class&>(kc_current_view_base);
	    {
		const Ctext ct = this->Ctext_1;
		kc::unparse(ct, kc_printer, kc_current_view);
	    }
	    break;
	}

	default:
	kc_unparsing_default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    { /* Alternative( *, args ) -> [view_gen_unparsedefs_default_c: */
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


void
impl_unparseitem_UnpSubexpr::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case view_checklanguagenames_enum: {
	    view_checklanguagenames_class& kc_current_view=static_cast<view_checklanguagenames_class&>(kc_current_view_base);
	    if ((this->languageoption_1->prod_sel() == sel_NoLanguagename)) {
	    } else
		if ((this->languageoption_1->prod_sel() == sel_LanguageList)) {
		const languagenames qual = phylum_cast<const impl_languageoption_LanguageList*>(this->languageoption_1)->languagenames_1;
		f_useoccurlanguagename(qual); 
			} else
		    goto kc_unparsing_default;
	    break;
	}
	case view_gen_unparsedefs_other_c_enum: {
	    view_gen_unparsedefs_other_c_class& kc_current_view=static_cast<view_gen_unparsedefs_other_c_class&>(kc_current_view_base);
	    {
		const languageoption lang = this->languageoption_1;
		const unpsubterm sub = this->unpsubterm_1;
		const viewnameoption a_vnameopt = this->viewnameoption_1;
		ID phy = f_typeofunpsubterm( sub, operatorstack.top() ); 
		kc::unparse(lang, kc_printer, kc_current_view);
		{ kc_printer(kc_t("kc::unparse("), kc_current_view); }
		kc::unparse(sub, kc_printer, kc_current_view);
		{ kc_printer(kc_t(", kc_printer, "), kc_current_view); }
		kc::unparse(a_vnameopt, kc_printer, kc_current_view);
		{ kc_printer(kc_t(");\
\n"), kc_current_view); }
	    }
	    break;
	}
	case view_gen_unparsedefs_default_c_enum: {
	    view_gen_unparsedefs_default_c_class& kc_current_view=static_cast<view_gen_unparsedefs_default_c_class&>(kc_current_view_base);
	    {
		const languageoption lang = this->languageoption_1;
		const unpsubterm sub = this->unpsubterm_1;
		const viewnameoption a_vnameopt = this->viewnameoption_1;
		ID phy = f_typeofunpsubterm( sub, operatorstack.top() ); 
		kc::unparse(lang, kc_printer, kc_current_view);
		{ kc_printer(kc_t("kc::unparse("), kc_current_view); }
		kc::unparse(sub, kc_printer, kc_current_view);
		{ kc_printer(kc_t(", kc_printer, "), kc_current_view); }
		kc::unparse(a_vnameopt, kc_printer, kc_current_view);
		{ kc_printer(kc_t(");\
\n"), kc_current_view); }
	    }
	    break;
	}
	case view_check_viewnames_enum: {
	    view_check_viewnames_class& kc_current_view=static_cast<view_check_viewnames_class&>(kc_current_view_base);
	    {
		const viewnameoption vno = this->viewnameoption_1;
		kc::unparse(vno, kc_printer, kc_current_view);
	    }
	    break;
	}
	case view_check_enum: {
	    view_check_class& kc_current_view=static_cast<view_check_class&>(kc_current_view_base);
	    {
		const unpsubterm us = this->unpsubterm_1;
		kc::unparse(us, kc_printer, kc_current_view);
	    }
	    break;
	}

	default:
	kc_unparsing_default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    { /* Alternative( *, args ) -> [view_gen_unparsedefs_default_c: */
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


void
impl_unparseitem_UnpStr::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case view_collect_strings_enum: {
	    view_collect_strings_class& kc_current_view=static_cast<view_collect_strings_class&>(kc_current_view_base);
	    {
		add_string_to_collection(this); 
	    }
	    break;
	}
	case view_output_collection_enum: {
	    view_output_collection_class& kc_current_view=static_cast<view_output_collection_class&>(kc_current_view_base);
	    {
		const CexpressionDQ expr = this->CexpressionDQ_1;
		{ kc_printer(kc_t("\t\""), kc_current_view); }
		kc::unparse(expr, kc_printer, kc_current_view);
		{ kc_printer(kc_t("\""), kc_current_view); }
	    }
	    break;
	}
	case view_checklanguagenames_enum: {
	    view_checklanguagenames_class& kc_current_view=static_cast<view_checklanguagenames_class&>(kc_current_view_base);
	    if ((this->languageoption_1->prod_sel() == sel_NoLanguagename)) {
	    } else
		if ((this->languageoption_1->prod_sel() == sel_LanguageList)) {
		const languagenames qual = phylum_cast<const impl_languageoption_LanguageList*>(this->languageoption_1)->languagenames_1;
		f_useoccurlanguagename(qual); 
			} else
		    goto kc_unparsing_default;
	    break;
	}
	case view_gen_unparsedefs_other_c_enum: {
	    view_gen_unparsedefs_other_c_class& kc_current_view=static_cast<view_gen_unparsedefs_other_c_class&>(kc_current_view_base);
	    {
		const CexpressionDQ a_CexpressionDQ = this->CexpressionDQ_1;
		const viewnameoption a_vnameopt = this->viewnameoption_1;
		ug_viewnameopt = a_vnameopt; 
		 if(pg_languageshavebeendefined) 
		{

		    static char buf[10];
		    static long last_nr=-1;
		    sprintf(buf,"%d",this->text_nr);

		    if(last_nr!=this->text_nr) 
		    {
			last_nr=this->text_nr;  
				{ kc_printer(kc_t("       { kc_printer(LANG_TEXT("), kc_current_view); }
			kc_printer( buf, base_uview ); 
				{ kc_printer(kc_t("), "), kc_current_view); }
			kc::unparse(a_vnameopt, kc_printer, kc_current_view);
			{ kc_printer(kc_t("); }\n"), kc_current_view); }
		    }
		}
		else 
		{
		    kc_printer( "", view_no_of_printed_string_chars_reset ); 
		    	{ kc_printer(kc_t("	{ kc_printer(kc_t(\""), kc_current_view); }
		    kc::unparse(a_CexpressionDQ, kc_printer, view_gen_unpstr_c);
		    { kc_printer(kc_t("\"), "), kc_current_view); }
		    kc::unparse(a_vnameopt, kc_printer, kc_current_view);
		    { kc_printer(kc_t("); }\
\n"), kc_current_view); }
		}
		ug_viewnameopt = 0; 
	    }
	    break;
	}
	case view_gen_unparsedefs_default_c_enum: {
	    view_gen_unparsedefs_default_c_class& kc_current_view=static_cast<view_gen_unparsedefs_default_c_class&>(kc_current_view_base);
	    {
		const CexpressionDQ a_CexpressionDQ = this->CexpressionDQ_1;
		const viewnameoption a_vnameopt = this->viewnameoption_1;
		ug_viewnameopt = a_vnameopt; 
		 if(pg_languageshavebeendefined) 
		{

		    static char buf[10];
		    static long last_nr=-1;
		    sprintf(buf,"%d",this->text_nr);

		    if(last_nr!=this->text_nr) 
		    {
			last_nr=this->text_nr;  
				{ kc_printer(kc_t("       { kc_printer(LANG_TEXT("), kc_current_view); }
			kc_printer( buf, base_uview ); 
				{ kc_printer(kc_t("), "), kc_current_view); }
			kc::unparse(a_vnameopt, kc_printer, kc_current_view);
			{ kc_printer(kc_t("); }\n"), kc_current_view); }
		    }
		}
		else 
		{
		    kc_printer( "", view_no_of_printed_string_chars_reset ); 
		    	{ kc_printer(kc_t("	{ kc_printer(kc_t(\""), kc_current_view); }
		    kc::unparse(a_CexpressionDQ, kc_printer, view_gen_unpstr_c);
		    { kc_printer(kc_t("\"), "), kc_current_view); }
		    kc::unparse(a_vnameopt, kc_printer, kc_current_view);
		    { kc_printer(kc_t("); }\
\n"), kc_current_view); }
		}
		ug_viewnameopt = 0; 
	    }
	    break;
	}
	case view_check_viewnames_enum: {
	    view_check_viewnames_class& kc_current_view=static_cast<view_check_viewnames_class&>(kc_current_view_base);
	    {
		const viewnameoption vno = this->viewnameoption_1;
		kc::unparse(vno, kc_printer, kc_current_view);
	    }
	    break;
	}
	case view_check_enum: {
	    view_check_class& kc_current_view=static_cast<view_check_class&>(kc_current_view_base);
	    {
	    }
	    break;
	}

	default:
	kc_unparsing_default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    { /* Alternative( *, args ) -> [view_gen_unparsedefs_default_c: */
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


void
impl_unpsubterm_UnpCastedVariable::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case view_gen_unparsedefs_other_c_enum: {
	    view_gen_unparsedefs_other_c_class& kc_current_view=static_cast<view_gen_unparsedefs_other_c_class&>(kc_current_view_base);
	    {
		const ID a_id = this->ID_2;
		kc::unparse(a_id, kc_printer, kc_current_view);
	    }
	    break;
	}
	case view_gen_unparsedefs_default_c_enum: {
	    view_gen_unparsedefs_default_c_class& kc_current_view=static_cast<view_gen_unparsedefs_default_c_class&>(kc_current_view_base);
	    {
		const ID a_id = this->ID_2;
		kc::unparse(a_id, kc_printer, kc_current_view);
	    }
	    break;
	}
	case view_check_enum: {
	    view_check_class& kc_current_view=static_cast<view_check_class&>(kc_current_view_base);
	    {
	    }
	    break;
	}

	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    { /* Alternative( *, args ) -> [view_gen_unparsedefs_default_c: */
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


void
impl_unpsubterm_UnpDollarvarAttr::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case view_gen_unparsedefs_other_c_enum: {
	    view_gen_unparsedefs_other_c_class& kc_current_view=static_cast<view_gen_unparsedefs_other_c_class&>(kc_current_view_base);
	    {
		const unpattributes a_unpattributes = this->unpattributes_1;
		kc::unparse(this, kc_printer, view_gen_initializephyla_c);
		kc::unparse(a_unpattributes, kc_printer, kc_current_view);
	    }
	    break;
	}
	case view_gen_unparsedefs_default_c_enum: {
	    view_gen_unparsedefs_default_c_class& kc_current_view=static_cast<view_gen_unparsedefs_default_c_class&>(kc_current_view_base);
	    {
		const unpattributes a_unpattributes = this->unpattributes_1;
		kc::unparse(this, kc_printer, view_gen_initializephyla_c);
		kc::unparse(a_unpattributes, kc_printer, kc_current_view);
	    }
	    break;
	}
	case view_gen_initializephyla_c_enum: {
	    view_gen_initializephyla_c_class& kc_current_view=static_cast<view_gen_initializephyla_c_class&>(kc_current_view_base);
	    {
		const INT i = this->INT_1;
		ID oid = f_emptyId(), dollarvar = dollarvarstack.top(), dollarvarext = dollarvarextstack.top();
		argument arg;
		bool nulvar = true;
		{
		    INT kc_selvar_0_1 = phylum_cast<INT>( i );
		    if ((kc_selvar_0_1->prod_sel() == sel_Int)) {
			const integer ii = phylum_cast<const impl_INT_Int*>(kc_selvar_0_1)->integer_1;

			if (ii->value != 0) {
			    nulvar = false;
			    oid = operatorstack.top();
			    arg = f_argumentofoperator( oid, i );
			}   
				} else
			kc_no_default_in_with( "", __LINE__, __FILE__ );
		}

		if (nulvar) 
		{
		    kc::unparse(dollarvar, kc_printer, kc_current_view);
		    kc::unparse(dollarvarext, kc_printer, kc_current_view);
		}
		else 
		{
		    kc::unparse(dollarvar, kc_printer, kc_current_view);
		    kc::unparse(dollarvarext, kc_printer, kc_current_view);
		    { kc_printer(kc_t("->"), kc_current_view); }
		    kc::unparse(arg, kc_printer, kc_current_view);
		    arg->free( false );  
		     }
	    }
	    break;
	}
	case view_check_enum: {
	    view_check_class& kc_current_view=static_cast<view_check_class&>(kc_current_view_base);
	    {
		const INT i = this->INT_1;
		const unpattributes unp_a = this->unpattributes_1;
		v_check_dollarvar_attribute_in_operators( i, unp_a, outmostoperators.top() ); 
	    }
	    break;
	}

	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    { /* Alternative( *, args ) -> [view_gen_unparsedefs_default_c: */
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


void
impl_unpsubterm_UnpSubAttr::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case view_gen_unparsedefs_other_c_enum: {
	    view_gen_unparsedefs_other_c_class& kc_current_view=static_cast<view_gen_unparsedefs_other_c_class&>(kc_current_view_base);
	    {
		const ID st = this->ID_1;
		const unpattributes a_unpattributes = this->unpattributes_1;
		kc::unparse(st, kc_printer, kc_current_view);
		kc::unparse(a_unpattributes, kc_printer, kc_current_view);
	    }
	    break;
	}
	case view_gen_unparsedefs_default_c_enum: {
	    view_gen_unparsedefs_default_c_class& kc_current_view=static_cast<view_gen_unparsedefs_default_c_class&>(kc_current_view_base);
	    {
		const ID st = this->ID_1;
		const unpattributes a_unpattributes = this->unpattributes_1;
		kc::unparse(st, kc_printer, kc_current_view);
		kc::unparse(a_unpattributes, kc_printer, kc_current_view);
	    }
	    break;
	}
	case view_check_enum: {
	    view_check_class& kc_current_view=static_cast<view_check_class&>(kc_current_view_base);
	    {
		const ID v_id = this->ID_1;
		const unpattributes unp_a = this->unpattributes_1;
		ID p_id;
		if (f_useoccurpatternvariable( v_id ) && (p_id = f_phylumofpatternvariable( v_id)))
		f_check_unpattributes_in_phylum( unp_a, p_id );
		v_syn_type_attribute_ID( v_id );

	    }
	    break;
	}

	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    { /* Alternative( *, args ) -> [view_gen_unparsedefs_default_c: */
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


void
impl_unpsubterm_UnpDollarvarTerm::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case view_gen_unparsedefs_other_c_enum: {
	    view_gen_unparsedefs_other_c_class& kc_current_view=static_cast<view_gen_unparsedefs_other_c_class&>(kc_current_view_base);
	    {
		kc::unparse(this, kc_printer, view_gen_initializephyla_c);
	    }
	    break;
	}
	case view_gen_unparsedefs_default_c_enum: {
	    view_gen_unparsedefs_default_c_class& kc_current_view=static_cast<view_gen_unparsedefs_default_c_class&>(kc_current_view_base);
	    {
		kc::unparse(this, kc_printer, view_gen_initializephyla_c);
	    }
	    break;
	}
	case view_gen_initializephyla_c_enum: {
	    view_gen_initializephyla_c_class& kc_current_view=static_cast<view_gen_initializephyla_c_class&>(kc_current_view_base);
	    {
		const INT i = this->INT_1;
		ID oid = f_emptyId(), dollarvar = dollarvarstack.top(), dollarvarext = dollarvarextstack.top();
		argument arg;
		bool nulvar = true;
		{
		    INT kc_selvar_0_1 = phylum_cast<INT>( i );
		    if ((kc_selvar_0_1->prod_sel() == sel_Int)) {
			const integer ii = phylum_cast<const impl_INT_Int*>(kc_selvar_0_1)->integer_1;

			if (ii->value != 0) {
			    nulvar = false;
			    oid = operatorstack.top();
			    arg = f_argumentofoperator( oid, i );
			}   
				} else
			kc_no_default_in_with( "", __LINE__, __FILE__ );
		}

		if (nulvar) 
		{
		    kc::unparse(dollarvar, kc_printer, kc_current_view);
		    kc::unparse(dollarvarext, kc_printer, kc_current_view);
		}
		else 
		{
		    kc::unparse(dollarvar, kc_printer, kc_current_view);
		    kc::unparse(dollarvarext, kc_printer, kc_current_view);
		    { kc_printer(kc_t("->"), kc_current_view); }
		    kc::unparse(arg, kc_printer, kc_current_view);
		    arg->free( false );  
		     }
	    }
	    break;
	}
	case view_check_enum: {
	    view_check_class& kc_current_view=static_cast<view_check_class&>(kc_current_view_base);
	    {
		const INT i = this->INT_1;
		v_check_dollarvar_attribute_in_operators( i, Nilunpattributes(),
		    outmostoperators.top() );

	    }
	    break;
	}

	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    { /* Alternative( *, args ) -> [view_gen_unparsedefs_default_c: */
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


void
impl_unpsubterm_UnpSubTerm::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case view_gen_unparsedefs_other_c_enum: {
	    view_gen_unparsedefs_other_c_class& kc_current_view=static_cast<view_gen_unparsedefs_other_c_class&>(kc_current_view_base);
	    {
		const ID st = this->ID_1;
		kc::unparse(st, kc_printer, kc_current_view);
	    }
	    break;
	}
	case view_gen_unparsedefs_default_c_enum: {
	    view_gen_unparsedefs_default_c_class& kc_current_view=static_cast<view_gen_unparsedefs_default_c_class&>(kc_current_view_base);
	    {
		const ID st = this->ID_1;
		kc::unparse(st, kc_printer, kc_current_view);
	    }
	    break;
	}
	case view_check_enum: {
	    view_check_class& kc_current_view=static_cast<view_check_class&>(kc_current_view_base);
	    {
		const ID id = this->ID_1;







	    }
	    break;
	}

	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    { /* Alternative( *, args ) -> [view_gen_unparsedefs_default_c: */
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}

void
impl_unpattributes::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    if(is_nil())
	nil_do_unparse(kc_printer, kc_current_view_base);
    else
	switch(kc_current_view_base) {
	case view_gen_unparsedefs_other_c_enum: {
	    view_gen_unparsedefs_other_c_class& kc_current_view=static_cast<view_gen_unparsedefs_other_c_class&>(kc_current_view_base);
	    {
		const ID a_attr = this->ID_1;
		const unpattributes r_attr = this->unpattributes_1;
		kc::unparse(r_attr, kc_printer, kc_current_view);
		{ kc_printer(kc_t("->"), kc_current_view); }
		kc::unparse(a_attr, kc_printer, kc_current_view);
	    }
	    break;
	}
	case view_gen_unparsedefs_default_c_enum: {
	    view_gen_unparsedefs_default_c_class& kc_current_view=static_cast<view_gen_unparsedefs_default_c_class&>(kc_current_view_base);
	    {
		const ID a_attr = this->ID_1;
		const unpattributes r_attr = this->unpattributes_1;
		kc::unparse(r_attr, kc_printer, kc_current_view);
		{ kc_printer(kc_t("->"), kc_current_view); }
		kc::unparse(a_attr, kc_printer, kc_current_view);
	    }
	    break;
	}

	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    { /* Alternative( *, args ) -> [view_gen_unparsedefs_default_c: */
		for (unpattributes iterator_ = this; iterator_->unpattributes_1 != 0; iterator_ = iterator_->unpattributes_1)
		    iterator_->ID_1->unparse(kc_printer, kc_current_view);
	    }
	    break;
	}
    }
}

void
impl_unpattributes::nil_do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case view_gen_unparsedefs_other_c_enum: {
	    view_gen_unparsedefs_other_c_class& kc_current_view=static_cast<view_gen_unparsedefs_other_c_class&>(kc_current_view_base);
	    {
	    }
	    break;
	}
	case view_gen_unparsedefs_default_c_enum: {
	    view_gen_unparsedefs_default_c_class& kc_current_view=static_cast<view_gen_unparsedefs_default_c_class&>(kc_current_view_base);
	    {
	    }
	    break;
	}

	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    { /* Alternative( *, args ) -> [view_gen_unparsedefs_default_c: */
	    }
	    break;
	}
    }
}


void
impl_viewnameoption_YesViewname::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case view_gen_unparsedefs_other_c_enum: {
	    view_gen_unparsedefs_other_c_class& kc_current_view=static_cast<view_gen_unparsedefs_other_c_class&>(kc_current_view_base);
	    {
		const ID v = this->ID_1;
		kc::unparse(v, kc_printer, kc_current_view);
	    }
	    break;
	}
	case view_gen_unparsedefs_default_c_enum: {
	    view_gen_unparsedefs_default_c_class& kc_current_view=static_cast<view_gen_unparsedefs_default_c_class&>(kc_current_view_base);
	    {
		const ID v = this->ID_1;
		kc::unparse(v, kc_printer, kc_current_view);
	    }
	    break;
	}
	case view_check_viewnames_enum: {
	    view_check_viewnames_class& kc_current_view=static_cast<view_check_viewnames_class&>(kc_current_view_base);
	    {
		const ID vn = this->ID_1;
		if(!is_uview_var(vn)) f_useoccuruviewname( vn ); 
	    }
	    break;
	}

	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    { /* Alternative( *, args ) -> [view_gen_unparsedefs_default_c: */
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


void
impl_viewnameoption_NoViewname::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case view_gen_unparsedefs_other_c_enum: {
	    view_gen_unparsedefs_other_c_class& kc_current_view=static_cast<view_gen_unparsedefs_other_c_class&>(kc_current_view_base);
	    {
		{ kc_printer(kc_t("kc_current_view"), kc_current_view); }
	    }
	    break;
	}
	case view_gen_unparsedefs_default_c_enum: {
	    view_gen_unparsedefs_default_c_class& kc_current_view=static_cast<view_gen_unparsedefs_default_c_class&>(kc_current_view_base);
	    {
		{ kc_printer(kc_t("kc_current_view"), kc_current_view); }
	    }
	    break;
	}
	case view_check_viewnames_enum: {
	    view_check_viewnames_class& kc_current_view=static_cast<view_check_viewnames_class&>(kc_current_view_base);
	    {
	    }
	    break;
	}

	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    { /* Alternative( *, args ) -> [view_gen_unparsedefs_default_c: */
	    }
	    break;
	}
    }
}


void
impl_languageoption_LanguageList::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case view_gen_unparsedefs_other_c_enum: {
	    view_gen_unparsedefs_other_c_class& kc_current_view=static_cast<view_gen_unparsedefs_other_c_class&>(kc_current_view_base);
	    {
		const languagenames langs = this->languagenames_1;
		{ kc_printer(kc_t("if("), kc_current_view); }
		kc::unparse(langs, kc_printer, kc_current_view);
		{ kc_printer(kc_t(")\n    "), kc_current_view); }
	    }
	    break;
	}
	case view_gen_unparsedefs_default_c_enum: {
	    view_gen_unparsedefs_default_c_class& kc_current_view=static_cast<view_gen_unparsedefs_default_c_class&>(kc_current_view_base);
	    {
		const languagenames langs = this->languagenames_1;
		{ kc_printer(kc_t("if("), kc_current_view); }
		kc::unparse(langs, kc_printer, kc_current_view);
		{ kc_printer(kc_t(")\n    "), kc_current_view); }
	    }
	    break;
	}

	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    { /* Alternative( *, args ) -> [view_gen_unparsedefs_default_c: */
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


void
impl_languageoption_NoLanguagename::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case view_gen_unparsedefs_other_c_enum: {
	    view_gen_unparsedefs_other_c_class& kc_current_view=static_cast<view_gen_unparsedefs_other_c_class&>(kc_current_view_base);
	    {
	    }
	    break;
	}
	case view_gen_unparsedefs_default_c_enum: {
	    view_gen_unparsedefs_default_c_class& kc_current_view=static_cast<view_gen_unparsedefs_default_c_class&>(kc_current_view_base);
	    {
	    }
	    break;
	}

	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    { /* Alternative( *, args ) -> [view_gen_unparsedefs_default_c: */
	    }
	    break;
	}
    }
}

void
impl_languagenames::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    if(is_nil())
	nil_do_unparse(kc_printer, kc_current_view_base);
    else
	switch(kc_current_view_base) {
	case view_gen_unparsedefs_other_c_enum: {
	    view_gen_unparsedefs_other_c_class& kc_current_view=static_cast<view_gen_unparsedefs_other_c_class&>(kc_current_view_base);
	    if ((this->languagenames_1->prod_sel() == sel_Nillanguagenames)) {
		const ID id = this->ID_1;
		{ kc_printer(kc_t("is_language("), kc_current_view); }
		kc::unparse(id, kc_printer, base_uview);
		{ kc_printer(kc_t(")"), kc_current_view); }
	    } else
	    {
		const ID id = this->ID_1;
		const languagenames tail = this->languagenames_1;
		kc::unparse(tail, kc_printer, kc_current_view);
		{ kc_printer(kc_t(" || is_language("), kc_current_view); }
		kc::unparse(id, kc_printer, base_uview);
		{ kc_printer(kc_t(")"), kc_current_view); }
	    }
	    break;
	}
	case view_gen_unparsedefs_default_c_enum: {
	    view_gen_unparsedefs_default_c_class& kc_current_view=static_cast<view_gen_unparsedefs_default_c_class&>(kc_current_view_base);
	    if ((this->languagenames_1->prod_sel() == sel_Nillanguagenames)) {
		const ID id = this->ID_1;
		{ kc_printer(kc_t("is_language("), kc_current_view); }
		kc::unparse(id, kc_printer, base_uview);
		{ kc_printer(kc_t(")"), kc_current_view); }
	    } else
	    {
		const ID id = this->ID_1;
		const languagenames tail = this->languagenames_1;
		kc::unparse(tail, kc_printer, kc_current_view);
		{ kc_printer(kc_t(" || is_language("), kc_current_view); }
		kc::unparse(id, kc_printer, base_uview);
		{ kc_printer(kc_t(")"), kc_current_view); }
	    }
	    break;
	}
	case view_gen_unparsedecls_h_enum: {
	    view_gen_unparsedecls_h_class& kc_current_view=static_cast<view_gen_unparsedecls_h_class&>(kc_current_view_base);
	    if ((this->languagenames_1->prod_sel() == sel_Nillanguagenames)) {
		const ID id = this->ID_1;
		{ kc_printer(kc_t("extern char* kc_language_"), kc_current_view); }
		kc::unparse(id, kc_printer, kc_current_view);
		{ kc_printer(kc_t("[];\n"), kc_current_view); }
	    } else
	    {
		const ID id = this->ID_1;
		const languagenames tail = this->languagenames_1;
		kc::unparse(tail, kc_printer, kc_current_view);
		{ kc_printer(kc_t("extern char* kc_language_"), kc_current_view); }
		kc::unparse(id, kc_printer, kc_current_view);
		{ kc_printer(kc_t("[];\n"), kc_current_view); }
	    }
	    break;
	}

	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    { /* Alternative( *, args ) -> [view_gen_unparsedefs_default_c: */
		for (languagenames iterator_ = this; iterator_->languagenames_1 != 0; iterator_ = iterator_->languagenames_1)
		    iterator_->ID_1->unparse(kc_printer, kc_current_view);
	    }
	    break;
	}
    }
}

void
impl_languagenames::nil_do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    { /* Alternative( *, args ) -> [view_gen_unparsedefs_default_c: */
	    }
	    break;
	}
    }
}


void
impl_fileline_PosNoFileLine::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case view_error_enum: {
	    view_error_class& kc_current_view=static_cast<view_error_class&>(kc_current_view_base);
	    {
		if (pg_lineno != 0) 
		{
		    { kc_printer(kc_t(" at "), kc_current_view); }
		    if (strcmp(pg_filename->name, "") != 0) 
		    {
			kc::unparse(pg_filename, kc_printer, kc_current_view);
		    }
		    { kc_printer(kc_t(":"), kc_current_view); }
		    kc::unparse(pg_lineno, kc_printer, kc_current_view);
		    { kc_printer(kc_t(" col:"), kc_current_view); }
		    kc::unparse(pg_column, kc_printer, kc_current_view);
		}
	    }
	    break;
	}
	case view_error_format_enum: {
	    view_error_format_class& kc_current_view=static_cast<view_error_format_class&>(kc_current_view_base);
	    {
		if (pg_lineno != 0) {
		    if (strcmp(pg_filename->name, "") != 0) {
			kc_current_view.file(pg_filename->name);
		    }
		    kc_current_view.line(pg_lineno);
		    kc_current_view.column(pg_column);
		} 
	    }
	    break;
	}

	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    { /* Alternative( *, args ) -> [view_gen_unparsedefs_default_c: */
	    }
	    break;
	}
    }
}


void
impl_fileline_NoFileLine::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case view_error_enum: {
	    view_error_class& kc_current_view=static_cast<view_error_class&>(kc_current_view_base);
	    {
		if (pg_lineno != 0) 
		{
		    { kc_printer(kc_t(" at "), kc_current_view); }
		    if (strcmp(pg_filename->name, "") != 0) 
		    {
			kc::unparse(pg_filename, kc_printer, kc_current_view);
		    }
		    { kc_printer(kc_t(":"), kc_current_view); }
		    kc::unparse(pg_lineno, kc_printer, kc_current_view);
		}
	    }
	    break;
	}
	case view_error_format_enum: {
	    view_error_format_class& kc_current_view=static_cast<view_error_format_class&>(kc_current_view_base);
	    {
		if (pg_lineno != 0) {
		    if (strcmp(pg_filename->name, "") != 0) {
			kc_current_view.file(pg_filename->name);
		    }
		    kc_current_view.line(pg_lineno);
		} 
	    }
	    break;
	}

	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    { /* Alternative( *, args ) -> [view_gen_unparsedefs_default_c: */
	    }
	    break;
	}
    }
}


void
impl_fileline_FileLine::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case view_error_enum: {
	    view_error_class& kc_current_view=static_cast<view_error_class&>(kc_current_view_base);
	    {
		if (line != 0) 
		{
		    { kc_printer(kc_t(" at "), kc_current_view); }
		    if (strcmp(file->name, "") != 0) 
		    {
			kc::unparse(file, kc_printer, kc_current_view);
		    }
		    { kc_printer(kc_t(":"), kc_current_view); }
		    kc::unparse(line, kc_printer, kc_current_view);
		}
		else  if (pg_lineno != 0) 
		{
		    { kc_printer(kc_t(" at "), kc_current_view); }
		    if (strcmp(pg_filename->name, "") != 0) 
		    {
			kc::unparse(pg_filename, kc_printer, kc_current_view);
		    }
		    { kc_printer(kc_t(":"), kc_current_view); }
		    kc::unparse(pg_lineno, kc_printer, kc_current_view);
		}
	    }
	    break;
	}
	case view_error_format_enum: {
	    view_error_format_class& kc_current_view=static_cast<view_error_format_class&>(kc_current_view_base);
	    {
		if (line != 0) {
		    if (strcmp(file->name, "") != 0) {
			kc_current_view.file(file->name);
		    }
		    kc_current_view.line(line);
		} else  if (pg_lineno != 0) {
		    if (strcmp(pg_filename->name, "") != 0) {
			kc_current_view.file(pg_filename->name);
		    }
		    kc_current_view.line(pg_lineno);
		} 
	    }
	    break;
	}

	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    { /* Alternative( *, args ) -> [view_gen_unparsedefs_default_c: */
	    }
	    break;
	}
    }
}

void
impl_scopetypefilelinestack::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    if(is_nil())
	nil_do_unparse(kc_printer, kc_current_view_base);
    else
	switch(kc_current_view_base) {

	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    { /* Alternative( *, args ) -> [view_gen_unparsedefs_default_c: */
		for (scopetypefilelinestack iterator_ = this; iterator_->scopetypefilelinestack_1 != 0; iterator_ = iterator_->scopetypefilelinestack_1)
		    iterator_->scopetypefileline_1->unparse(kc_printer, kc_current_view);
	    }
	    break;
	}
    }
}

void
impl_scopetypefilelinestack::nil_do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    { /* Alternative( *, args ) -> [view_gen_unparsedefs_default_c: */
	    }
	    break;
	}
    }
}


void
impl_scopetypefileline_ScopeTypeFileLine::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    { /* Alternative( *, args ) -> [view_gen_unparsedefs_default_c: */
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


void
impl_IDtype_ITLanguageName::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    { /* Alternative( *, args ) -> [view_gen_unparsedefs_default_c: */
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


void
impl_IDtype_ITPatternVariable::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case view_error_tID_enum: {
	    view_error_tID_class& kc_current_view=static_cast<view_error_tID_class&>(kc_current_view_base);
	    {
		{ kc_printer(kc_t("(it's a "), kc_current_view); }
		kc::unparse(this, kc_printer, view_error);
		{ kc_printer(kc_t(")"), kc_current_view); }
	    }
	    break;
	}
	case view_error_enum: {
	    view_error_class& kc_current_view=static_cast<view_error_class&>(kc_current_view_base);
	    {
		{ kc_printer(kc_t("pattern variable"), kc_current_view); }
	    }
	    break;
	}

	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    { /* Alternative( *, args ) -> [view_gen_unparsedefs_default_c: */
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


void
impl_IDtype_ITUserFunction::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case view_error_tID_enum: {
	    view_error_tID_class& kc_current_view=static_cast<view_error_tID_class&>(kc_current_view_base);
	    {
		{ kc_printer(kc_t("(it's a "), kc_current_view); }
		kc::unparse(this, kc_printer, view_error);
		{ kc_printer(kc_t(")"), kc_current_view); }
	    }
	    break;
	}
	case view_error_enum: {
	    view_error_class& kc_current_view=static_cast<view_error_class&>(kc_current_view_base);
	    {
		{ kc_printer(kc_t("function"), kc_current_view); }
	    }
	    break;
	}

	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    { /* Alternative( *, args ) -> [view_gen_unparsedefs_default_c: */
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


void
impl_IDtype_ITUserRView::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case view_error_tID_enum: {
	    view_error_tID_class& kc_current_view=static_cast<view_error_tID_class&>(kc_current_view_base);
	    {
		{ kc_printer(kc_t("(it's a "), kc_current_view); }
		kc::unparse(this, kc_printer, view_error);
		{ kc_printer(kc_t(")"), kc_current_view); }
	    }
	    break;
	}
	case view_error_enum: {
	    view_error_class& kc_current_view=static_cast<view_error_class&>(kc_current_view_base);
	    {
		{ kc_printer(kc_t("rewrite view"), kc_current_view); }
	    }
	    break;
	}

	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    { /* Alternative( *, args ) -> [view_gen_unparsedefs_default_c: */
	    }
	    break;
	}
    }
}


void
impl_IDtype_ITPredefinedRView::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case view_error_tID_enum: {
	    view_error_tID_class& kc_current_view=static_cast<view_error_tID_class&>(kc_current_view_base);
	    {
		{ kc_printer(kc_t("(it's a "), kc_current_view); }
		kc::unparse(this, kc_printer, view_error);
		{ kc_printer(kc_t(")"), kc_current_view); }
	    }
	    break;
	}
	case view_error_enum: {
	    view_error_class& kc_current_view=static_cast<view_error_class&>(kc_current_view_base);
	    {
		{ kc_printer(kc_t("predefined rewrite view"), kc_current_view); }
	    }
	    break;
	}

	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    { /* Alternative( *, args ) -> [view_gen_unparsedefs_default_c: */
	    }
	    break;
	}
    }
}


void
impl_IDtype_ITUViewVar::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    { /* Alternative( *, args ) -> [view_gen_unparsedefs_default_c: */
	    }
	    break;
	}
    }
}


void
impl_IDtype_ITUserUView::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case view_error_tID_enum: {
	    view_error_tID_class& kc_current_view=static_cast<view_error_tID_class&>(kc_current_view_base);
	    {
		{ kc_printer(kc_t("(it's a "), kc_current_view); }
		kc::unparse(this, kc_printer, view_error);
		{ kc_printer(kc_t(")"), kc_current_view); }
	    }
	    break;
	}
	case view_error_enum: {
	    view_error_class& kc_current_view=static_cast<view_error_class&>(kc_current_view_base);
	    {
		{ kc_printer(kc_t("unparse view"), kc_current_view); }
	    }
	    break;
	}

	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    { /* Alternative( *, args ) -> [view_gen_unparsedefs_default_c: */
	    }
	    break;
	}
    }
}


void
impl_IDtype_ITPredefinedUView::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case view_error_tID_enum: {
	    view_error_tID_class& kc_current_view=static_cast<view_error_tID_class&>(kc_current_view_base);
	    {
		{ kc_printer(kc_t("(it's a "), kc_current_view); }
		kc::unparse(this, kc_printer, view_error);
		{ kc_printer(kc_t(")"), kc_current_view); }
	    }
	    break;
	}
	case view_error_enum: {
	    view_error_class& kc_current_view=static_cast<view_error_class&>(kc_current_view_base);
	    {
		{ kc_printer(kc_t("predefined unparse view"), kc_current_view); }
	    }
	    break;
	}

	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    { /* Alternative( *, args ) -> [view_gen_unparsedefs_default_c: */
	    }
	    break;
	}
    }
}


void
impl_IDtype_ITStorageClass::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case view_error_tID_enum: {
	    view_error_tID_class& kc_current_view=static_cast<view_error_tID_class&>(kc_current_view_base);
	    {
		{ kc_printer(kc_t("(it's a "), kc_current_view); }
		kc::unparse(this, kc_printer, view_error);
		{ kc_printer(kc_t(")"), kc_current_view); }
	    }
	    break;
	}
	case view_error_enum: {
	    view_error_class& kc_current_view=static_cast<view_error_class&>(kc_current_view_base);
	    {
		{ kc_printer(kc_t("storageclass"), kc_current_view); }
	    }
	    break;
	}

	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    { /* Alternative( *, args ) -> [view_gen_unparsedefs_default_c: */
	    }
	    break;
	}
    }
}


void
impl_IDtype_ITPredefinedStorageClass::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case view_error_tID_enum: {
	    view_error_tID_class& kc_current_view=static_cast<view_error_tID_class&>(kc_current_view_base);
	    {
		{ kc_printer(kc_t("(it's a "), kc_current_view); }
		kc::unparse(this, kc_printer, view_error);
		{ kc_printer(kc_t(")"), kc_current_view); }
	    }
	    break;
	}
	case view_error_enum: {
	    view_error_class& kc_current_view=static_cast<view_error_class&>(kc_current_view_base);
	    {
		{ kc_printer(kc_t("predefined storageclass"), kc_current_view); }
	    }
	    break;
	}

	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    { /* Alternative( *, args ) -> [view_gen_unparsedefs_default_c: */
	    }
	    break;
	}
    }
}


void
impl_IDtype_ITUserOperator::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case view_error_tID_enum: {
	    view_error_tID_class& kc_current_view=static_cast<view_error_tID_class&>(kc_current_view_base);
	    {
		{ kc_printer(kc_t("(it's an "), kc_current_view); }
		kc::unparse(this, kc_printer, view_error);
		{ kc_printer(kc_t(")"), kc_current_view); }
	    }
	    break;
	}
	case view_error_enum: {
	    view_error_class& kc_current_view=static_cast<view_error_class&>(kc_current_view_base);
	    {
		{ kc_printer(kc_t("operator"), kc_current_view); }
	    }
	    break;
	}

	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    { /* Alternative( *, args ) -> [view_gen_unparsedefs_default_c: */
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


void
impl_IDtype_ITPredefinedOperator::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case view_error_tID_enum: {
	    view_error_tID_class& kc_current_view=static_cast<view_error_tID_class&>(kc_current_view_base);
	    {
		{ kc_printer(kc_t("(it's a "), kc_current_view); }
		kc::unparse(this, kc_printer, view_error);
		{ kc_printer(kc_t(")"), kc_current_view); }
	    }
	    break;
	}
	case view_error_enum: {
	    view_error_class& kc_current_view=static_cast<view_error_class&>(kc_current_view_base);
	    {
		{ kc_printer(kc_t("predefined operator"), kc_current_view); }
	    }
	    break;
	}

	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    { /* Alternative( *, args ) -> [view_gen_unparsedefs_default_c: */
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


void
impl_IDtype_ITUserPhylum::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case view_error_tID_enum: {
	    view_error_tID_class& kc_current_view=static_cast<view_error_tID_class&>(kc_current_view_base);
	    {
		{ kc_printer(kc_t("(it's a "), kc_current_view); }
		kc::unparse(this, kc_printer, view_error);
		{ kc_printer(kc_t(")"), kc_current_view); }
	    }
	    break;
	}
	case view_error_enum: {
	    view_error_class& kc_current_view=static_cast<view_error_class&>(kc_current_view_base);
	    {
		{ kc_printer(kc_t("phylum"), kc_current_view); }
	    }
	    break;
	}

	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    { /* Alternative( *, args ) -> [view_gen_unparsedefs_default_c: */
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


void
impl_IDtype_ITPredefinedPhylum::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case view_error_tID_enum: {
	    view_error_tID_class& kc_current_view=static_cast<view_error_tID_class&>(kc_current_view_base);
	    {
		{ kc_printer(kc_t("(it's a "), kc_current_view); }
		kc::unparse(this, kc_printer, view_error);
		{ kc_printer(kc_t(")"), kc_current_view); }
	    }
	    break;
	}
	case view_error_enum: {
	    view_error_class& kc_current_view=static_cast<view_error_class&>(kc_current_view_base);
	    {
		{ kc_printer(kc_t("predefined phylum"), kc_current_view); }
	    }
	    break;
	}

	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    { /* Alternative( *, args ) -> [view_gen_unparsedefs_default_c: */
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


void
impl_IDtype_ITUnknown::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case view_error_tID_enum: {
	    view_error_tID_class& kc_current_view=static_cast<view_error_tID_class&>(kc_current_view_base);
	    {
	    }
	    break;
	}
	case view_error_enum: {
	    view_error_class& kc_current_view=static_cast<view_error_class&>(kc_current_view_base);
	    {
	    }
	    break;
	}

	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    { /* Alternative( *, args ) -> [view_gen_unparsedefs_default_c: */
	    }
	    break;
	}
    }
}

void
impl_operators::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    if(is_nil())
	nil_do_unparse(kc_printer, kc_current_view_base);
    else
	switch(kc_current_view_base) {

	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    { /* Alternative( *, args ) -> [view_gen_unparsedefs_default_c: */
		for (operators iterator_ = this; iterator_->operators_1 != 0; iterator_ = iterator_->operators_1)
		    iterator_->ID_1->unparse(kc_printer, kc_current_view);
	    }
	    break;
	}
    }
}

void
impl_operators::nil_do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    { /* Alternative( *, args ) -> [view_gen_unparsedefs_default_c: */
	    }
	    break;
	}
    }
}

void
impl_phyla::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    if(is_nil())
	nil_do_unparse(kc_printer, kc_current_view_base);
    else
	switch(kc_current_view_base) {
	case view_gen_printdotedges_c_enum: {
	    view_gen_printdotedges_c_class& kc_current_view=static_cast<view_gen_printdotedges_c_class&>(kc_current_view_base);
	    {
		const ID a_phy = this->ID_1;
		const phyla r_phy = this->phyla_1;
		kc::unparse(r_phy, kc_printer, kc_current_view);
		{ kc_printer(kc_t("	case phylum_"), kc_current_view); }
		kc::unparse(a_phy, kc_printer, kc_current_view);
		{ kc_printer(kc_t(": {\
\n	    kc_do_printdot_id_of__"), kc_current_view); }
		kc::unparse(a_phy, kc_printer, kc_current_view);
		{ kc_printer(kc_t("(kc_f, kc_p->ptr_to.yt_"), kc_current_view); }
		kc::unparse(a_phy, kc_printer, kc_current_view);
		{ kc_printer(kc_t(", use_context_when_sharing_leaves, kc_p->ptr_from.yt_voidptr, kc_p->son_nr);\
\n	break; }\
\n"), kc_current_view); }
	    }
	    break;
	}
	case view_gen_printdotdefs_c_enum: {
	    view_gen_printdotdefs_c_class& kc_current_view=static_cast<view_gen_printdotdefs_c_class&>(kc_current_view_base);
	    {
		const ID a_phy = this->ID_1;
		const phyla r_phy = this->phyla_1;

		assertionFailed("Not used anymore"); 
		kc::unparse(r_phy, kc_printer, kc_current_view);
		{ kc_printer(kc_t("    assertReason(kc_phy != phylum_"), kc_current_view); }
		kc::unparse(a_phy, kc_printer, kc_current_view);
		{ kc_printer(kc_t(", \"kc_do_printdot_phylum called with phylum_"), kc_current_view); }
		kc::unparse(a_phy, kc_printer, kc_current_view);
		{ kc_printer(kc_t(" argument\");\
\n"), kc_current_view); }
	    }
	    break;
	}

	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    { /* Alternative( *, args ) -> [view_gen_unparsedefs_default_c: */
		for (phyla iterator_ = this; iterator_->phyla_1 != 0; iterator_ = iterator_->phyla_1)
		    iterator_->ID_1->unparse(kc_printer, kc_current_view);
	    }
	    break;
	}
    }
}

void
impl_phyla::nil_do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case view_gen_printdotedges_c_enum: {
	    view_gen_printdotedges_c_class& kc_current_view=static_cast<view_gen_printdotedges_c_class&>(kc_current_view_base);
	    {
	    }
	    break;
	}
	case view_gen_printdotdefs_c_enum: {
	    view_gen_printdotdefs_c_class& kc_current_view=static_cast<view_gen_printdotdefs_c_class&>(kc_current_view_base);
	    {
	    }
	    break;
	}

	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    { /* Alternative( *, args ) -> [view_gen_unparsedefs_default_c: */
	    }
	    break;
	}
    }
}

void
impl_variables::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    if(is_nil())
	nil_do_unparse(kc_printer, kc_current_view_base);
    else
	switch(kc_current_view_base) {

	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    { /* Alternative( *, args ) -> [view_gen_unparsedefs_default_c: */
		for (variables iterator_ = this; iterator_->variables_1 != 0; iterator_ = iterator_->variables_1)
		    iterator_->ID_1->unparse(kc_printer, kc_current_view);
	    }
	    break;
	}
    }
}

void
impl_variables::nil_do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    { /* Alternative( *, args ) -> [view_gen_unparsedefs_default_c: */
	    }
	    break;
	}
    }
}


void
impl_dollarvarstatus_DVDisallowed::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    { /* Alternative( *, args ) -> [view_gen_unparsedefs_default_c: */
	    }
	    break;
	}
    }
}


void
impl_dollarvarstatus_DVAllowed::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    { /* Alternative( *, args ) -> [view_gen_unparsedefs_default_c: */
	    }
	    break;
	}
    }
}


void
impl_tribool_Bigger::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    { /* Alternative( *, args ) -> [view_gen_unparsedefs_default_c: */
	    }
	    break;
	}
    }
}


void
impl_tribool_Smaller::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    { /* Alternative( *, args ) -> [view_gen_unparsedefs_default_c: */
	    }
	    break;
	}
    }
}


void
impl_tribool_Equal::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    { /* Alternative( *, args ) -> [view_gen_unparsedefs_default_c: */
	    }
	    break;
	}
    }
}

void
impl_patternrepresentations::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    if(is_nil())
	nil_do_unparse(kc_printer, kc_current_view_base);
    else
	switch(kc_current_view_base) {

	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    { /* Alternative( *, args ) -> [view_gen_unparsedefs_default_c: */
		for (patternrepresentations iterator_ = this; iterator_->patternrepresentations_1 != 0; iterator_ = iterator_->patternrepresentations_1)
		    iterator_->patternrepresentation_1->unparse(kc_printer, kc_current_view);
	    }
	    break;
	}
    }
}

void
impl_patternrepresentations::nil_do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    { /* Alternative( *, args ) -> [view_gen_unparsedefs_default_c: */
	    }
	    break;
	}
    }
}

void
impl_patternrepresentation::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    if(is_nil())
	nil_do_unparse(kc_printer, kc_current_view_base);
    else
	switch(kc_current_view_base) {
	case view_unp_predicates_enum: {
	    view_unp_predicates_class& kc_current_view=static_cast<view_unp_predicates_class&>(kc_current_view_base);
	    if ((this->elem_patternrepresentation_1->prod_sel() == sel_PRUserPredicate) && (this->patternrepresentation_1->prod_sel() == sel_Nilpatternrepresentation)) {
		const Cexpression cexpr = phylum_cast<const impl_elem_patternrepresentation_PRUserPredicate*>(this->elem_patternrepresentation_1)->Cexpression_1;
		gl_outer_view=kc_current_view; 
			{ kc_printer(kc_t("KC_TRACE_PROVIDED(("), kc_current_view); }
		kc::unparse(cexpr, kc_printer, view_gen_user_predicates);
		{ kc_printer(kc_t("), \""), kc_current_view); }
		kc::unparse(cexpr->file, kc_printer, kc_current_view);
		{ kc_printer(kc_t("\", "), kc_current_view); }
		kc::unparse(cexpr->line, kc_printer, kc_current_view);
		{ kc_printer(kc_t(", this)"), kc_current_view); }
	    } else
		if ((this->elem_patternrepresentation_1->prod_sel() == sel_PRUserPredicate)) {
		const Cexpression cexpr = phylum_cast<const impl_elem_patternrepresentation_PRUserPredicate*>(this->elem_patternrepresentation_1)->Cexpression_1;
		const patternrepresentation r_p = this->patternrepresentation_1;
		gl_outer_view=kc_current_view; 
		kc::unparse(r_p, kc_printer, kc_current_view);
		{ kc_printer(kc_t(") && KC_TRACE_PROVIDED(("), kc_current_view); }
		kc::unparse(cexpr, kc_printer, view_gen_user_predicates);
		{ kc_printer(kc_t("), \""), kc_current_view); }
		kc::unparse(cexpr->file, kc_printer, kc_current_view);
		{ kc_printer(kc_t("\", "), kc_current_view); }
		kc::unparse(cexpr->line, kc_printer, kc_current_view);
		{ kc_printer(kc_t(", this"), kc_current_view); }
	    } else
		if ((this->patternrepresentation_1->prod_sel() == sel_Nilpatternrepresentation)) {
		const elem_patternrepresentation p = this->elem_patternrepresentation_1;
		kc::unparse(p, kc_printer, kc_current_view);
	    } else
	    {
		const elem_patternrepresentation p = this->elem_patternrepresentation_1;
		const patternrepresentation r_p = this->patternrepresentation_1;
		kc::unparse(p, kc_printer, kc_current_view);
		{ kc_printer(kc_t(") && ("), kc_current_view); }
		kc::unparse(r_p, kc_printer, kc_current_view);
	    }
	    break;
	}
	case view_wc_predicates_enum: {
	    view_wc_predicates_class& kc_current_view=static_cast<view_wc_predicates_class&>(kc_current_view_base);
	    if ((this->elem_patternrepresentation_1->prod_sel() == sel_PRUserPredicate) && (this->patternrepresentation_1->prod_sel() == sel_Nilpatternrepresentation)) {
		const Cexpression cexpr = phylum_cast<const impl_elem_patternrepresentation_PRUserPredicate*>(this->elem_patternrepresentation_1)->Cexpression_1;
		gl_outer_view=kc_current_view; 
			{ kc_printer(kc_t("KC_TRACE_PROVIDED(("), kc_current_view); }
		kc::unparse(cexpr, kc_printer, view_gen_user_predicates);
		{ kc_printer(kc_t("), \""), kc_current_view); }
		kc::unparse(cexpr->file, kc_printer, kc_current_view);
		{ kc_printer(kc_t("\", "), kc_current_view); }
		kc::unparse(cexpr->line, kc_printer, kc_current_view);
		{ kc_printer(kc_t(", this)"), kc_current_view); }
	    } else
		if ((this->elem_patternrepresentation_1->prod_sel() == sel_PRUserPredicate)) {
		const Cexpression cexpr = phylum_cast<const impl_elem_patternrepresentation_PRUserPredicate*>(this->elem_patternrepresentation_1)->Cexpression_1;
		const patternrepresentation r_p = this->patternrepresentation_1;
		gl_outer_view=kc_current_view; 
		kc::unparse(r_p, kc_printer, kc_current_view);
		{ kc_printer(kc_t(") && KC_TRACE_PROVIDED(("), kc_current_view); }
		kc::unparse(cexpr, kc_printer, view_gen_user_predicates);
		{ kc_printer(kc_t("), \""), kc_current_view); }
		kc::unparse(cexpr->file, kc_printer, kc_current_view);
		{ kc_printer(kc_t("\", "), kc_current_view); }
		kc::unparse(cexpr->line, kc_printer, kc_current_view);
		{ kc_printer(kc_t(", this"), kc_current_view); }
	    } else
		if ((this->patternrepresentation_1->prod_sel() == sel_Nilpatternrepresentation)) {
		const elem_patternrepresentation p = this->elem_patternrepresentation_1;
		kc::unparse(p, kc_printer, kc_current_view);
	    } else
	    {
		const elem_patternrepresentation p = this->elem_patternrepresentation_1;
		const patternrepresentation r_p = this->patternrepresentation_1;
		kc::unparse(p, kc_printer, kc_current_view);
		{ kc_printer(kc_t(") && ("), kc_current_view); }
		kc::unparse(r_p, kc_printer, kc_current_view);
	    }
	    break;
	}
	case view_rw_predicates_enum: {
	    view_rw_predicates_class& kc_current_view=static_cast<view_rw_predicates_class&>(kc_current_view_base);
	    if ((this->elem_patternrepresentation_1->prod_sel() == sel_PRUserPredicate) && (this->patternrepresentation_1->prod_sel() == sel_Nilpatternrepresentation)) {
		const Cexpression cexpr = phylum_cast<const impl_elem_patternrepresentation_PRUserPredicate*>(this->elem_patternrepresentation_1)->Cexpression_1;
		gl_outer_view=kc_current_view; 
			{ kc_printer(kc_t("KC_TRACE_PROVIDED(("), kc_current_view); }
		kc::unparse(cexpr, kc_printer, view_gen_user_predicates);
		{ kc_printer(kc_t("), \""), kc_current_view); }
		kc::unparse(cexpr->file, kc_printer, kc_current_view);
		{ kc_printer(kc_t("\", "), kc_current_view); }
		kc::unparse(cexpr->line, kc_printer, kc_current_view);
		{ kc_printer(kc_t(", this)"), kc_current_view); }
	    } else
		if ((this->elem_patternrepresentation_1->prod_sel() == sel_PRUserPredicate)) {
		const Cexpression cexpr = phylum_cast<const impl_elem_patternrepresentation_PRUserPredicate*>(this->elem_patternrepresentation_1)->Cexpression_1;
		const patternrepresentation r_p = this->patternrepresentation_1;
		gl_outer_view=kc_current_view; 
		kc::unparse(r_p, kc_printer, kc_current_view);
		{ kc_printer(kc_t(") && KC_TRACE_PROVIDED(("), kc_current_view); }
		kc::unparse(cexpr, kc_printer, view_gen_user_predicates);
		{ kc_printer(kc_t("), \""), kc_current_view); }
		kc::unparse(cexpr->file, kc_printer, kc_current_view);
		{ kc_printer(kc_t("\", "), kc_current_view); }
		kc::unparse(cexpr->line, kc_printer, kc_current_view);
		{ kc_printer(kc_t(", this"), kc_current_view); }
	    } else
		if ((this->patternrepresentation_1->prod_sel() == sel_Nilpatternrepresentation)) {
		const elem_patternrepresentation p = this->elem_patternrepresentation_1;
		kc::unparse(p, kc_printer, kc_current_view);
	    } else
	    {
		const elem_patternrepresentation p = this->elem_patternrepresentation_1;
		const patternrepresentation r_p = this->patternrepresentation_1;
		kc::unparse(p, kc_printer, kc_current_view);
		{ kc_printer(kc_t(") && ("), kc_current_view); }
		kc::unparse(r_p, kc_printer, kc_current_view);
	    }
	    break;
	}

	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    { /* Alternative( *, args ) -> [view_gen_unparsedefs_default_c: */
		for (patternrepresentation iterator_ = this; iterator_->patternrepresentation_1 != 0; iterator_ = iterator_->patternrepresentation_1)
		    iterator_->elem_patternrepresentation_1->unparse(kc_printer, kc_current_view);
	    }
	    break;
	}
    }
}

void
impl_patternrepresentation::nil_do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    { /* Alternative( *, args ) -> [view_gen_unparsedefs_default_c: */
	    }
	    break;
	}
    }
}


void
impl_elem_patternrepresentation_PRIntLiteral::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    if ((this->path_1->prod_sel() == sel_Conspath)) {
		const path p = this->path_1;
		const path r_p = (this->path_1)->path_1;
		const INT i = this->INT_1;
		{ kc_printer(kc_t("("), kc_current_view); }
		kc::unparse(r_p, kc_printer, view_gen_cast);
		kc::unparse(p, kc_printer, kc_current_view);
		{ kc_printer(kc_t(")->value == "), kc_current_view); }
		kc::unparse(i, kc_printer, kc_current_view);
	    } else
	    { /* Alternative( *, args ) -> [view_gen_unparsedefs_default_c: */
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


void
impl_elem_patternrepresentation_PRStringLiteral::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    if ((this->path_1->prod_sel() == sel_Conspath)) {
		const path p = this->path_1;
		const path r_p = (this->path_1)->path_1;
		const CexpressionDQ Cexprdq = this->CexpressionDQ_1;
		if ((strcmp( f_strofID( f_typeof( p ) ), "casestring" ) == 0) ||
		    (strcmp( f_strofID( f_typeof( p ) ), "nocasestring" ) == 0)) { 
		    	{ kc_printer(kc_t("kc_strcmp("), kc_current_view); }
		    kc::unparse(r_p, kc_printer, view_gen_cast);
		    kc::unparse(p, kc_printer, kc_current_view);
		    { kc_printer(kc_t("->name, kc_t(\""), kc_current_view); }
		    kc::unparse(Cexprdq, kc_printer, kc_current_view);
		    { kc_printer(kc_t("\"))==0"), kc_current_view); }
		} else {

		    assertionFailed("String literal type neither casestring nor nocasestring");
		} 
			} else
	    { /* Alternative( *, args ) -> [view_gen_unparsedefs_default_c: */
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


void
impl_elem_patternrepresentation_PRDefault::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		{ kc_printer(kc_t("1 /*default*/"), kc_current_view); }
	    }
	    break;
	}
    }
}


void
impl_elem_patternrepresentation_PRWildcard::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		{ kc_printer(kc_t("1 /*default*/"), kc_current_view); }
	    }
	    break;
	}
    }
}


void
impl_elem_patternrepresentation_PRNonLeafBinding::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case view_predicate_bindings_enum: {
	    view_predicate_bindings_class& kc_current_view=static_cast<view_predicate_bindings_class&>(kc_current_view_base);
	    if ((this->ID_1->prod_sel() == sel_Id) && (phylum_cast<const impl_ID_Id*>(this->ID_1)->uniqID_1->prod_sel() == sel_Str)) {
		const path p = this->path_1;
		const casestring id = phylum_cast<const impl_uniqID_Str*>(phylum_cast<const impl_ID_Id*>(this->ID_1)->uniqID_1)->casestring_1;
		gl_bindings[id->name]=p; 
			} else
		    goto kc_unparsing_default;
	    break;
	}

	default:
	kc_unparsing_default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		const path p = this->path_1;
		const ID id = this->ID_1;
		{
		    ID gl_type;
		    if (this->type->eq( f_emptyId())) {
			gl_type = f_typeof( p );
		    } else {
			gl_type = this->type;
		    }   
		     if(g_options.linedirec) 
		    {
			kc::unparse(pg_line, kc_printer, kc_current_view);
			kc::unparse(id->line, kc_printer, kc_current_view);
			{ kc_printer(kc_t(" \""), kc_current_view); }
			PRINT(g_options.dir_line.c_str()); 
			kc::unparse(id->file, kc_printer, view_filename);
			{ kc_printer(kc_t("\"\n"), kc_current_view); }
		    }
		    { kc_printer(kc_t("	const "), kc_current_view); }
		    kc::unparse(gl_type, kc_printer, kc_current_view);
		    { kc_printer(kc_t(" "), kc_current_view); }
		    kc::unparse(id, kc_printer, kc_current_view);
		    { kc_printer(kc_t(" = "), kc_current_view); }
		    {
			path kc_selvar_0_1 = phylum_cast<path>(p);
			if ((kc_selvar_0_1->prod_sel() == sel_Conspath)) {
			    const path r_p = (kc_selvar_0_1)->path_1;
			    r_p->unparse(kc_printer, view_gen_cast); 
			    	} else
			    if ((kc_selvar_0_1->prod_sel() == sel_Nilpath)) {

			} else
			    kc_no_default_in_with( "", __LINE__, __FILE__ );
		    }

		    kc::unparse(p, kc_printer, kc_current_view);
		    { kc_printer(kc_t(";\
\n"), kc_current_view); }
		}
	    }
	    break;
	}
    }
}


void
impl_elem_patternrepresentation_PRUserPredicate::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    { /* Alternative( *, args ) -> [view_gen_unparsedefs_default_c: */
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


void
impl_elem_patternrepresentation_PROperPredicate::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case view_unp_predicates_enum: {
	    view_unp_predicates_class& kc_current_view=static_cast<view_unp_predicates_class&>(kc_current_view_base);
	    if ((this->path_1->prod_sel() == sel_Conspath) && ((this->path_1)->path_1->prod_sel() == sel_Conspath)) {
		const path p = (this->path_1)->path_1;
		const path r_p = ((this->path_1)->path_1)->path_1;
		const ID id = this->ID_1;
		kc::unparse(r_p, kc_printer, view_gen_cast);
		kc::unparse(p, kc_printer, kc_current_view);
		{ kc_printer(kc_t("->prod_sel() == sel_"), kc_current_view); }
		kc::unparse(id, kc_printer, kc_current_view);
	    } else
		if ((this->path_1->prod_sel() == sel_Nilpath)) {
	    } else
	    {
		{ kc_printer(kc_t(" true "), kc_current_view); }
	    }
	    break;
	}

	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    if ((this->path_1->prod_sel() == sel_Conspath) && ((this->path_1)->path_1->prod_sel() == sel_Conspath)) {
		const path p = (this->path_1)->path_1;
		const path r_p = ((this->path_1)->path_1)->path_1;
		const ID id = this->ID_1;
		kc::unparse(r_p, kc_printer, view_gen_cast);
		kc::unparse(p, kc_printer, kc_current_view);
		{ kc_printer(kc_t("->prod_sel() == sel_"), kc_current_view); }
		kc::unparse(id, kc_printer, kc_current_view);
	    } else
		if ((this->path_1->prod_sel() == sel_Nilpath)) {
	    } else
	    { /* Alternative( *, args ) -> [view_gen_unparsedefs_default_c: */
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


void
impl_elem_patternrepresentation_PRVarPredicate::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		const paths ps = this->paths_1;
		kc::unparse(ps, kc_printer, kc_current_view);
	    }
	    break;
	}
    }
}


void
impl_elem_patternrepresentation_PRBinding::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case view_predicate_bindings_enum: {
	    view_predicate_bindings_class& kc_current_view=static_cast<view_predicate_bindings_class&>(kc_current_view_base);
	    if ((this->ID_1->prod_sel() == sel_Id) && (phylum_cast<const impl_ID_Id*>(this->ID_1)->uniqID_1->prod_sel() == sel_Str)) {
		const path p = this->path_1;
		const casestring id = phylum_cast<const impl_uniqID_Str*>(phylum_cast<const impl_ID_Id*>(this->ID_1)->uniqID_1)->casestring_1;
		gl_bindings[id->name]=p; 
			} else
		    goto kc_unparsing_default;
	    break;
	}

	default:
	kc_unparsing_default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		const path p = this->path_1;
		const ID id = this->ID_1;
		{
		    ID gl_type;
		    if (this->type->eq( f_emptyId())) {
			gl_type = f_typeof( p );
		    } else {
			gl_type = this->type;
		    }   
		     if(g_options.linedirec) 
		    {
			kc::unparse(pg_line, kc_printer, kc_current_view);
			kc::unparse(id->line, kc_printer, kc_current_view);
			{ kc_printer(kc_t(" \""), kc_current_view); }
			PRINT(g_options.dir_line.c_str()); 
			kc::unparse(id->file, kc_printer, view_filename);
			{ kc_printer(kc_t("\"\n"), kc_current_view); }
		    }
		    { kc_printer(kc_t("	const "), kc_current_view); }
		    kc::unparse(gl_type, kc_printer, kc_current_view);
		    { kc_printer(kc_t(" "), kc_current_view); }
		    kc::unparse(id, kc_printer, kc_current_view);
		    { kc_printer(kc_t(" = "), kc_current_view); }
		    {
			path kc_selvar_0_1 = phylum_cast<path>(p);
			if ((kc_selvar_0_1->prod_sel() == sel_Conspath)) {
			    const path r_p = (kc_selvar_0_1)->path_1;
			    r_p->unparse(kc_printer, view_gen_cast); 
			    	} else
			    if ((kc_selvar_0_1->prod_sel() == sel_Nilpath)) {

			} else
			    kc_no_default_in_with( "", __LINE__, __FILE__ );
		    }

		    kc::unparse(p, kc_printer, kc_current_view);
		    { kc_printer(kc_t(";\
\n"), kc_current_view); }
		}
	    }
	    break;
	}
    }
}

void
impl_path::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    if(is_nil())
	nil_do_unparse(kc_printer, kc_current_view_base);
    else
	switch(kc_current_view_base) {
	case view_gen_cast_enum: {
	    view_gen_cast_class& kc_current_view=static_cast<view_gen_cast_class&>(kc_current_view_base);
	    {
		const integer i = this->integer_1;
		const path r_p = this->path_1;
		bool isnotlist = f_listelementphylum(f_phylumofoperator(this->op))->eq(f_emptyId());
		if(isnotlist)

		{
		    { kc_printer(kc_t("phylum_cast<const "), kc_current_view); }
		    kc::unparse(this->op, kc_printer, view_class_of_op);
		    { kc_printer(kc_t("*>"), kc_current_view); }
		}
		{ kc_printer(kc_t("("), kc_current_view); }
		kc::unparse(r_p, kc_printer, kc_current_view);
	    }
	    break;
	}
	case view_rw_bindings_enum: {
	    view_rw_bindings_class& kc_current_view=static_cast<view_rw_bindings_class&>(kc_current_view_base);
	    if ((this->path_1->prod_sel() == sel_Nilpath)) {
		const integer i = this->integer_1;
		const path r_p = this->path_1;
		argument gl_argument = f_argumentofoperator( r_p->op, Int( i )); 
		 if (!g_options.rw_loop) 
		{
		    { kc_printer(kc_t("l_"), kc_current_view); }
		}
		kc::unparse(gl_argument, kc_printer, kc_current_view);
		gl_argument->free(false); 
			} else
		    goto kc_unparsing_default;
	    break;
	}
	case view_unp_bindings_enum: {
	    view_unp_bindings_class& kc_current_view=static_cast<view_unp_bindings_class&>(kc_current_view_base);
	    if ((this->path_1->prod_sel() == sel_Nilpath)) {
		const integer i = this->integer_1;
		const path r_p = this->path_1;
		argument gl_argument = f_argumentofoperator( r_p->op, Int( i )); 
			{ kc_printer(kc_t("this->"), kc_current_view); }
		kc::unparse(gl_argument, kc_printer, kc_current_view);
		gl_argument->free(false); 
			} else
		    goto kc_unparsing_default;
	    break;
	}
	case view_wc_bindings_enum: {
	    view_wc_bindings_class& kc_current_view=static_cast<view_wc_bindings_class&>(kc_current_view_base);
	    if ((this->path_1->prod_sel() == sel_Nilpath)) {
		const integer i = this->integer_1;
		ID selvar = cf_topselvar(); 
		kc::unparse(selvar, kc_printer, kc_current_view);
		{ kc_printer(kc_t("_"), kc_current_view); }
		kc::unparse(i, kc_printer, kc_current_view);
	    } else
		    goto kc_unparsing_default;
	    break;
	}
	case view_unp_predicates_enum: {
	    view_unp_predicates_class& kc_current_view=static_cast<view_unp_predicates_class&>(kc_current_view_base);
	    if ((this->path_1->prod_sel() == sel_Nilpath)) {
		const integer i = this->integer_1;
		const path r_p = this->path_1;
		argument gl_argument = f_argumentofoperator( r_p->op, Int( i )); 
			{ kc_printer(kc_t("this->"), kc_current_view); }
		kc::unparse(gl_argument, kc_printer, kc_current_view);
		gl_argument->free(false); 
			} else
		    goto kc_unparsing_default;
	    break;
	}
	case view_wc_predicates_enum: {
	    view_wc_predicates_class& kc_current_view=static_cast<view_wc_predicates_class&>(kc_current_view_base);
	    if ((this->path_1->prod_sel() == sel_Nilpath)) {
		const integer i = this->integer_1;
		ID selvar = cf_topselvar(); 
		kc::unparse(selvar, kc_printer, kc_current_view);
		{ kc_printer(kc_t("_"), kc_current_view); }
		kc::unparse(i, kc_printer, kc_current_view);
	    } else
		    goto kc_unparsing_default;
	    break;
	}
	case view_rw_predicates_enum: {
	    view_rw_predicates_class& kc_current_view=static_cast<view_rw_predicates_class&>(kc_current_view_base);
	    if ((this->path_1->prod_sel() == sel_Nilpath)) {
		const integer i = this->integer_1;
		const path r_p = this->path_1;
		argument gl_argument = f_argumentofoperator( r_p->op, Int( i )); 
		 if (!g_options.rw_loop) 
		{
		    { kc_printer(kc_t("l_"), kc_current_view); }
		}
		kc::unparse(gl_argument, kc_printer, kc_current_view);
		gl_argument->free(false); 
			} else
		    goto kc_unparsing_default;
	    break;
	}

	default:
	kc_unparsing_default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		const integer i = this->integer_1;
		const path r_p = this->path_1;
		kc::unparse(r_p, kc_printer, kc_current_view);
		{ kc_printer(kc_t(")->"), kc_current_view); }
		argument gl_argument = f_argumentofoperator( r_p->op, Int( i )); 
		kc::unparse(gl_argument, kc_printer, kc_current_view);
		gl_argument->free(false); 
	    }
	    break;
	}
    }
}

void
impl_path::nil_do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case view_rw_bindings_enum: {
	    view_rw_bindings_class& kc_current_view=static_cast<view_rw_bindings_class&>(kc_current_view_base);
	    {
		if (gl_args->is_nil() || g_options.rw_loop) 
		{
		    { kc_printer(kc_t("this"), kc_current_view); }
		}
		else 
		{
		    { kc_printer(kc_t("((("), kc_current_view); }
		    kc::unparse(gl_args, kc_printer, view_gen_rewritedefs_dotestarg_c);
		    { kc_printer(kc_t(")) ? this : "), kc_current_view); }
		    kc::unparse(gl_operator, kc_printer, kc_current_view);
		    { kc_printer(kc_t("("), kc_current_view); }
		    kc::unparse(gl_args, kc_printer, view_gen_rewritedefs_args_c);
		    { kc_printer(kc_t("))"), kc_current_view); }
		}
	    }
	    break;
	}
	case view_unp_bindings_enum: {
	    view_unp_bindings_class& kc_current_view=static_cast<view_unp_bindings_class&>(kc_current_view_base);
	    {
		{ kc_printer(kc_t("this/**/"), kc_current_view); }
	    }
	    break;
	}
	case view_unp_predicates_enum: {
	    view_unp_predicates_class& kc_current_view=static_cast<view_unp_predicates_class&>(kc_current_view_base);
	    {
		{ kc_printer(kc_t("this/**/"), kc_current_view); }
	    }
	    break;
	}
	case view_rw_predicates_enum: {
	    view_rw_predicates_class& kc_current_view=static_cast<view_rw_predicates_class&>(kc_current_view_base);
	    {
		if (gl_args->is_nil() || g_options.rw_loop) 
		{
		    { kc_printer(kc_t("this"), kc_current_view); }
		}
		else 
		{
		    { kc_printer(kc_t("((("), kc_current_view); }
		    kc::unparse(gl_args, kc_printer, view_gen_rewritedefs_dotestarg_c);
		    { kc_printer(kc_t(")) ? this : "), kc_current_view); }
		    kc::unparse(gl_operator, kc_printer, kc_current_view);
		    { kc_printer(kc_t("("), kc_current_view); }
		    kc::unparse(gl_args, kc_printer, view_gen_rewritedefs_args_c);
		    { kc_printer(kc_t("))"), kc_current_view); }
		}
	    }
	    break;
	}

	default:
	kc_unparsing_default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
	    }
	    break;
	}
    }
}

void
impl_paths::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    if(is_nil())
	nil_do_unparse(kc_printer, kc_current_view_base);
    else
	switch(kc_current_view_base) {

	default:
	kc_unparsing_default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    if ((this->path_1->prod_sel() == sel_Conspath) && (this->paths_1->prod_sel() == sel_Conspaths) && ((this->paths_1)->path_1->prod_sel() == sel_Conspath) && ((this->paths_1)->paths_1->prod_sel() == sel_Nilpaths)) {
		const path p1 = this->path_1;
		const path r_p1 = (this->path_1)->path_1;
		const path p2 = (this->paths_1)->path_1;
		const path r_p2 = ((this->paths_1)->path_1)->path_1;
		kc::unparse(r_p1, kc_printer, view_gen_cast);
		kc::unparse(p1, kc_printer, kc_current_view);
		{ kc_printer(kc_t("->eq("), kc_current_view); }
		kc::unparse(r_p2, kc_printer, view_gen_cast);
		kc::unparse(p2, kc_printer, kc_current_view);
		{ kc_printer(kc_t(")"), kc_current_view); }
	    } else
		if ((this->path_1->prod_sel() == sel_Conspath) && (this->paths_1->prod_sel() == sel_Conspaths) && ((this->paths_1)->path_1->prod_sel() == sel_Conspath)) {
		const path p1 = this->path_1;
		const path r_p1 = (this->path_1)->path_1;
		const paths pp1 = this->paths_1;
		const path p2 = (this->paths_1)->path_1;
		const path r_p2 = ((this->paths_1)->path_1)->path_1;
		kc::unparse(r_p1, kc_printer, view_gen_cast);
		kc::unparse(p1, kc_printer, kc_current_view);
		{ kc_printer(kc_t("->eq("), kc_current_view); }
		kc::unparse(r_p2, kc_printer, view_gen_cast);
		kc::unparse(p2, kc_printer, kc_current_view);
		{ kc_printer(kc_t(")) && ("), kc_current_view); }
		kc::unparse(pp1, kc_printer, kc_current_view);
	    } else
		if ((this->paths_1->prod_sel() == sel_Nilpaths)) {
	    } else
	    { /* Alternative( *, args ) -> [view_gen_unparsedefs_default_c: */
		path_1->unparse(kc_printer, kc_current_view );
		paths_1->do_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}

void
impl_paths::nil_do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

	default:
	kc_unparsing_default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
	    }
	    break;
	}
    }
}

void
impl_argsnumbers::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    if(is_nil())
	nil_do_unparse(kc_printer, kc_current_view_base);
    else
	switch(kc_current_view_base) {
	case view_gen_rewritek_c_enum: {
	    view_gen_rewritek_c_class& kc_current_view=static_cast<view_gen_rewritek_c_class&>(kc_current_view_base);
	    {
		const integer i = this->integer_1;
		const argsnumbers r = this->argsnumbers_1;
		{ kc_printer(kc_t("   case "), kc_current_view); }
		kc::unparse(i, kc_printer, kc_current_view);
		{ kc_printer(kc_t(": return kc_create(kc_op"), kc_current_view); }
		for (int j=0; j<i->value; ++j) 
		{
		    { kc_printer(kc_t(", sons[son_offset"), kc_current_view); }
		    if (j!=0) 
		    {
			{ kc_printer(kc_t("+"), kc_current_view); }
			kc::unparse(j, kc_printer, kc_current_view);
		    }
		    { kc_printer(kc_t("]"), kc_current_view); }
		}
		{ kc_printer(kc_t(");\
\n"), kc_current_view); }
		kc::unparse(r, kc_printer, kc_current_view);
	    }
	    break;
	}
	case view_gen_copydefs_c_enum: {
	    view_gen_copydefs_c_class& kc_current_view=static_cast<view_gen_copydefs_c_class&>(kc_current_view_base);
	    {
		const integer i = this->integer_1;
		const argsnumbers r = this->argsnumbers_1;
		{ kc_printer(kc_t("   case "), kc_current_view); }
		kc::unparse(i, kc_printer, kc_current_view);
		{ kc_printer(kc_t(": kc_answer = kc_create(prod_sel()"), kc_current_view); }
		for (int j=0; j<i->value; ++j) 
		{
		    { kc_printer(kc_t(", kc_subtmp["), kc_current_view); }
		    kc::unparse(j, kc_printer, kc_current_view);
		    { kc_printer(kc_t("]"), kc_current_view); }
		}
		{ kc_printer(kc_t("); break;\
\n"), kc_current_view); }
		kc::unparse(r, kc_printer, kc_current_view);
	    }
	    break;
	}
	case view_gen_csgio_c_enum: {
	    view_gen_csgio_c_class& kc_current_view=static_cast<view_gen_csgio_c_class&>(kc_current_view_base);
	    {
		const integer i = this->integer_1;
		const argsnumbers r = this->argsnumbers_1;
		{ kc_printer(kc_t("   case "), kc_current_view); }
		kc::unparse(i, kc_printer, kc_current_view);
		{ kc_printer(kc_t(": kc_answer = kc_create(kc_op"), kc_current_view); }
		for (int j=0; j<i->value; ++j) 
		{
		    { kc_printer(kc_t(", kc_subtmp["), kc_current_view); }
		    kc::unparse(j, kc_printer, kc_current_view);
		    { kc_printer(kc_t("]"), kc_current_view); }
		}
		{ kc_printer(kc_t("); break;\
\n"), kc_current_view); }
		kc::unparse(r, kc_printer, kc_current_view);
	    }
	    break;
	}

	default:
	kc_unparsing_default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    { /* Alternative( *, args ) -> [view_gen_unparsedefs_default_c: */
		for (argsnumbers iterator_ = this; iterator_->argsnumbers_1 != 0; iterator_ = iterator_->argsnumbers_1)
		    iterator_->integer_1->unparse(kc_printer, kc_current_view);
	    }
	    break;
	}
    }
}

void
impl_argsnumbers::nil_do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case view_gen_rewritek_c_enum: {
	    view_gen_rewritek_c_class& kc_current_view=static_cast<view_gen_rewritek_c_class&>(kc_current_view_base);
	    {
	    }
	    break;
	}
	case view_gen_copydefs_c_enum: {
	    view_gen_copydefs_c_class& kc_current_view=static_cast<view_gen_copydefs_c_class&>(kc_current_view_base);
	    {
	    }
	    break;
	}
	case view_gen_csgio_c_enum: {
	    view_gen_csgio_c_class& kc_current_view=static_cast<view_gen_csgio_c_class&>(kc_current_view_base);
	    {
	    }
	    break;
	}

	default:
	kc_unparsing_default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    { /* Alternative( *, args ) -> [view_gen_unparsedefs_default_c: */
	    }
	    break;
	}
    }
}

void
impl_rewriterulesinfo::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    if(is_nil())
	nil_do_unparse(kc_printer, kc_current_view_base);
    else
	switch(kc_current_view_base) {
	case view_gen_rewritedefs_other_c_enum: {
	    view_gen_rewritedefs_other_c_class& kc_current_view=static_cast<view_gen_rewritedefs_other_c_class&>(kc_current_view_base);
	    if ((this->rewriteruleinfo_1->prod_sel() == sel_Rewriteruleinfo) && (phylum_cast<const impl_rewriteruleinfo_Rewriteruleinfo*>(this->rewriteruleinfo_1)->patternrepresentation_1->prod_sel() == sel_Conspatternrepresentation) && ((phylum_cast<const impl_rewriteruleinfo_Rewriteruleinfo*>(this->rewriteruleinfo_1)->patternrepresentation_1)->patternrepresentation_1->prod_sel() == sel_Nilpatternrepresentation) && (phylum_cast<const impl_rewriteruleinfo_Rewriteruleinfo*>(this->rewriteruleinfo_1)->rewriteclause_1->prod_sel() == sel_RewriteClause)) {
		const elem_patternrepresentation rep = (phylum_cast<const impl_rewriteruleinfo_Rewriteruleinfo*>(this->rewriteruleinfo_1)->patternrepresentation_1)->elem_patternrepresentation_1;
		const patternrepresentation bindings = phylum_cast<const impl_rewriteruleinfo_Rewriteruleinfo*>(this->rewriteruleinfo_1)->patternrepresentation_2;
		const term t = phylum_cast<const impl_rewriteclause_RewriteClause*>(phylum_cast<const impl_rewriteruleinfo_Rewriteruleinfo*>(this->rewriteruleinfo_1)->rewriteclause_1)->term_1;
		const rewriterulesinfo r_rri = this->rewriterulesinfo_1;
		if(g_options.linedirec) 
		{
		    kc::unparse(pg_line, kc_printer, kc_current_view);
		    kc::unparse(rep->line, kc_printer, kc_current_view);
		    { kc_printer(kc_t(" \""), kc_current_view); }
		    PRINT(g_options.dir_line.c_str()); 
		    kc::unparse(rep->file, kc_printer, view_filename);
		    { kc_printer(kc_t("\"\n"), kc_current_view); }
		}
		{ kc_printer(kc_t("	{ KC_TRACE_REWRITE_MATCH(kc_current_view, \""), kc_current_view); }
		kc::unparse(rep->file, kc_printer, kc_current_view);
		{ kc_printer(kc_t("\", "), kc_current_view); }
		kc::unparse(rep->line, kc_printer, kc_current_view);
		{ kc_printer(kc_t(", this);\
\n"), kc_current_view); }
		kc::unparse(bindings, kc_printer, view_rw_bindings);
		if(g_options.linedirec) 
		{
		    kc::unparse(pg_line, kc_printer, kc_current_view);
		    kc::unparse(t->line, kc_printer, kc_current_view);
		    { kc_printer(kc_t(" \""), kc_current_view); }
		    PRINT(g_options.dir_line.c_str()); 
		    kc::unparse(t->file, kc_printer, view_filename);
		    { kc_printer(kc_t("\"\n"), kc_current_view); }
		}
		if(g_options.rw_loop) 
		{
		    { kc_printer(kc_t("	"), kc_current_view); }
		    kc::unparse(gl_phylum, kc_printer, kc_current_view);
		    { kc_printer(kc_t(" kc_result = "), kc_current_view); }
		    kc::unparse(t, kc_printer, kc_current_view);
		    { kc_printer(kc_t(";\
\n"), kc_current_view); }
		    kc::unparse(g_emptystring, kc_printer, view_printer_outputfileline);
		    { kc_printer(kc_t("	KC_TRACE_REWRITE_RESULT(kc_current_view,\""), kc_current_view); }
		    kc::unparse(t->file, kc_printer, kc_current_view);
		    { kc_printer(kc_t("\","), kc_current_view); }
		    kc::unparse(t->line, kc_printer, kc_current_view);
		    { kc_printer(kc_t(",kc_result);\
\n	return kc_result;\
\n"), kc_current_view); }
		}
		else 
		{
		    if(g_options.smart_pointer) 
		    {
			{ kc_printer(kc_t("	"), kc_current_view); }
			kc::unparse(gl_phylum, kc_printer, kc_current_view);
			{ kc_printer(kc_t("_ptr kc_result = "), kc_current_view); }
			kc::unparse(t, kc_printer, kc_current_view);
			{ kc_printer(kc_t(";\
\n"), kc_current_view); }
			kc::unparse(g_emptystring, kc_printer, view_printer_outputfileline);
			{ kc_printer(kc_t("	KC_TRACE_REWRITE_RESULT(kc_current_view,\""), kc_current_view); }
			kc::unparse(t->file, kc_printer, kc_current_view);
			{ kc_printer(kc_t("\","), kc_current_view); }
			kc::unparse(t->line, kc_printer, kc_current_view);
			{ kc_printer(kc_t(",kc_result);\
\n	return (kc_result() == this ? this : kc_result->rewrite( kc_current_view_base ))->return_ptr();\
\n"), kc_current_view); }
		    }
		    else 
		    {
			{ kc_printer(kc_t("	"), kc_current_view); }
			kc::unparse(gl_phylum, kc_printer, kc_current_view);
			{ kc_printer(kc_t(" kc_result = "), kc_current_view); }
			kc::unparse(t, kc_printer, kc_current_view);
			{ kc_printer(kc_t(";\
\n"), kc_current_view); }
			kc::unparse(g_emptystring, kc_printer, view_printer_outputfileline);
			{ kc_printer(kc_t("	KC_TRACE_REWRITE_RESULT(kc_current_view,\""), kc_current_view); }
			kc::unparse(t->file, kc_printer, kc_current_view);
			{ kc_printer(kc_t("\","), kc_current_view); }
			kc::unparse(t->line, kc_printer, kc_current_view);
			{ kc_printer(kc_t(",kc_result);\
\n	return (const_cast<const impl_"), kc_current_view); }
			kc::unparse(gl_phylum, kc_printer, kc_current_view);
			{ kc_printer(kc_t("*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );\
\n"), kc_current_view); }
		    }
		}
		{ kc_printer(kc_t("\
\n	}\
\n"), kc_current_view); }
		if (g_options.warn_drop_identical_patterns) {
		    rewriterulesinfo kc_selvar_0_1 = phylum_cast<rewriterulesinfo>(r_rri);
		    if ((kc_selvar_0_1->prod_sel() == sel_Consrewriterulesinfo)) {

			{
			    rewriterulesinfo kc_fe_selvar_1 =  kc_selvar_0_1;

			    while(
				    kc_fe_selvar_1->prod_sel() == sel_Consrewriterulesinfo
				) {
				rewriteruleinfo kc_selvar_1_1 = kc_fe_selvar_1->rewriteruleinfo_1;
				{
				    {
					{
					    const rewriteruleinfo rri = kc_selvar_1_1;

					    warn_drop_identical_pattern(rri);

					}
				    }

				}
				kc_fe_selvar_1 = kc_fe_selvar_1->rewriterulesinfo_1;

			    }
			}

		    } else
			if ((kc_selvar_0_1->prod_sel() == sel_Nilrewriterulesinfo)) {

		    } else
			kc_no_default_in_with( "", __LINE__, __FILE__ );
		}

	    } else
		if ((this->rewriteruleinfo_1->prod_sel() == sel_Rewriteruleinfo) && (phylum_cast<const impl_rewriteruleinfo_Rewriteruleinfo*>(this->rewriteruleinfo_1)->patternrepresentation_1->prod_sel() == sel_Nilpatternrepresentation) && (phylum_cast<const impl_rewriteruleinfo_Rewriteruleinfo*>(this->rewriteruleinfo_1)->rewriteclause_1->prod_sel() == sel_RewriteClause)) {
		const patternrepresentation bindings = phylum_cast<const impl_rewriteruleinfo_Rewriteruleinfo*>(this->rewriteruleinfo_1)->patternrepresentation_2;
		const term t = phylum_cast<const impl_rewriteclause_RewriteClause*>(phylum_cast<const impl_rewriteruleinfo_Rewriteruleinfo*>(this->rewriteruleinfo_1)->rewriteclause_1)->term_1;
		assertionFailed("Completely empty rewrite pattern not possible."); 
			} else
		if ((this->rewriteruleinfo_1->prod_sel() == sel_Rewriteruleinfo) && (phylum_cast<const impl_rewriteruleinfo_Rewriteruleinfo*>(this->rewriteruleinfo_1)->patternrepresentation_1->prod_sel() == sel_Conspatternrepresentation) && (phylum_cast<const impl_rewriteruleinfo_Rewriteruleinfo*>(this->rewriteruleinfo_1)->rewriteclause_1->prod_sel() == sel_RewriteClause)) {
		const elem_patternrepresentation rep = (phylum_cast<const impl_rewriteruleinfo_Rewriteruleinfo*>(this->rewriteruleinfo_1)->patternrepresentation_1)->elem_patternrepresentation_1;
		const patternrepresentation r_p = (phylum_cast<const impl_rewriteruleinfo_Rewriteruleinfo*>(this->rewriteruleinfo_1)->patternrepresentation_1)->patternrepresentation_1;
		const patternrepresentation bindings = phylum_cast<const impl_rewriteruleinfo_Rewriteruleinfo*>(this->rewriteruleinfo_1)->patternrepresentation_2;
		const term t = phylum_cast<const impl_rewriteclause_RewriteClause*>(phylum_cast<const impl_rewriteruleinfo_Rewriteruleinfo*>(this->rewriteruleinfo_1)->rewriteclause_1)->term_1;
		const rewriterulesinfo r_rri = this->rewriterulesinfo_1;
		gl_bindings.clear(); 
		kc::unparse(bindings, kc_printer, view_predicate_bindings);
		if(g_options.linedirec) 
		{
		    kc::unparse(pg_line, kc_printer, kc_current_view);
		    kc::unparse(rep->line, kc_printer, kc_current_view);
		    { kc_printer(kc_t(" \""), kc_current_view); }
		    PRINT(g_options.dir_line.c_str()); 
		    kc::unparse(rep->file, kc_printer, view_filename);
		    { kc_printer(kc_t("\"\n"), kc_current_view); }
		}
		{ kc_printer(kc_t("	if (("), kc_current_view); }
		kc::unparse(r_p, kc_printer, view_rw_predicates);
		{ kc_printer(kc_t(")) { KC_TRACE_REWRITE_MATCH(kc_current_view, \""), kc_current_view); }
		kc::unparse(rep->file, kc_printer, kc_current_view);
		{ kc_printer(kc_t("\", "), kc_current_view); }
		kc::unparse(rep->line, kc_printer, kc_current_view);
		{ kc_printer(kc_t(", this);\
\n"), kc_current_view); }
		kc::unparse(bindings, kc_printer, view_rw_bindings);
		if(g_options.linedirec) 
		{
		    kc::unparse(pg_line, kc_printer, kc_current_view);
		    kc::unparse(t->line, kc_printer, kc_current_view);
		    { kc_printer(kc_t(" \""), kc_current_view); }
		    PRINT(g_options.dir_line.c_str()); 
		    kc::unparse(t->file, kc_printer, view_filename);
		    { kc_printer(kc_t("\"\n"), kc_current_view); }
		}
		if(g_options.rw_loop) 
		{
		    { kc_printer(kc_t("	"), kc_current_view); }
		    kc::unparse(gl_phylum, kc_printer, kc_current_view);
		    { kc_printer(kc_t(" kc_result = "), kc_current_view); }
		    kc::unparse(t, kc_printer, kc_current_view);
		    { kc_printer(kc_t(";\
\n"), kc_current_view); }
		    kc::unparse(g_emptystring, kc_printer, view_printer_outputfileline);
		    { kc_printer(kc_t("	KC_TRACE_REWRITE_RESULT(kc_current_view,\""), kc_current_view); }
		    kc::unparse(t->file, kc_printer, kc_current_view);
		    { kc_printer(kc_t("\","), kc_current_view); }
		    kc::unparse(t->line, kc_printer, kc_current_view);
		    { kc_printer(kc_t(",kc_result);\
\n	return kc_result;\
\n"), kc_current_view); }
		}
		else 
		{
		    if(g_options.smart_pointer) 
		    {
			{ kc_printer(kc_t("	"), kc_current_view); }
			kc::unparse(gl_phylum, kc_printer, kc_current_view);
			{ kc_printer(kc_t("_ptr kc_result = "), kc_current_view); }
			kc::unparse(t, kc_printer, kc_current_view);
			{ kc_printer(kc_t(";\
\n"), kc_current_view); }
			kc::unparse(g_emptystring, kc_printer, view_printer_outputfileline);
			{ kc_printer(kc_t("	KC_TRACE_REWRITE_RESULT(kc_current_view,\""), kc_current_view); }
			kc::unparse(t->file, kc_printer, kc_current_view);
			{ kc_printer(kc_t("\","), kc_current_view); }
			kc::unparse(t->line, kc_printer, kc_current_view);
			{ kc_printer(kc_t(",kc_result);\
\n	return (kc_result() == this ? this : kc_result->rewrite( kc_current_view_base ))->return_ptr();\
\n"), kc_current_view); }
		    }
		    else 
		    {
			{ kc_printer(kc_t("	"), kc_current_view); }
			kc::unparse(gl_phylum, kc_printer, kc_current_view);
			{ kc_printer(kc_t(" kc_result = "), kc_current_view); }
			kc::unparse(t, kc_printer, kc_current_view);
			{ kc_printer(kc_t(";\
\n"), kc_current_view); }
			kc::unparse(g_emptystring, kc_printer, view_printer_outputfileline);
			{ kc_printer(kc_t("	KC_TRACE_REWRITE_RESULT(kc_current_view,\""), kc_current_view); }
			kc::unparse(t->file, kc_printer, kc_current_view);
			{ kc_printer(kc_t("\","), kc_current_view); }
			kc::unparse(t->line, kc_printer, kc_current_view);
			{ kc_printer(kc_t(",kc_result);\
\n	return (const_cast<const impl_"), kc_current_view); }
			kc::unparse(gl_phylum, kc_printer, kc_current_view);
			{ kc_printer(kc_t("*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );\
\n"), kc_current_view); }
		    }
		}
		{ kc_printer(kc_t("\
\n	} else\
\n"), kc_current_view); }
		kc::unparse(r_rri, kc_printer, kc_current_view);
	    } else
		    goto kc_unparsing_default;
	    break;
	}
	case view_gen_rewritedefs_default_c_enum: {
	    view_gen_rewritedefs_default_c_class& kc_current_view=static_cast<view_gen_rewritedefs_default_c_class&>(kc_current_view_base);
	    if ((this->rewriteruleinfo_1->prod_sel() == sel_Rewriteruleinfo) && (phylum_cast<const impl_rewriteruleinfo_Rewriteruleinfo*>(this->rewriteruleinfo_1)->patternrepresentation_1->prod_sel() == sel_Conspatternrepresentation) && ((phylum_cast<const impl_rewriteruleinfo_Rewriteruleinfo*>(this->rewriteruleinfo_1)->patternrepresentation_1)->patternrepresentation_1->prod_sel() == sel_Nilpatternrepresentation) && (phylum_cast<const impl_rewriteruleinfo_Rewriteruleinfo*>(this->rewriteruleinfo_1)->rewriteclause_1->prod_sel() == sel_RewriteClause)) {
		const elem_patternrepresentation rep = (phylum_cast<const impl_rewriteruleinfo_Rewriteruleinfo*>(this->rewriteruleinfo_1)->patternrepresentation_1)->elem_patternrepresentation_1;
		const patternrepresentation bindings = phylum_cast<const impl_rewriteruleinfo_Rewriteruleinfo*>(this->rewriteruleinfo_1)->patternrepresentation_2;
		const term t = phylum_cast<const impl_rewriteclause_RewriteClause*>(phylum_cast<const impl_rewriteruleinfo_Rewriteruleinfo*>(this->rewriteruleinfo_1)->rewriteclause_1)->term_1;
		const rewriterulesinfo r_rri = this->rewriterulesinfo_1;
		if(g_options.linedirec) 
		{
		    kc::unparse(pg_line, kc_printer, kc_current_view);
		    kc::unparse(rep->line, kc_printer, kc_current_view);
		    { kc_printer(kc_t(" \""), kc_current_view); }
		    PRINT(g_options.dir_line.c_str()); 
		    kc::unparse(rep->file, kc_printer, view_filename);
		    { kc_printer(kc_t("\"\n"), kc_current_view); }
		}
		{ kc_printer(kc_t("	{ KC_TRACE_REWRITE_MATCH(kc_current_view, \""), kc_current_view); }
		kc::unparse(rep->file, kc_printer, kc_current_view);
		{ kc_printer(kc_t("\", "), kc_current_view); }
		kc::unparse(rep->line, kc_printer, kc_current_view);
		{ kc_printer(kc_t(", this);\
\n"), kc_current_view); }
		kc::unparse(bindings, kc_printer, view_rw_bindings);
		if(g_options.linedirec) 
		{
		    kc::unparse(pg_line, kc_printer, kc_current_view);
		    kc::unparse(t->line, kc_printer, kc_current_view);
		    { kc_printer(kc_t(" \""), kc_current_view); }
		    PRINT(g_options.dir_line.c_str()); 
		    kc::unparse(t->file, kc_printer, view_filename);
		    { kc_printer(kc_t("\"\n"), kc_current_view); }
		}
		if(g_options.rw_loop) 
		{
		    { kc_printer(kc_t("	"), kc_current_view); }
		    kc::unparse(gl_phylum, kc_printer, kc_current_view);
		    { kc_printer(kc_t(" kc_result = "), kc_current_view); }
		    kc::unparse(t, kc_printer, kc_current_view);
		    { kc_printer(kc_t(";\
\n"), kc_current_view); }
		    kc::unparse(g_emptystring, kc_printer, view_printer_outputfileline);
		    { kc_printer(kc_t("	KC_TRACE_REWRITE_RESULT(kc_current_view,\""), kc_current_view); }
		    kc::unparse(t->file, kc_printer, kc_current_view);
		    { kc_printer(kc_t("\","), kc_current_view); }
		    kc::unparse(t->line, kc_printer, kc_current_view);
		    { kc_printer(kc_t(",kc_result);\
\n	return kc_result;\
\n"), kc_current_view); }
		}
		else 
		{
		    if(g_options.smart_pointer) 
		    {
			{ kc_printer(kc_t("	"), kc_current_view); }
			kc::unparse(gl_phylum, kc_printer, kc_current_view);
			{ kc_printer(kc_t("_ptr kc_result = "), kc_current_view); }
			kc::unparse(t, kc_printer, kc_current_view);
			{ kc_printer(kc_t(";\
\n"), kc_current_view); }
			kc::unparse(g_emptystring, kc_printer, view_printer_outputfileline);
			{ kc_printer(kc_t("	KC_TRACE_REWRITE_RESULT(kc_current_view,\""), kc_current_view); }
			kc::unparse(t->file, kc_printer, kc_current_view);
			{ kc_printer(kc_t("\","), kc_current_view); }
			kc::unparse(t->line, kc_printer, kc_current_view);
			{ kc_printer(kc_t(",kc_result);\
\n	return (kc_result() == this ? this : kc_result->rewrite( kc_current_view_base ))->return_ptr();\
\n"), kc_current_view); }
		    }
		    else 
		    {
			{ kc_printer(kc_t("	"), kc_current_view); }
			kc::unparse(gl_phylum, kc_printer, kc_current_view);
			{ kc_printer(kc_t(" kc_result = "), kc_current_view); }
			kc::unparse(t, kc_printer, kc_current_view);
			{ kc_printer(kc_t(";\
\n"), kc_current_view); }
			kc::unparse(g_emptystring, kc_printer, view_printer_outputfileline);
			{ kc_printer(kc_t("	KC_TRACE_REWRITE_RESULT(kc_current_view,\""), kc_current_view); }
			kc::unparse(t->file, kc_printer, kc_current_view);
			{ kc_printer(kc_t("\","), kc_current_view); }
			kc::unparse(t->line, kc_printer, kc_current_view);
			{ kc_printer(kc_t(",kc_result);\
\n	return (const_cast<const impl_"), kc_current_view); }
			kc::unparse(gl_phylum, kc_printer, kc_current_view);
			{ kc_printer(kc_t("*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );\
\n"), kc_current_view); }
		    }
		}
		{ kc_printer(kc_t("\
\n	}\
\n"), kc_current_view); }
		if (g_options.warn_drop_identical_patterns) {
		    rewriterulesinfo kc_selvar_0_1 = phylum_cast<rewriterulesinfo>(r_rri);
		    if ((kc_selvar_0_1->prod_sel() == sel_Consrewriterulesinfo)) {

			{
			    rewriterulesinfo kc_fe_selvar_1 =  kc_selvar_0_1;

			    while(
				    kc_fe_selvar_1->prod_sel() == sel_Consrewriterulesinfo
				) {
				rewriteruleinfo kc_selvar_1_1 = kc_fe_selvar_1->rewriteruleinfo_1;
				{
				    {
					{
					    const rewriteruleinfo rri = kc_selvar_1_1;

					    warn_drop_identical_pattern(rri);

					}
				    }

				}
				kc_fe_selvar_1 = kc_fe_selvar_1->rewriterulesinfo_1;

			    }
			}

		    } else
			if ((kc_selvar_0_1->prod_sel() == sel_Nilrewriterulesinfo)) {

		    } else
			kc_no_default_in_with( "", __LINE__, __FILE__ );
		}

	    } else
		if ((this->rewriteruleinfo_1->prod_sel() == sel_Rewriteruleinfo) && (phylum_cast<const impl_rewriteruleinfo_Rewriteruleinfo*>(this->rewriteruleinfo_1)->patternrepresentation_1->prod_sel() == sel_Nilpatternrepresentation) && (phylum_cast<const impl_rewriteruleinfo_Rewriteruleinfo*>(this->rewriteruleinfo_1)->rewriteclause_1->prod_sel() == sel_RewriteClause)) {
		const patternrepresentation bindings = phylum_cast<const impl_rewriteruleinfo_Rewriteruleinfo*>(this->rewriteruleinfo_1)->patternrepresentation_2;
		const term t = phylum_cast<const impl_rewriteclause_RewriteClause*>(phylum_cast<const impl_rewriteruleinfo_Rewriteruleinfo*>(this->rewriteruleinfo_1)->rewriteclause_1)->term_1;
		assertionFailed("Completely empty rewrite pattern not possible."); 
			} else
		if ((this->rewriteruleinfo_1->prod_sel() == sel_Rewriteruleinfo) && (phylum_cast<const impl_rewriteruleinfo_Rewriteruleinfo*>(this->rewriteruleinfo_1)->patternrepresentation_1->prod_sel() == sel_Conspatternrepresentation) && (phylum_cast<const impl_rewriteruleinfo_Rewriteruleinfo*>(this->rewriteruleinfo_1)->rewriteclause_1->prod_sel() == sel_RewriteClause)) {
		const elem_patternrepresentation rep = (phylum_cast<const impl_rewriteruleinfo_Rewriteruleinfo*>(this->rewriteruleinfo_1)->patternrepresentation_1)->elem_patternrepresentation_1;
		const patternrepresentation r_p = (phylum_cast<const impl_rewriteruleinfo_Rewriteruleinfo*>(this->rewriteruleinfo_1)->patternrepresentation_1)->patternrepresentation_1;
		const patternrepresentation bindings = phylum_cast<const impl_rewriteruleinfo_Rewriteruleinfo*>(this->rewriteruleinfo_1)->patternrepresentation_2;
		const term t = phylum_cast<const impl_rewriteclause_RewriteClause*>(phylum_cast<const impl_rewriteruleinfo_Rewriteruleinfo*>(this->rewriteruleinfo_1)->rewriteclause_1)->term_1;
		const rewriterulesinfo r_rri = this->rewriterulesinfo_1;
		gl_bindings.clear(); 
		kc::unparse(bindings, kc_printer, view_predicate_bindings);
		if(g_options.linedirec) 
		{
		    kc::unparse(pg_line, kc_printer, kc_current_view);
		    kc::unparse(rep->line, kc_printer, kc_current_view);
		    { kc_printer(kc_t(" \""), kc_current_view); }
		    PRINT(g_options.dir_line.c_str()); 
		    kc::unparse(rep->file, kc_printer, view_filename);
		    { kc_printer(kc_t("\"\n"), kc_current_view); }
		}
		{ kc_printer(kc_t("	if (("), kc_current_view); }
		kc::unparse(r_p, kc_printer, view_rw_predicates);
		{ kc_printer(kc_t(")) { KC_TRACE_REWRITE_MATCH(kc_current_view, \""), kc_current_view); }
		kc::unparse(rep->file, kc_printer, kc_current_view);
		{ kc_printer(kc_t("\", "), kc_current_view); }
		kc::unparse(rep->line, kc_printer, kc_current_view);
		{ kc_printer(kc_t(", this);\
\n"), kc_current_view); }
		kc::unparse(bindings, kc_printer, view_rw_bindings);
		if(g_options.linedirec) 
		{
		    kc::unparse(pg_line, kc_printer, kc_current_view);
		    kc::unparse(t->line, kc_printer, kc_current_view);
		    { kc_printer(kc_t(" \""), kc_current_view); }
		    PRINT(g_options.dir_line.c_str()); 
		    kc::unparse(t->file, kc_printer, view_filename);
		    { kc_printer(kc_t("\"\n"), kc_current_view); }
		}
		if(g_options.rw_loop) 
		{
		    { kc_printer(kc_t("	"), kc_current_view); }
		    kc::unparse(gl_phylum, kc_printer, kc_current_view);
		    { kc_printer(kc_t(" kc_result = "), kc_current_view); }
		    kc::unparse(t, kc_printer, kc_current_view);
		    { kc_printer(kc_t(";\
\n"), kc_current_view); }
		    kc::unparse(g_emptystring, kc_printer, view_printer_outputfileline);
		    { kc_printer(kc_t("	KC_TRACE_REWRITE_RESULT(kc_current_view,\""), kc_current_view); }
		    kc::unparse(t->file, kc_printer, kc_current_view);
		    { kc_printer(kc_t("\","), kc_current_view); }
		    kc::unparse(t->line, kc_printer, kc_current_view);
		    { kc_printer(kc_t(",kc_result);\
\n	return kc_result;\
\n"), kc_current_view); }
		}
		else 
		{
		    if(g_options.smart_pointer) 
		    {
			{ kc_printer(kc_t("	"), kc_current_view); }
			kc::unparse(gl_phylum, kc_printer, kc_current_view);
			{ kc_printer(kc_t("_ptr kc_result = "), kc_current_view); }
			kc::unparse(t, kc_printer, kc_current_view);
			{ kc_printer(kc_t(";\
\n"), kc_current_view); }
			kc::unparse(g_emptystring, kc_printer, view_printer_outputfileline);
			{ kc_printer(kc_t("	KC_TRACE_REWRITE_RESULT(kc_current_view,\""), kc_current_view); }
			kc::unparse(t->file, kc_printer, kc_current_view);
			{ kc_printer(kc_t("\","), kc_current_view); }
			kc::unparse(t->line, kc_printer, kc_current_view);
			{ kc_printer(kc_t(",kc_result);\
\n	return (kc_result() == this ? this : kc_result->rewrite( kc_current_view_base ))->return_ptr();\
\n"), kc_current_view); }
		    }
		    else 
		    {
			{ kc_printer(kc_t("	"), kc_current_view); }
			kc::unparse(gl_phylum, kc_printer, kc_current_view);
			{ kc_printer(kc_t(" kc_result = "), kc_current_view); }
			kc::unparse(t, kc_printer, kc_current_view);
			{ kc_printer(kc_t(";\
\n"), kc_current_view); }
			kc::unparse(g_emptystring, kc_printer, view_printer_outputfileline);
			{ kc_printer(kc_t("	KC_TRACE_REWRITE_RESULT(kc_current_view,\""), kc_current_view); }
			kc::unparse(t->file, kc_printer, kc_current_view);
			{ kc_printer(kc_t("\","), kc_current_view); }
			kc::unparse(t->line, kc_printer, kc_current_view);
			{ kc_printer(kc_t(",kc_result);\
\n	return (const_cast<const impl_"), kc_current_view); }
			kc::unparse(gl_phylum, kc_printer, kc_current_view);
			{ kc_printer(kc_t("*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );\
\n"), kc_current_view); }
		    }
		}
		{ kc_printer(kc_t("\
\n	} else\
\n"), kc_current_view); }
		kc::unparse(r_rri, kc_printer, kc_current_view);
	    } else
		    goto kc_unparsing_default;
	    break;
	}

	default:
	kc_unparsing_default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    { /* Alternative( *, args ) -> [view_gen_unparsedefs_default_c: */
		for (rewriterulesinfo iterator_ = this; iterator_->rewriterulesinfo_1 != 0; iterator_ = iterator_->rewriterulesinfo_1)
		    iterator_->rewriteruleinfo_1->unparse(kc_printer, kc_current_view);
	    }
	    break;
	}
    }
}

void
impl_rewriterulesinfo::nil_do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case view_gen_rewritedefs_other_c_enum: {
	    view_gen_rewritedefs_other_c_class& kc_current_view=static_cast<view_gen_rewritedefs_other_c_class&>(kc_current_view_base);
	    {
		{ kc_printer(kc_t("\vgoto kc_rewrite_default\r;\
\n"), kc_current_view); }
		gl_rewrite_goto_used = true; 
	    }
	    break;
	}
	case view_gen_rewritedefs_default_c_enum: {
	    view_gen_rewritedefs_default_c_class& kc_current_view=static_cast<view_gen_rewritedefs_default_c_class&>(kc_current_view_base);
	    {
		{ kc_printer(kc_t("break;"), kc_current_view); }
	    }
	    break;
	}

	default:
	kc_unparsing_default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    { /* Alternative( *, args ) -> [view_gen_unparsedefs_default_c: */
	    }
	    break;
	}
    }
}


void
impl_rewriteruleinfo_Rewriteruleinfo::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    { /* Alternative( *, args ) -> [view_gen_unparsedefs_default_c: */
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}

void
impl_withcasesinfo::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    if(is_nil())
	nil_do_unparse(kc_printer, kc_current_view_base);
    else
	switch(kc_current_view_base) {

	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    if ((this->withcaseinfo_1->prod_sel() == sel_Withcaseinfo) && (phylum_cast<const impl_withcaseinfo_Withcaseinfo*>(this->withcaseinfo_1)->patternrepresentation_1->prod_sel() == sel_Conspatternrepresentation) && ((phylum_cast<const impl_withcaseinfo_Withcaseinfo*>(this->withcaseinfo_1)->patternrepresentation_1)->elem_patternrepresentation_1->prod_sel() == sel_PRUserPredicate) && (phylum_cast<const impl_elem_patternrepresentation_PRUserPredicate*>((phylum_cast<const impl_withcaseinfo_Withcaseinfo*>(this->withcaseinfo_1)->patternrepresentation_1)->elem_patternrepresentation_1)->Cexpression_1->prod_sel() == sel_NilCexpression)) {
		const patternrepresentation bindings = phylum_cast<const impl_withcaseinfo_Withcaseinfo*>(this->withcaseinfo_1)->patternrepresentation_2;
		const Ctext ct = phylum_cast<const impl_withcaseinfo_Withcaseinfo*>(this->withcaseinfo_1)->Ctext_1;
		{ kc_printer(kc_t("{\
\n"), kc_current_view); }
		if(g_options.linedirec) 
		{
		    kc::unparse(pg_line, kc_printer, kc_current_view);
		    kc::unparse(ct->line, kc_printer, kc_current_view);
		    { kc_printer(kc_t(" \""), kc_current_view); }
		    PRINT(g_options.dir_line.c_str()); 
		    kc::unparse(ct->file, kc_printer, view_filename);
		    { kc_printer(kc_t("\"\n"), kc_current_view); }
		}
		kc::unparse(bindings, kc_printer, view_wc_bindings);
		if(g_options.linedirec) 
		{
		    kc::unparse(pg_line, kc_printer, kc_current_view);
		    kc::unparse(ct->line, kc_printer, kc_current_view);
		    { kc_printer(kc_t(" \""), kc_current_view); }
		    PRINT(g_options.dir_line.c_str()); 
		    kc::unparse(ct->file, kc_printer, view_filename);
		    { kc_printer(kc_t("\"\n"), kc_current_view); }
		}
		kc::unparse(ct, kc_printer, view_gen_initializephyla_c);
		kc::unparse(g_emptystring, kc_printer, view_printer_outputfileline);
		{ kc_printer(kc_t("}\
\n"), kc_current_view); }
	    } else
		if ((this->withcaseinfo_1->prod_sel() == sel_Withcaseinfo) && (phylum_cast<const impl_withcaseinfo_Withcaseinfo*>(this->withcaseinfo_1)->patternrepresentation_1->prod_sel() == sel_Conspatternrepresentation) && ((phylum_cast<const impl_withcaseinfo_Withcaseinfo*>(this->withcaseinfo_1)->patternrepresentation_1)->elem_patternrepresentation_1->prod_sel() == sel_PRDefault)) {
		const patternrepresentation bindings = phylum_cast<const impl_withcaseinfo_Withcaseinfo*>(this->withcaseinfo_1)->patternrepresentation_2;
		const Ctext ct = phylum_cast<const impl_withcaseinfo_Withcaseinfo*>(this->withcaseinfo_1)->Ctext_1;
		{ kc_printer(kc_t("{\
\n"), kc_current_view); }
		if(g_options.linedirec) 
		{
		    kc::unparse(pg_line, kc_printer, kc_current_view);
		    kc::unparse(ct->line, kc_printer, kc_current_view);
		    { kc_printer(kc_t(" \""), kc_current_view); }
		    PRINT(g_options.dir_line.c_str()); 
		    kc::unparse(ct->file, kc_printer, view_filename);
		    { kc_printer(kc_t("\"\n"), kc_current_view); }
		}
		kc::unparse(bindings, kc_printer, view_wc_bindings);
		if(g_options.linedirec) 
		{
		    kc::unparse(pg_line, kc_printer, kc_current_view);
		    kc::unparse(ct->line, kc_printer, kc_current_view);
		    { kc_printer(kc_t(" \""), kc_current_view); }
		    PRINT(g_options.dir_line.c_str()); 
		    kc::unparse(ct->file, kc_printer, view_filename);
		    { kc_printer(kc_t("\"\n"), kc_current_view); }
		}
		kc::unparse(ct, kc_printer, view_gen_initializephyla_c);
		kc::unparse(g_emptystring, kc_printer, view_printer_outputfileline);
		{ kc_printer(kc_t("}\
\n"), kc_current_view); }
	    } else
		if ((this->withcaseinfo_1->prod_sel() == sel_Withcaseinfo) && (phylum_cast<const impl_withcaseinfo_Withcaseinfo*>(this->withcaseinfo_1)->patternrepresentation_1->prod_sel() == sel_Nilpatternrepresentation)) {
		const patternrepresentation bindings = phylum_cast<const impl_withcaseinfo_Withcaseinfo*>(this->withcaseinfo_1)->patternrepresentation_2;
		const Ctext ct = phylum_cast<const impl_withcaseinfo_Withcaseinfo*>(this->withcaseinfo_1)->Ctext_1;
		{ kc_printer(kc_t("{\
\n"), kc_current_view); }
		if(g_options.linedirec) 
		{
		    kc::unparse(pg_line, kc_printer, kc_current_view);
		    kc::unparse(ct->line, kc_printer, kc_current_view);
		    { kc_printer(kc_t(" \""), kc_current_view); }
		    PRINT(g_options.dir_line.c_str()); 
		    kc::unparse(ct->file, kc_printer, view_filename);
		    { kc_printer(kc_t("\"\n"), kc_current_view); }
		}
		kc::unparse(bindings, kc_printer, view_wc_bindings);
		if(g_options.linedirec) 
		{
		    kc::unparse(pg_line, kc_printer, kc_current_view);
		    kc::unparse(ct->line, kc_printer, kc_current_view);
		    { kc_printer(kc_t(" \""), kc_current_view); }
		    PRINT(g_options.dir_line.c_str()); 
		    kc::unparse(ct->file, kc_printer, view_filename);
		    { kc_printer(kc_t("\"\n"), kc_current_view); }
		}
		kc::unparse(ct, kc_printer, view_gen_initializephyla_c);
		kc::unparse(g_emptystring, kc_printer, view_printer_outputfileline);
		{ kc_printer(kc_t("}\
\n"), kc_current_view); }
	    } else
		if ((this->withcaseinfo_1->prod_sel() == sel_Withcaseinfo)) {
		const patternrepresentation p = phylum_cast<const impl_withcaseinfo_Withcaseinfo*>(this->withcaseinfo_1)->patternrepresentation_1;
		const patternrepresentation bindings = phylum_cast<const impl_withcaseinfo_Withcaseinfo*>(this->withcaseinfo_1)->patternrepresentation_2;
		const Ctext ct = phylum_cast<const impl_withcaseinfo_Withcaseinfo*>(this->withcaseinfo_1)->Ctext_1;
		const withcasesinfo r_rri = this->withcasesinfo_1;
		gl_bindings.clear(); 
		kc::unparse(bindings, kc_printer, view_predicate_bindings);
		if(g_options.linedirec) 
		{
		    kc::unparse(pg_line, kc_printer, kc_current_view);
		    kc::unparse(ct->line, kc_printer, kc_current_view);
		    { kc_printer(kc_t(" \""), kc_current_view); }
		    PRINT(g_options.dir_line.c_str()); 
		    kc::unparse(ct->file, kc_printer, view_filename);
		    { kc_printer(kc_t("\"\n"), kc_current_view); }
		}
		{ kc_printer(kc_t("	if (("), kc_current_view); }
		kc::unparse(p, kc_printer, view_wc_predicates);
		{ kc_printer(kc_t(")) {\
\n"), kc_current_view); }
		if(g_options.linedirec) 
		{
		    kc::unparse(pg_line, kc_printer, kc_current_view);
		    kc::unparse(ct->line, kc_printer, kc_current_view);
		    { kc_printer(kc_t(" \""), kc_current_view); }
		    PRINT(g_options.dir_line.c_str()); 
		    kc::unparse(ct->file, kc_printer, view_filename);
		    { kc_printer(kc_t("\"\n"), kc_current_view); }
		}
		kc::unparse(bindings, kc_printer, view_wc_bindings);
		operatorstack.push( f_operatorofpatternrepresentation( p ) ); 
		 if(g_options.linedirec) 
		{
		    kc::unparse(pg_line, kc_printer, kc_current_view);
		    kc::unparse(ct->line, kc_printer, kc_current_view);
		    { kc_printer(kc_t(" \""), kc_current_view); }
		    PRINT(g_options.dir_line.c_str()); 
		    kc::unparse(ct->file, kc_printer, view_filename);
		    { kc_printer(kc_t("\"\n"), kc_current_view); }
		}
		kc::unparse(ct, kc_printer, view_gen_initializephyla_c);
		operatorstack.pop(); 
		kc::unparse(g_emptystring, kc_printer, view_printer_outputfileline);
		{ kc_printer(kc_t("	} else\
\n"), kc_current_view); }
		kc::unparse(r_rri, kc_printer, kc_current_view);
	    } else
	    { /* Alternative( *, args ) -> [view_gen_unparsedefs_default_c: */
		withcaseinfo_1->unparse(kc_printer, kc_current_view );
		withcasesinfo_1->do_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}

void
impl_withcasesinfo::nil_do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case view_gen_withcases_and_default_enum: {
	    view_gen_withcases_and_default_class& kc_current_view=static_cast<view_gen_withcases_and_default_class&>(kc_current_view_base);
	    {
		if (inforeachcontext.top()) 
		{
		    { kc_printer(kc_t("{/* EMPTY */ /*skip: no matching pattern in foreach patterns*/}\
\n"), kc_current_view); }
		}
		else if ( (strcmp( gl_return_type, "" ) == 0) ||
		    ((gl_star_count == 0) &&
			(! f_isphylum( gl_return_ID )) &&
			(! f_is_known_ptr_type( gl_return_ID )) ) ) 
		{
		    { kc_printer(kc_t("kc_no_default_in_with( \""), kc_current_view); }
		    kc::unparse(gl_function, kc_printer, kc_current_view);
		    { kc_printer(kc_t("\", __LINE__, __FILE__ );\
\n"), kc_current_view); }
		}
		else 
		{
		    { kc_printer(kc_t("{ kc_no_default_in_with( \""), kc_current_view); }
		    kc::unparse(gl_function, kc_printer, kc_current_view);
		    { kc_printer(kc_t("\", __LINE__, __FILE__ );\
\n   return static_cast<"), kc_current_view); }
		    kc::unparse(gl_return_type, kc_printer, kc_current_view);
		    charruns star_string = Stars()->set(gl_star_count); 
		    kc::unparse(star_string, kc_printer, kc_current_view);
		    { kc_printer(kc_t(">(0); }\
\n"), kc_current_view); }
		}
	    }
	    break;
	}

	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    { /* Alternative( *, args ) -> [view_gen_unparsedefs_default_c: */
	    }
	    break;
	}
    }
}


void
impl_withcaseinfo_Withcaseinfo::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    { /* Alternative( *, args ) -> [view_gen_unparsedefs_default_c: */
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}

void
impl_rewriteviewsinfo::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    if(is_nil())
	nil_do_unparse(kc_printer, kc_current_view_base);
    else
	switch(kc_current_view_base) {
	case view_gen_rewritedefs_c_enum: {
	    view_gen_rewritedefs_c_class& kc_current_view=static_cast<view_gen_rewritedefs_c_class&>(kc_current_view_base);
	    {
		const rewriteviewinfo a_rvi = this->rewriteviewinfo_1;
		const rewriteviewsinfo r_rvi = this->rewriteviewsinfo_1;
		kc::unparse(r_rvi, kc_printer, kc_current_view);
		kc::unparse(a_rvi, kc_printer, kc_current_view);
	    }
	    break;
	}

	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    { /* Alternative( *, args ) -> [view_gen_unparsedefs_default_c: */
		for (rewriteviewsinfo iterator_ = this; iterator_->rewriteviewsinfo_1 != 0; iterator_ = iterator_->rewriteviewsinfo_1)
		    iterator_->rewriteviewinfo_1->unparse(kc_printer, kc_current_view);
	    }
	    break;
	}
    }
}

void
impl_rewriteviewsinfo::nil_do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case view_gen_rewritedefs_c_enum: {
	    view_gen_rewritedefs_c_class& kc_current_view=static_cast<view_gen_rewritedefs_c_class&>(kc_current_view_base);
	    {
	    }
	    break;
	}

	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    { /* Alternative( *, args ) -> [view_gen_unparsedefs_default_c: */
	    }
	    break;
	}
    }
}


void
impl_rewriteviewinfo_Rewriteviewinfo::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case view_gen_rewritedefs_other_c_enum: {
	    view_gen_rewritedefs_other_c_class& kc_current_view=static_cast<view_gen_rewritedefs_other_c_class&>(kc_current_view_base);
	    if ((this->rewriterulesinfo_1->prod_sel() == sel_Nilrewriterulesinfo)) {
	    } else
	    {
		const ID v = this->ID_1;
		{ kc_printer(kc_t("    case "), kc_current_view); }
		kc::unparse(v, kc_printer, kc_current_view);
		{ kc_printer(kc_t("_enum: {\
\n		"), kc_current_view); }
		kc::unparse(v, kc_printer, kc_current_view);
		{ kc_printer(kc_t("_class& kc_current_view=static_cast<"), kc_current_view); }
		kc::unparse(v, kc_printer, kc_current_view);
		{ kc_printer(kc_t("_class&>(kc_current_view_base);\
\n"), kc_current_view); }
		gl_view = v; 
		kc::unparse(gl_alternative, kc_printer, kc_current_view);
		gl_view = 0; 
			{ kc_printer(kc_t("    }\
\n"), kc_current_view); }
	    }
	    break;
	}
	case view_gen_rewritedefs_default_c_enum: {
	    view_gen_rewritedefs_default_c_class& kc_current_view=static_cast<view_gen_rewritedefs_default_c_class&>(kc_current_view_base);
	    if ((this->rewriterulesinfo_1->prod_sel() == sel_Nilrewriterulesinfo)) {
		if (gl_rewrite_goto_used) 
		{
		    { kc_printer(kc_t("    kc_rewrite_default:\
\n"), kc_current_view); }
		}
		{ kc_printer(kc_t("    default:;\
\n"), kc_current_view); }
	    } else
	    {
		const ID v = this->ID_1;
		{ kc_printer(kc_t("    default:\
\n"), kc_current_view); }
		if (gl_rewrite_goto_used) 
		{
		    { kc_printer(kc_t("    kc_rewrite_default:\
\n"), kc_current_view); }
		}
		{ kc_printer(kc_t("    case "), kc_current_view); }
		kc::unparse(v, kc_printer, kc_current_view);
		{ kc_printer(kc_t("_enum: {\
\n		"), kc_current_view); }
		kc::unparse(v, kc_printer, kc_current_view);
		{ kc_printer(kc_t("_class& kc_current_view=static_cast<"), kc_current_view); }
		kc::unparse(v, kc_printer, kc_current_view);
		{ kc_printer(kc_t("_class&>(kc_current_view_base);\
\n"), kc_current_view); }
		gl_view = v; 
		kc::unparse(gl_alternative, kc_printer, kc_current_view);
		gl_view = 0; 
			{ kc_printer(kc_t("    }\
\n"), kc_current_view); }
	    }
	    break;
	}
	case view_gen_rewritedefs_c_enum: {
	    view_gen_rewritedefs_c_class& kc_current_view=static_cast<view_gen_rewritedefs_c_class&>(kc_current_view_base);
	    if ((this->ID_1->prod_sel() == sel_Id) && (phylum_cast<const impl_ID_Id*>(this->ID_1)->uniqID_1->prod_sel() == sel_Str)) {
		const casestring v = phylum_cast<const impl_uniqID_Str*>(phylum_cast<const impl_ID_Id*>(this->ID_1)->uniqID_1)->casestring_1;
		const rewriterulesinfo rri = this->rewriterulesinfo_1;
		gl_rewrite_rewriteinfo = rri; 
		 if ( strcmp(v->name, "base_rview" )==0 ) 
		{
		    kc::unparse(this, kc_printer, view_gen_rewritedefs_default_c);
		}
		else 
		{
		    kc::unparse(this, kc_printer, view_gen_rewritedefs_other_c);
		}
		gl_rewrite_rewriteinfo = 0; 
			} else
		    goto kc_unparsing_default;
	    break;
	}

	default:
	kc_unparsing_default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    { /* Alternative( *, args ) -> [view_gen_unparsedefs_default_c: */
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}

void
impl_unparseviewsinfo::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    if(is_nil())
	nil_do_unparse(kc_printer, kc_current_view_base);
    else
	switch(kc_current_view_base) {
	case view_gen_unparsedefs_c_enum: {
	    view_gen_unparsedefs_c_class& kc_current_view=static_cast<view_gen_unparsedefs_c_class&>(kc_current_view_base);
	    {
		const unparseviewinfo a_uvi = this->unparseviewinfo_1;
		const unparseviewsinfo r_uvi = this->unparseviewsinfo_1;
		kc::unparse(r_uvi, kc_printer, kc_current_view);
		kc::unparse(a_uvi, kc_printer, kc_current_view);
	    }
	    break;
	}

	default:
	kc_unparsing_default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    { /* Alternative( *, args ) -> [view_gen_unparsedefs_default_c: */
		for (unparseviewsinfo iterator_ = this; iterator_->unparseviewsinfo_1 != 0; iterator_ = iterator_->unparseviewsinfo_1)
		    iterator_->unparseviewinfo_1->unparse(kc_printer, kc_current_view);
	    }
	    break;
	}
    }
}

void
impl_unparseviewsinfo::nil_do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case view_gen_unparsedefs_c_enum: {
	    view_gen_unparsedefs_c_class& kc_current_view=static_cast<view_gen_unparsedefs_c_class&>(kc_current_view_base);
	    {
	    }
	    break;
	}

	default:
	kc_unparsing_default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    { /* Alternative( *, args ) -> [view_gen_unparsedefs_default_c: */
	    }
	    break;
	}
    }
}


void
impl_unparseviewinfo_Unparseviewinfo::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case view_gen_unparsedefs_other_c_enum: {
	    view_gen_unparsedefs_other_c_class& kc_current_view=static_cast<view_gen_unparsedefs_other_c_class&>(kc_current_view_base);
	    if ((this->unparsedeclsinfo_1->prod_sel() == sel_Nilunparsedeclsinfo)) {
	    } else
	    {
		const ID v = this->ID_1;
		const unparsedeclsinfo udi = this->unparsedeclsinfo_1;
		{ kc_printer(kc_t("    case "), kc_current_view); }
		kc::unparse(v, kc_printer, kc_current_view);
		{ kc_printer(kc_t("_enum: {\
\n		"), kc_current_view); }
		kc::unparse(v, kc_printer, kc_current_view);
		{ kc_printer(kc_t("_class& kc_current_view=static_cast<"), kc_current_view); }
		kc::unparse(v, kc_printer, kc_current_view);
		{ kc_printer(kc_t("_class&>(kc_current_view_base);\
\n"), kc_current_view); }
		kc::unparse(udi, kc_printer, kc_current_view);
		{ kc_printer(kc_t("	break;\
\n    }\
\n"), kc_current_view); }
	    }
	    break;
	}
	case view_gen_unparsedefs_default_c_enum: {
	    view_gen_unparsedefs_default_c_class& kc_current_view=static_cast<view_gen_unparsedefs_default_c_class&>(kc_current_view_base);
	    {
		const ID v = this->ID_1;
		const unparsedeclsinfo udi = this->unparsedeclsinfo_1;
		kc::unparse(g_emptystring, kc_printer, view_printer_outputfileline);
		{ kc_printer(kc_t("    default:\
\n"), kc_current_view); }
		if (gl_unparse_goto_used) 
		{
		    { kc_printer(kc_t("    kc_unparsing_default:\
\n"), kc_current_view); }
		}
		{ kc_printer(kc_t("    case "), kc_current_view); }
		kc::unparse(v, kc_printer, kc_current_view);
		{ kc_printer(kc_t("_enum: {\
\n		uview kc_current_view=kc_current_view_base;\
\n"), kc_current_view); }
		bool onlyDefault;
		{
		    unparsedeclsinfo kc_selvar_0_1 = phylum_cast<unparsedeclsinfo>(udi);
		    if ((kc_selvar_0_1->prod_sel() == sel_Nilunparsedeclsinfo)) {
			onlyDefault = true; 
				} else
		    {
			onlyDefault = false; 
		    }
		}

		view_gen_unparsedefs_default_c_class vgudcD(/* is list ? */ false, onlyDefault);
		kc::unparse(udi, kc_printer, vgudcD);
		{ kc_printer(kc_t("	break;\
\n    }\
\n"), kc_current_view); }
	    }
	    break;
	}
	case view_gen_unparsedefs_c_enum: {
	    view_gen_unparsedefs_c_class& kc_current_view=static_cast<view_gen_unparsedefs_c_class&>(kc_current_view_base);
	    if ((this->ID_1->prod_sel() == sel_Id) && (phylum_cast<const impl_ID_Id*>(this->ID_1)->uniqID_1->prod_sel() == sel_Str)) {
		const casestring v = phylum_cast<const impl_uniqID_Str*>(phylum_cast<const impl_ID_Id*>(this->ID_1)->uniqID_1)->casestring_1;
		if ( strcmp(v->name, "base_uview" )==0 ) 
		{
		    kc::unparse(this, kc_printer, view_gen_unparsedefs_default_c);
		}
		else 
		{
		    kc::unparse(this, kc_printer, view_gen_unparsedefs_other_c);
		}
	    } else
		    goto kc_unparsing_default;
	    break;
	}

	default:
	kc_unparsing_default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    { /* Alternative( *, args ) -> [view_gen_unparsedefs_default_c: */
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}

void
impl_unparsedeclsinfo::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    if(is_nil())
	nil_do_unparse(kc_printer, kc_current_view_base);
    else
	switch(kc_current_view_base) {
	case view_gen_unparsedefs_other_c_enum: {
	    view_gen_unparsedefs_other_c_class& kc_current_view=static_cast<view_gen_unparsedefs_other_c_class&>(kc_current_view_base);
	    if ((this->unparsedeclinfo_1->prod_sel() == sel_Unparsedeclinfo) && (phylum_cast<const impl_unparsedeclinfo_Unparsedeclinfo*>(this->unparsedeclinfo_1)->patternrepresentation_1->prod_sel() == sel_Conspatternrepresentation) && ((phylum_cast<const impl_unparsedeclinfo_Unparsedeclinfo*>(this->unparsedeclinfo_1)->patternrepresentation_1)->patternrepresentation_1->prod_sel() == sel_Nilpatternrepresentation)) {
		const patternrepresentation p = phylum_cast<const impl_unparsedeclinfo_Unparsedeclinfo*>(this->unparsedeclinfo_1)->patternrepresentation_1;
		const patternrepresentation bindings = phylum_cast<const impl_unparsedeclinfo_Unparsedeclinfo*>(this->unparsedeclinfo_1)->patternrepresentation_2;
		const unparseclause uc = phylum_cast<const impl_unparsedeclinfo_Unparsedeclinfo*>(this->unparsedeclinfo_1)->unparseclause_1;
		const unparsedeclsinfo r_udi = this->unparsedeclsinfo_1;
		{ kc_printer(kc_t("{\n"), kc_current_view); }
		kc::unparse(bindings, kc_printer, view_unp_bindings);
		operatorstack.push( f_operatorofpatternrepresentation( p ) ); 
		kc::unparse(uc, kc_printer, kc_current_view);
		operatorstack.pop(); 
			{ kc_printer(kc_t("}\
\n"), kc_current_view); }
		if (g_options.warn_drop_identical_patterns) {
		    unparsedeclsinfo kc_selvar_0_1 = phylum_cast<unparsedeclsinfo>(r_udi);
		    if ((kc_selvar_0_1->prod_sel() == sel_Consunparsedeclsinfo)) {

			{
			    unparsedeclsinfo kc_fe_selvar_1 =  kc_selvar_0_1;

			    while(
				    kc_fe_selvar_1->prod_sel() == sel_Consunparsedeclsinfo
				) {
				unparsedeclinfo kc_selvar_1_1 = kc_fe_selvar_1->unparsedeclinfo_1;
				{
				    {
					{
					    const unparsedeclinfo udi = kc_selvar_1_1;

					    warn_drop_identical_pattern(udi);

					}
				    }

				}
				kc_fe_selvar_1 = kc_fe_selvar_1->unparsedeclsinfo_1;

			    }
			}

		    } else
			if ((kc_selvar_0_1->prod_sel() == sel_Nilunparsedeclsinfo)) {

		    } else
			kc_no_default_in_with( "", __LINE__, __FILE__ );
		}

	    } else
		if ((this->unparsedeclinfo_1->prod_sel() == sel_Unparsedeclinfo) && (phylum_cast<const impl_unparsedeclinfo_Unparsedeclinfo*>(this->unparsedeclinfo_1)->patternrepresentation_1->prod_sel() == sel_Conspatternrepresentation)) {
		const patternrepresentation p = phylum_cast<const impl_unparsedeclinfo_Unparsedeclinfo*>(this->unparsedeclinfo_1)->patternrepresentation_1;
		const patternrepresentation r_p = (phylum_cast<const impl_unparsedeclinfo_Unparsedeclinfo*>(this->unparsedeclinfo_1)->patternrepresentation_1)->patternrepresentation_1;
		const patternrepresentation bindings = phylum_cast<const impl_unparsedeclinfo_Unparsedeclinfo*>(this->unparsedeclinfo_1)->patternrepresentation_2;
		const unparseclause uc = phylum_cast<const impl_unparsedeclinfo_Unparsedeclinfo*>(this->unparsedeclinfo_1)->unparseclause_1;
		const unparsedeclsinfo r_udi = this->unparsedeclsinfo_1;
		gl_bindings.clear(); 
		kc::unparse(bindings, kc_printer, view_predicate_bindings);
		{ kc_printer(kc_t("	if (("), kc_current_view); }
		kc::unparse(r_p, kc_printer, view_unp_predicates);
		{ kc_printer(kc_t(")) {\
\n"), kc_current_view); }
		kc::unparse(bindings, kc_printer, view_unp_bindings);
		operatorstack.push( f_operatorofpatternrepresentation( p ) ); 
		kc::unparse(uc, kc_printer, kc_current_view);
		operatorstack.pop(); 
			{ kc_printer(kc_t("	} else\
\n"), kc_current_view); }
		kc::unparse(r_udi, kc_printer, kc_current_view);
	    } else
		    goto kc_unparsing_default;
	    break;
	}
	case view_gen_unparsedefs_default_c_enum: {
	    view_gen_unparsedefs_default_c_class& kc_current_view=static_cast<view_gen_unparsedefs_default_c_class&>(kc_current_view_base);
	    if ((this->unparsedeclinfo_1->prod_sel() == sel_Unparsedeclinfo) && (phylum_cast<const impl_unparsedeclinfo_Unparsedeclinfo*>(this->unparsedeclinfo_1)->patternrepresentation_1->prod_sel() == sel_Conspatternrepresentation) && ((phylum_cast<const impl_unparsedeclinfo_Unparsedeclinfo*>(this->unparsedeclinfo_1)->patternrepresentation_1)->patternrepresentation_1->prod_sel() == sel_Nilpatternrepresentation)) {
		const patternrepresentation p = phylum_cast<const impl_unparsedeclinfo_Unparsedeclinfo*>(this->unparsedeclinfo_1)->patternrepresentation_1;
		const patternrepresentation bindings = phylum_cast<const impl_unparsedeclinfo_Unparsedeclinfo*>(this->unparsedeclinfo_1)->patternrepresentation_2;
		const unparseclause uc = phylum_cast<const impl_unparsedeclinfo_Unparsedeclinfo*>(this->unparsedeclinfo_1)->unparseclause_1;
		const unparsedeclsinfo r_udi = this->unparsedeclsinfo_1;
		{ kc_printer(kc_t("{\n"), kc_current_view); }
		kc::unparse(bindings, kc_printer, view_unp_bindings);
		operatorstack.push( f_operatorofpatternrepresentation( p ) ); 
		kc::unparse(uc, kc_printer, kc_current_view);
		operatorstack.pop(); 
			{ kc_printer(kc_t("}\
\n"), kc_current_view); }
		if (g_options.warn_drop_identical_patterns) {
		    unparsedeclsinfo kc_selvar_0_1 = phylum_cast<unparsedeclsinfo>(r_udi);
		    if ((kc_selvar_0_1->prod_sel() == sel_Consunparsedeclsinfo)) {

			{
			    unparsedeclsinfo kc_fe_selvar_1 =  kc_selvar_0_1;

			    while(
				    kc_fe_selvar_1->prod_sel() == sel_Consunparsedeclsinfo
				) {
				unparsedeclinfo kc_selvar_1_1 = kc_fe_selvar_1->unparsedeclinfo_1;
				{
				    {
					{
					    const unparsedeclinfo udi = kc_selvar_1_1;

					    warn_drop_identical_pattern(udi);

					}
				    }

				}
				kc_fe_selvar_1 = kc_fe_selvar_1->unparsedeclsinfo_1;

			    }
			}

		    } else
			if ((kc_selvar_0_1->prod_sel() == sel_Nilunparsedeclsinfo)) {

		    } else
			kc_no_default_in_with( "", __LINE__, __FILE__ );
		}

	    } else
		if ((this->unparsedeclinfo_1->prod_sel() == sel_Unparsedeclinfo) && (phylum_cast<const impl_unparsedeclinfo_Unparsedeclinfo*>(this->unparsedeclinfo_1)->patternrepresentation_1->prod_sel() == sel_Conspatternrepresentation)) {
		const patternrepresentation p = phylum_cast<const impl_unparsedeclinfo_Unparsedeclinfo*>(this->unparsedeclinfo_1)->patternrepresentation_1;
		const patternrepresentation r_p = (phylum_cast<const impl_unparsedeclinfo_Unparsedeclinfo*>(this->unparsedeclinfo_1)->patternrepresentation_1)->patternrepresentation_1;
		const patternrepresentation bindings = phylum_cast<const impl_unparsedeclinfo_Unparsedeclinfo*>(this->unparsedeclinfo_1)->patternrepresentation_2;
		const unparseclause uc = phylum_cast<const impl_unparsedeclinfo_Unparsedeclinfo*>(this->unparsedeclinfo_1)->unparseclause_1;
		const unparsedeclsinfo r_udi = this->unparsedeclsinfo_1;
		gl_bindings.clear(); 
		kc::unparse(bindings, kc_printer, view_predicate_bindings);
		{ kc_printer(kc_t("	if (("), kc_current_view); }
		kc::unparse(r_p, kc_printer, view_unp_predicates);
		{ kc_printer(kc_t(")) {\
\n"), kc_current_view); }
		kc::unparse(bindings, kc_printer, view_unp_bindings);
		operatorstack.push( f_operatorofpatternrepresentation( p ) ); 
		kc::unparse(uc, kc_printer, kc_current_view);
		operatorstack.pop(); 
			{ kc_printer(kc_t("	} else\
\n"), kc_current_view); }
		kc::unparse(r_udi, kc_printer, kc_current_view);
	    } else
		    goto kc_unparsing_default;
	    break;
	}

	default:
	kc_unparsing_default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    { /* Alternative( *, args ) -> [view_gen_unparsedefs_default_c: */
		for (unparsedeclsinfo iterator_ = this; iterator_->unparsedeclsinfo_1 != 0; iterator_ = iterator_->unparsedeclsinfo_1)
		    iterator_->unparsedeclinfo_1->unparse(kc_printer, kc_current_view);
	    }
	    break;
	}
    }
}

void
impl_unparsedeclsinfo::nil_do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case view_gen_unparsedefs_other_c_enum: {
	    view_gen_unparsedefs_other_c_class& kc_current_view=static_cast<view_gen_unparsedefs_other_c_class&>(kc_current_view_base);
	    {
		{ kc_printer(kc_t("\vgoto kc_unparsing_default\r;\
\n"), kc_current_view); }
		gl_unparse_goto_used = true; 
	    }
	    break;
	}
	case view_gen_unparsedefs_default_c_enum: {
	    view_gen_unparsedefs_default_c_class& kc_current_view=static_cast<view_gen_unparsedefs_default_c_class&>(kc_current_view_base);
	    {
		phylumdeclaration phydecl = f_lookupdecl( gl_phylum );
		if ( phydecl == 0 ) 
		{

		    v_report(NonFatal( FileLine( gl_phylum->file, gl_phylum->line ), Problem1S1ID( "internal error: could not find declaration of phylum:", gl_phylum )));

		}
		else 
		{
		    kc::unparse(phydecl, kc_printer, kc_current_view);
		}
	    }
	    break;
	}

	default:
	kc_unparsing_default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    { /* Alternative( *, args ) -> [view_gen_unparsedefs_default_c: */
	    }
	    break;
	}
    }
}


void
impl_unparsedeclinfo_Unparsedeclinfo::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    { /* Alternative( *, args ) -> [view_gen_unparsedefs_default_c: */
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


void
impl_ac_declaration_AcDeclaration::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		const ac_declaration_specifiers ds = this->ac_declaration_specifiers_1;
		const ac_init_declarator_list idlo = this->ac_init_declarator_list_1;
		kc::unparse(ds, kc_printer, kc_current_view);
		{ kc_printer(kc_t(" "), kc_current_view); }
		kc::unparse(idlo, kc_printer, kc_current_view);
		{ kc_printer(kc_t(";\
\n"), kc_current_view); }
	    }
	    break;
	}
    }
}

void
impl_ac_declaration_list::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    if(is_nil())
	nil_do_unparse(kc_printer, kc_current_view_base);
    else
	switch(kc_current_view_base) {

	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		const ac_declaration h = this->ac_declaration_1;
		const ac_declaration_list t = this->ac_declaration_list_1;
		kc::unparse(t, kc_printer, kc_current_view);
		kc::unparse(h, kc_printer, kc_current_view);
	    }
	    break;
	}
    }
}

void
impl_ac_declaration_list::nil_do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    { /* Alternative( *, args ) -> [view_gen_unparsedefs_default_c: */
	    }
	    break;
	}
    }
}

void
impl_ac_declaration_specifiers::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    if(is_nil())
	nil_do_unparse(kc_printer, kc_current_view_base);
    else
	switch(kc_current_view_base) {

	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    if ((this->ac_declaration_specifiers_1->prod_sel() == sel_Nilac_declaration_specifiers)) {
		const ac_declaration_specifier h = this->ac_declaration_specifier_1;
		kc::unparse(h, kc_printer, kc_current_view);
	    } else
	    {
		const ac_declaration_specifier h = this->ac_declaration_specifier_1;
		const ac_declaration_specifiers t = this->ac_declaration_specifiers_1;
		kc::unparse(t, kc_printer, kc_current_view);
		{ kc_printer(kc_t(" "), kc_current_view); }
		kc::unparse(h, kc_printer, kc_current_view);
	    }
	    break;
	}
    }
}

void
impl_ac_declaration_specifiers::nil_do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    { /* Alternative( *, args ) -> [view_gen_unparsedefs_default_c: */
	    }
	    break;
	}
    }
}


void
impl_ac_declaration_specifier_AcDeclSpecTypeQual::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    { /* Alternative( *, args ) -> [view_gen_unparsedefs_default_c: */
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


void
impl_ac_declaration_specifier_AcDeclSpecTypeSpec::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    { /* Alternative( *, args ) -> [view_gen_unparsedefs_default_c: */
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


void
impl_ac_declaration_specifier_AcDeclSpecStorageSpec::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    { /* Alternative( *, args ) -> [view_gen_unparsedefs_default_c: */
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


void
impl_ac_storage_class_specifier_AcVirtual::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case view_gen_fnk_c_enum: {
	    view_gen_fnk_c_class& kc_current_view=static_cast<view_gen_fnk_c_class&>(kc_current_view_base);
	    {
	    }
	    break;
	}

	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		{ kc_printer(kc_t("virtual"), kc_current_view); }
	    }
	    break;
	}
    }
}


void
impl_ac_storage_class_specifier_AcTypedef::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		{ kc_printer(kc_t("typedef"), kc_current_view); }
	    }
	    break;
	}
    }
}


void
impl_ac_storage_class_specifier_AcExtern::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		{ kc_printer(kc_t("extern"), kc_current_view); }
	    }
	    break;
	}
    }
}


void
impl_ac_storage_class_specifier_AcStatic::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case view_gen_member_dcl_h_enum: {
	    view_gen_member_dcl_h_class& kc_current_view=static_cast<view_gen_member_dcl_h_class&>(kc_current_view_base);
	    {
		{ kc_printer(kc_t("static"), kc_current_view); }
	    }
	    break;
	}

	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    { /* Alternative( *, args ) -> [view_gen_unparsedefs_default_c: */
	    }
	    break;
	}
    }
}


void
impl_ac_storage_class_specifier_AcRegister::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		{ kc_printer(kc_t("register"), kc_current_view); }
	    }
	    break;
	}
    }
}


void
impl_ac_storage_class_specifier_AcAuto::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		{ kc_printer(kc_t("auto"), kc_current_view); }
	    }
	    break;
	}
    }
}


void
impl_ac_type_specifier_AcTypeSpec::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		const ID i = this->ID_1;
		kc::unparse(i, kc_printer, kc_current_view);
	    }
	    break;
	}
    }
}


void
impl_ac_type_qualifier_AcNoQualifier::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    { /* Alternative( *, args ) -> [view_gen_unparsedefs_default_c: */
	    }
	    break;
	}
    }
}


void
impl_ac_type_qualifier_AcUnsigned::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		{ kc_printer(kc_t("unsigned"), kc_current_view); }
	    }
	    break;
	}
    }
}


void
impl_ac_type_qualifier_AcVolatile::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		{ kc_printer(kc_t("volatile"), kc_current_view); }
	    }
	    break;
	}
    }
}


void
impl_ac_type_qualifier_AcConst::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		{ kc_printer(kc_t("const"), kc_current_view); }
	    }
	    break;
	}
    }
}

void
impl_ac_init_declarator_list::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    if(is_nil())
	nil_do_unparse(kc_printer, kc_current_view_base);
    else
	switch(kc_current_view_base) {

	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    if ((this->ac_init_declarator_list_1->prod_sel() == sel_Nilac_init_declarator_list)) {
		const ac_init_declarator h = this->ac_init_declarator_1;
		kc::unparse(h, kc_printer, kc_current_view);
	    } else
	    {
		const ac_init_declarator h = this->ac_init_declarator_1;
		const ac_init_declarator_list t = this->ac_init_declarator_list_1;
		kc::unparse(t, kc_printer, kc_current_view);
		{ kc_printer(kc_t(" "), kc_current_view); }
		kc::unparse(h, kc_printer, kc_current_view);
	    }
	    break;
	}
    }
}

void
impl_ac_init_declarator_list::nil_do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    { /* Alternative( *, args ) -> [view_gen_unparsedefs_default_c: */
	    }
	    break;
	}
    }
}


void
impl_ac_init_declarator_AcInitDecl::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		const ac_declarator d = this->ac_declarator_1;
		kc::unparse(d, kc_printer, kc_current_view);
	    }
	    break;
	}
    }
}


void
impl_ac_declarator_AcDeclarator::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case view_gen_opt_const_enum: {
	    view_gen_opt_const_class& kc_current_view=static_cast<view_gen_opt_const_class&>(kc_current_view_base);
	    {
		const ac_direct_declarator dd = this->ac_direct_declarator_1;
		kc::unparse(dd, kc_printer, kc_current_view);
	    }
	    break;
	}
	case view_gen_fnkdecls_enum: {
	    view_gen_fnkdecls_class& kc_current_view=static_cast<view_gen_fnkdecls_class&>(kc_current_view_base);
	    {
		const ac_pointer_option po = this->ac_pointer_option_1;
		const ac_ref_option rr = this->ac_ref_option_1;
		const ac_direct_declarator dd = this->ac_direct_declarator_1;
		kc::unparse(po, kc_printer, kc_current_view);
		kc::unparse(rr, kc_printer, kc_current_view);
		kc::unparse(dd, kc_printer, kc_current_view);
	    }
	    break;
	}
	case view_gen_fnkargs_enum: {
	    view_gen_fnkargs_class& kc_current_view=static_cast<view_gen_fnkargs_class&>(kc_current_view_base);
	    {
		const ac_direct_declarator dd = this->ac_direct_declarator_1;
		kc::unparse(dd, kc_printer, kc_current_view);
	    }
	    break;
	}
	case view_gen_fn_pointer_name_enum: {
	    view_gen_fn_pointer_name_class& kc_current_view=static_cast<view_gen_fn_pointer_name_class&>(kc_current_view_base);
	    {
		const ac_pointer_option po = this->ac_pointer_option_1;
		const ac_ref_option rr = this->ac_ref_option_1;
		const ac_direct_declarator dd = this->ac_direct_declarator_1;
		kc::unparse(po, kc_printer, kc_current_view);
		kc::unparse(rr, kc_printer, kc_current_view);
		kc::unparse(dd, kc_printer, kc_current_view);
	    }
	    break;
	}

	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		const ac_pointer_option po = this->ac_pointer_option_1;
		const ac_ref_option rr = this->ac_ref_option_1;
		const ac_direct_declarator dd = this->ac_direct_declarator_1;
		kc::unparse(po, kc_printer, kc_current_view);
		kc::unparse(rr, kc_printer, kc_current_view);
		kc::unparse(dd, kc_printer, kc_current_view);
	    }
	    break;
	}
    }
}


void
impl_ac_direct_declarator_AcOperatorDeclId::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		const ac_operator_name id = this->ac_operator_name_1;
		{ kc_printer(kc_t("operator "), kc_current_view); }
		kc::unparse(id, kc_printer, kc_current_view);
	    }
	    break;
	}
    }
}


void
impl_ac_direct_declarator_AcConvOperatorDecl::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case view_gen_member_dcl_h_enum: {
	    view_gen_member_dcl_h_class& kc_current_view=static_cast<view_gen_member_dcl_h_class&>(kc_current_view_base);
	    {
		const ID id = this->ID_2;
		{ kc_printer(kc_t("operator "), kc_current_view); }
		kc::unparse(id, kc_printer, kc_current_view);
	    }
	    break;
	}
	case view_gen_fn_pointer_name_enum: {
	    view_gen_fn_pointer_name_class& kc_current_view=static_cast<view_gen_fn_pointer_name_class&>(kc_current_view_base);
	    {
		const ID clid = this->ID_1;
		const ID id = this->ID_2;
		kc::unparse(clid, kc_printer, view_gen_fn_pointer_name);
		{ kc_printer(kc_t("::operator "), kc_current_view); }
		kc::unparse(id, kc_printer, kc_current_view);
	    }
	    break;
	}
	case view_gen_fnk_c_enum: {
	    view_gen_fnk_c_class& kc_current_view=static_cast<view_gen_fnk_c_class&>(kc_current_view_base);
	    {
		const ID clid = this->ID_1;
		const ID id = this->ID_2;
		kc::unparse(clid, kc_printer, view_gen_fn_pointer_name);
		{ kc_printer(kc_t("::operator "), kc_current_view); }
		kc::unparse(id, kc_printer, kc_current_view);
	    }
	    break;
	}

	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    { /* Alternative( *, args ) -> [view_gen_unparsedefs_default_c: */
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


void
impl_ac_direct_declarator_AcMemberDecl::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case view_gen_member_dcl_h_enum: {
	    view_gen_member_dcl_h_class& kc_current_view=static_cast<view_gen_member_dcl_h_class&>(kc_current_view_base);
	    {
		const ID id = this->ID_2;
		const ac_constant_expression_list idxs = this->ac_constant_expression_list_1;
		kc::unparse(id, kc_printer, kc_current_view);
		kc::unparse(idxs, kc_printer, kc_current_view);
	    }
	    break;
	}
	case view_gen_fn_pointer_name_enum: {
	    view_gen_fn_pointer_name_class& kc_current_view=static_cast<view_gen_fn_pointer_name_class&>(kc_current_view_base);
	    {
		const ID clid = this->ID_1;
		const ID id = this->ID_2;
		const ac_constant_expression_list idxs = this->ac_constant_expression_list_1;
		kc::unparse(clid, kc_printer, view_gen_fn_pointer_name);
		{ kc_printer(kc_t("::"), kc_current_view); }
		kc::unparse(id, kc_printer, kc_current_view);
		kc::unparse(idxs, kc_printer, kc_current_view);
	    }
	    break;
	}
	case view_gen_fnk_c_enum: {
	    view_gen_fnk_c_class& kc_current_view=static_cast<view_gen_fnk_c_class&>(kc_current_view_base);
	    {
		const ID clid = this->ID_1;
		const ID id = this->ID_2;
		const ac_constant_expression_list idxs = this->ac_constant_expression_list_1;
		kc::unparse(clid, kc_printer, view_gen_fn_pointer_name);
		{ kc_printer(kc_t("::"), kc_current_view); }
		kc::unparse(id, kc_printer, kc_current_view);
		kc::unparse(idxs, kc_printer, kc_current_view);
	    }
	    break;
	}

	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    { /* Alternative( *, args ) -> [view_gen_unparsedefs_default_c: */
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


void
impl_ac_direct_declarator_AcQualifiedDeclProto::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case view_gen_opt_const_enum: {
	    view_gen_opt_const_class& kc_current_view=static_cast<view_gen_opt_const_class&>(kc_current_view_base);
	    {
		const ac_type_qualifier co = this->ac_type_qualifier_1;
		kc::unparse(co, kc_printer, kc_current_view);
	    }
	    break;
	}
	case view_gen_member_dcl_h_enum: {
	    view_gen_member_dcl_h_class& kc_current_view=static_cast<view_gen_member_dcl_h_class&>(kc_current_view_base);
	    {
		const ac_direct_declarator id = this->ac_direct_declarator_1;
		const ac_parameter_type_list args = this->ac_parameter_type_list_1;
		const ac_type_qualifier opt_const = this->ac_type_qualifier_1;
		kc::unparse(id, kc_printer, kc_current_view);
		{ kc_printer(kc_t("("), kc_current_view); }
		kc::unparse(args, kc_printer, kc_current_view);
		{ kc_printer(kc_t(")"), kc_current_view); }
		kc::unparse(opt_const, kc_printer, kc_current_view);
		{ kc_printer(kc_t(";\
\n"), kc_current_view); }
	    }
	    break;
	}
	case view_gen_fnkdecls_enum: {
	    view_gen_fnkdecls_class& kc_current_view=static_cast<view_gen_fnkdecls_class&>(kc_current_view_base);
	    if ((this->ac_class_qualifier_list_1->prod_sel() == sel_Nilac_class_qualifier_list)) {
		const ac_direct_declarator dd = this->ac_direct_declarator_1;
		kc::unparse(dd, kc_printer, kc_current_view);
		{ kc_printer(kc_t("()"), kc_current_view); }
	    } else
	    {
	    }
	    break;
	}
	case view_gen_fnkargs_enum: {
	    view_gen_fnkargs_class& kc_current_view=static_cast<view_gen_fnkargs_class&>(kc_current_view_base);
	    {
		const ac_direct_declarator dd = this->ac_direct_declarator_1;
		kc::unparse(dd, kc_printer, kc_current_view);
	    }
	    break;
	}
	case view_gen_fn_pointer_name_enum: {
	    view_gen_fn_pointer_name_class& kc_current_view=static_cast<view_gen_fn_pointer_name_class&>(kc_current_view_base);
	    {
		const ac_class_qualifier_list dd = this->ac_class_qualifier_list_1;
		const ac_direct_declarator id = this->ac_direct_declarator_1;
		kc::unparse(dd, kc_printer, kc_current_view);
		kc::unparse(id, kc_printer, kc_current_view);
	    }
	    break;
	}

	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		const ac_class_qualifier_list qq = this->ac_class_qualifier_list_1;
		const ac_direct_declarator id = this->ac_direct_declarator_1;
		const ac_parameter_type_list ptl = this->ac_parameter_type_list_1;
		const ac_type_qualifier oc = this->ac_type_qualifier_1;
		kc::unparse(qq, kc_printer, kc_current_view);
		kc::unparse(id, kc_printer, kc_current_view);
		{ kc_printer(kc_t("("), kc_current_view); }
		kc::unparse(ptl, kc_printer, kc_current_view);
		{ kc_printer(kc_t(")"), kc_current_view); }
		kc::unparse(oc, kc_printer, kc_current_view);
	    }
	    break;
	}
    }
}


void
impl_ac_direct_declarator_AcDirectDeclProto::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case view_gen_opt_const_enum: {
	    view_gen_opt_const_class& kc_current_view=static_cast<view_gen_opt_const_class&>(kc_current_view_base);
	    {
	    }
	    break;
	}
	case view_gen_fnkdecls_enum: {
	    view_gen_fnkdecls_class& kc_current_view=static_cast<view_gen_fnkdecls_class&>(kc_current_view_base);
	    {
		const ac_direct_declarator dd = this->ac_direct_declarator_1;
		kc::unparse(dd, kc_printer, kc_current_view);
		{ kc_printer(kc_t("()"), kc_current_view); }
	    }
	    break;
	}
	case view_gen_fnkargs_enum: {
	    view_gen_fnkargs_class& kc_current_view=static_cast<view_gen_fnkargs_class&>(kc_current_view_base);
	    {
		const ac_direct_declarator dd = this->ac_direct_declarator_1;
		kc::unparse(dd, kc_printer, kc_current_view);
	    }
	    break;
	}
	case view_gen_fn_pointer_name_enum: {
	    view_gen_fn_pointer_name_class& kc_current_view=static_cast<view_gen_fn_pointer_name_class&>(kc_current_view_base);
	    {
		const ac_direct_declarator dd = this->ac_direct_declarator_1;
		kc::unparse(dd, kc_printer, kc_current_view);
	    }
	    break;
	}

	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		const ac_direct_declarator dd = this->ac_direct_declarator_1;
		const ac_parameter_type_list ptl = this->ac_parameter_type_list_1;
		kc::unparse(dd, kc_printer, kc_current_view);
		{ kc_printer(kc_t("("), kc_current_view); }
		kc::unparse(ptl, kc_printer, kc_current_view);
		{ kc_printer(kc_t(")"), kc_current_view); }
	    }
	    break;
	}
    }
}


void
impl_ac_direct_declarator_AcDirectDeclArray::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case view_gen_fnkdecls_enum: {
	    view_gen_fnkdecls_class& kc_current_view=static_cast<view_gen_fnkdecls_class&>(kc_current_view_base);
	    {
		const ac_direct_declarator dd = this->ac_direct_declarator_1;
		const ac_constant_expression_option ceo = this->ac_constant_expression_option_1;
		kc::unparse(dd, kc_printer, kc_current_view);
		{ kc_printer(kc_t("["), kc_current_view); }
		kc::unparse(ceo, kc_printer, kc_current_view);
		{ kc_printer(kc_t("]"), kc_current_view); }
	    }
	    break;
	}
	case view_gen_fnkargs_enum: {
	    view_gen_fnkargs_class& kc_current_view=static_cast<view_gen_fnkargs_class&>(kc_current_view_base);
	    {
		const ac_direct_declarator dd = this->ac_direct_declarator_1;
		kc::unparse(dd, kc_printer, kc_current_view);
	    }
	    break;
	}

	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		const ac_direct_declarator dd = this->ac_direct_declarator_1;
		const ac_constant_expression_option ceo = this->ac_constant_expression_option_1;
		kc::unparse(dd, kc_printer, kc_current_view);
		{ kc_printer(kc_t("["), kc_current_view); }
		kc::unparse(ceo, kc_printer, kc_current_view);
		{ kc_printer(kc_t("]"), kc_current_view); }
	    }
	    break;
	}
    }
}


void
impl_ac_direct_declarator_AcDirectDeclPack::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case view_gen_fnkdecls_enum: {
	    view_gen_fnkdecls_class& kc_current_view=static_cast<view_gen_fnkdecls_class&>(kc_current_view_base);
	    {
		const ac_declarator d = this->ac_declarator_1;
		{ kc_printer(kc_t("("), kc_current_view); }
		kc::unparse(d, kc_printer, kc_current_view);
		{ kc_printer(kc_t(")"), kc_current_view); }
	    }
	    break;
	}
	case view_gen_fnkargs_enum: {
	    view_gen_fnkargs_class& kc_current_view=static_cast<view_gen_fnkargs_class&>(kc_current_view_base);
	    {
		const ac_declarator d = this->ac_declarator_1;
		kc::unparse(d, kc_printer, kc_current_view);
	    }
	    break;
	}

	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		const ac_declarator d = this->ac_declarator_1;
		{ kc_printer(kc_t("("), kc_current_view); }
		kc::unparse(d, kc_printer, kc_current_view);
		{ kc_printer(kc_t(")"), kc_current_view); }
	    }
	    break;
	}
    }
}


void
impl_ac_direct_declarator_AcDirectDeclId::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case view_gen_fnkdecls_enum: {
	    view_gen_fnkdecls_class& kc_current_view=static_cast<view_gen_fnkdecls_class&>(kc_current_view_base);
	    {
		const ID i = this->ID_1;
		kc::unparse(i, kc_printer, kc_current_view);
	    }
	    break;
	}

	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		const ID i = this->ID_1;
		kc::unparse(i, kc_printer, kc_current_view);
	    }
	    break;
	}
    }
}


void
impl_ac_pointer_option_Yespointer::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		const ac_pointer p = this->ac_pointer_1;
		kc::unparse(p, kc_printer, kc_current_view);
	    }
	    break;
	}
    }
}


void
impl_ac_pointer_option_Nopointer::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
	    }
	    break;
	}
    }
}


void
impl_ac_pointer_AcPointerCons::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    if ((this->ac_type_qualifier_list_1->prod_sel() == sel_Nilac_type_qualifier_list)) {
		const ac_pointer p = this->ac_pointer_1;
		{ kc_printer(kc_t("*"), kc_current_view); }
		kc::unparse(p, kc_printer, kc_current_view);
	    } else
	    {
		const ac_type_qualifier_list tql = this->ac_type_qualifier_list_1;
		const ac_pointer p = this->ac_pointer_1;
		{ kc_printer(kc_t("* "), kc_current_view); }
		kc::unparse(tql, kc_printer, kc_current_view);
		{ kc_printer(kc_t(" "), kc_current_view); }
		kc::unparse(p, kc_printer, kc_current_view);
	    }
	    break;
	}
    }
}


void
impl_ac_pointer_AcPointerNil::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    if ((this->ac_type_qualifier_list_1->prod_sel() == sel_Nilac_type_qualifier_list)) {
		{ kc_printer(kc_t("*"), kc_current_view); }
	    } else
	    {
		const ac_type_qualifier_list tql = this->ac_type_qualifier_list_1;
		{ kc_printer(kc_t("* "), kc_current_view); }
		kc::unparse(tql, kc_printer, kc_current_view);
		{ kc_printer(kc_t(" "), kc_current_view); }
	    }
	    break;
	}
    }
}


void
impl_ac_ref_option_AcRef::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		{ kc_printer(kc_t("&"), kc_current_view); }
	    }
	    break;
	}
    }
}


void
impl_ac_ref_option_AcNoRef::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
	    }
	    break;
	}
    }
}


void
impl_ac_operator_name_AcOperatorName::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    { /* Alternative( *, args ) -> [view_gen_unparsedefs_default_c: */
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}

void
impl_ac_class_qualifier_help_list::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    if(is_nil())
	nil_do_unparse(kc_printer, kc_current_view_base);
    else
	switch(kc_current_view_base) {

	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    { /* Alternative( *, args ) -> [view_gen_unparsedefs_default_c: */
		for (ac_class_qualifier_help_list iterator_ = this; iterator_->ac_class_qualifier_help_list_1 != 0; iterator_ = iterator_->ac_class_qualifier_help_list_1)
		    iterator_->ac_direct_declarator_1->unparse(kc_printer, kc_current_view);
	    }
	    break;
	}
    }
}

void
impl_ac_class_qualifier_help_list::nil_do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    { /* Alternative( *, args ) -> [view_gen_unparsedefs_default_c: */
	    }
	    break;
	}
    }
}

void
impl_ac_class_qualifier_list::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    if(is_nil())
	nil_do_unparse(kc_printer, kc_current_view_base);
    else
	switch(kc_current_view_base) {

	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		const ID head = this->ID_1;
		const ac_class_qualifier_list tail = this->ac_class_qualifier_list_1;
		kc::unparse(tail, kc_printer, kc_current_view);
		kc::unparse(head, kc_printer, kc_current_view);
		{ kc_printer(kc_t("::"), kc_current_view); }
	    }
	    break;
	}
    }
}

void
impl_ac_class_qualifier_list::nil_do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    { /* Alternative( *, args ) -> [view_gen_unparsedefs_default_c: */
	    }
	    break;
	}
    }
}

void
impl_ac_type_qualifier_list::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    if(is_nil())
	nil_do_unparse(kc_printer, kc_current_view_base);
    else
	switch(kc_current_view_base) {

	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    if ((this->ac_type_qualifier_list_1->prod_sel() == sel_Nilac_type_qualifier_list)) {
		const ac_type_qualifier h = this->ac_type_qualifier_1;
		kc::unparse(h, kc_printer, kc_current_view);
	    } else
	    {
		const ac_type_qualifier h = this->ac_type_qualifier_1;
		const ac_type_qualifier_list t = this->ac_type_qualifier_list_1;
		kc::unparse(t, kc_printer, kc_current_view);
		{ kc_printer(kc_t(" "), kc_current_view); }
		kc::unparse(h, kc_printer, kc_current_view);
	    }
	    break;
	}
    }
}

void
impl_ac_type_qualifier_list::nil_do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    { /* Alternative( *, args ) -> [view_gen_unparsedefs_default_c: */
	    }
	    break;
	}
    }
}


void
impl_ac_parameter_type_list_AcParList3Dot::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case view_gen_fnkdecls_enum: {
	    view_gen_fnkdecls_class& kc_current_view=static_cast<view_gen_fnkdecls_class&>(kc_current_view_base);
	    {
		const ac_parameter_list pl = this->ac_parameter_list_1;
		kc::unparse(pl, kc_printer, kc_current_view);
	    }
	    break;
	}
	case view_gen_fnkargs_enum: {
	    view_gen_fnkargs_class& kc_current_view=static_cast<view_gen_fnkargs_class&>(kc_current_view_base);
	    {
		const ac_parameter_list pl = this->ac_parameter_list_1;
		kc::unparse(pl, kc_printer, kc_current_view);
	    }
	    break;
	}

	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		const ac_parameter_list pl = this->ac_parameter_list_1;
		kc::unparse(pl, kc_printer, kc_current_view);
		{ kc_printer(kc_t(" ..."), kc_current_view); }
	    }
	    break;
	}
    }
}


void
impl_ac_parameter_type_list_AcParList::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case view_gen_fnkdecls_enum: {
	    view_gen_fnkdecls_class& kc_current_view=static_cast<view_gen_fnkdecls_class&>(kc_current_view_base);
	    if ((this->ac_parameter_list_1->prod_sel() == sel_Nilac_parameter_list)) {
	    } else
		    goto kc_unparsing_default;
	    break;
	}
	case view_gen_fnkargs_enum: {
	    view_gen_fnkargs_class& kc_current_view=static_cast<view_gen_fnkargs_class&>(kc_current_view_base);
	    if ((this->ac_parameter_list_1->prod_sel() == sel_Nilac_parameter_list)) {
	    } else
		    goto kc_unparsing_default;
	    break;
	}

	default:
	kc_unparsing_default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		const ac_parameter_list pl = this->ac_parameter_list_1;
		kc::unparse(pl, kc_printer, kc_current_view);
	    }
	    break;
	}
    }
}

void
impl_ac_parameter_list::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    if(is_nil())
	nil_do_unparse(kc_printer, kc_current_view_base);
    else
	switch(kc_current_view_base) {
	case view_gen_fnkdecls_enum: {
	    view_gen_fnkdecls_class& kc_current_view=static_cast<view_gen_fnkdecls_class&>(kc_current_view_base);
	    if ((this->ac_parameter_list_1->prod_sel() == sel_Nilac_parameter_list)) {
		const ac_parameter_declaration h = this->ac_parameter_declaration_1;
		kc::unparse(h, kc_printer, kc_current_view);
		{ kc_printer(kc_t(";"), kc_current_view); }
	    } else
	    {
		const ac_parameter_declaration h = this->ac_parameter_declaration_1;
		const ac_parameter_list t = this->ac_parameter_list_1;
		kc::unparse(t, kc_printer, kc_current_view);
		{ kc_printer(kc_t("\n"), kc_current_view); }
		kc::unparse(h, kc_printer, kc_current_view);
		{ kc_printer(kc_t(";"), kc_current_view); }
	    }
	    break;
	}

	default:
	kc_unparsing_default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    if ((this->ac_parameter_list_1->prod_sel() == sel_Nilac_parameter_list)) {
		const ac_parameter_declaration h = this->ac_parameter_declaration_1;
		kc::unparse(h, kc_printer, kc_current_view);
	    } else
	    {
		const ac_parameter_declaration h = this->ac_parameter_declaration_1;
		const ac_parameter_list t = this->ac_parameter_list_1;
		kc::unparse(t, kc_printer, kc_current_view);
		{ kc_printer(kc_t(", "), kc_current_view); }
		kc::unparse(h, kc_printer, kc_current_view);
	    }
	    break;
	}
    }
}

void
impl_ac_parameter_list::nil_do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

	default:
	kc_unparsing_default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    { /* Alternative( *, args ) -> [view_gen_unparsedefs_default_c: */
	    }
	    break;
	}
    }
}


void
impl_ac_parameter_declaration_AcParDeclAbsdecl::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case view_gen_member_dcl_h_enum: {
	    view_gen_member_dcl_h_class& kc_current_view=static_cast<view_gen_member_dcl_h_class&>(kc_current_view_base);
	    if ((this->ac_constant_expression_option_1->prod_sel() == sel_Noac_constant_expression)) {
		const ac_declaration_specifiers ds = this->ac_declaration_specifiers_1;
		const ac_abstract_declarator ad = this->ac_abstract_declarator_1;
		kc::unparse(ds, kc_printer, kc_current_view);
		{ kc_printer(kc_t(" "), kc_current_view); }
		kc::unparse(ad, kc_printer, kc_current_view);
	    } else
		if ((this->ac_constant_expression_option_1->prod_sel() == sel_Yesac_constant_expression)) {
		const ac_declaration_specifiers ds = this->ac_declaration_specifiers_1;
		const ac_abstract_declarator ad = this->ac_abstract_declarator_1;
		const ac_constant_expression expr = phylum_cast<const impl_ac_constant_expression_option_Yesac_constant_expression*>(this->ac_constant_expression_option_1)->ac_constant_expression_1;
		kc::unparse(ds, kc_printer, kc_current_view);
		{ kc_printer(kc_t(" "), kc_current_view); }
		kc::unparse(ad, kc_printer, kc_current_view);
		{ kc_printer(kc_t("="), kc_current_view); }
		kc::unparse(expr, kc_printer, kc_current_view);
	    } else
		    goto kc_unparsing_default;
	    break;
	}
	case view_gen_fnkdecls_enum: {
	    view_gen_fnkdecls_class& kc_current_view=static_cast<view_gen_fnkdecls_class&>(kc_current_view_base);
	    if ((this->ac_constant_expression_option_1->prod_sel() == sel_Noac_constant_expression)) {
		const ac_declaration_specifiers ds = this->ac_declaration_specifiers_1;
		const ac_abstract_declarator ad = this->ac_abstract_declarator_1;
		kc::unparse(ds, kc_printer, kc_current_view);
		{ kc_printer(kc_t(" "), kc_current_view); }
		kc::unparse(ad, kc_printer, kc_current_view);
	    } else
		if ((this->ac_constant_expression_option_1->prod_sel() == sel_Yesac_constant_expression)) {
		const ac_declaration_specifiers ds = this->ac_declaration_specifiers_1;
		const ac_abstract_declarator ad = this->ac_abstract_declarator_1;
		const ac_constant_expression expr = phylum_cast<const impl_ac_constant_expression_option_Yesac_constant_expression*>(this->ac_constant_expression_option_1)->ac_constant_expression_1;
		kc::unparse(ds, kc_printer, kc_current_view);
		{ kc_printer(kc_t(" "), kc_current_view); }
		kc::unparse(ad, kc_printer, kc_current_view);
		{ kc_printer(kc_t("="), kc_current_view); }
		kc::unparse(expr, kc_printer, kc_current_view);
	    } else
		    goto kc_unparsing_default;
	    break;
	}
	case view_gen_fnkargs_enum: {
	    view_gen_fnkargs_class& kc_current_view=static_cast<view_gen_fnkargs_class&>(kc_current_view_base);
	    {
		const ac_abstract_declarator ad = this->ac_abstract_declarator_1;
		kc::unparse(ad, kc_printer, kc_current_view);
	    }
	    break;
	}
	case view_gen_fnkdecls_c_enum: {
	    view_gen_fnkdecls_c_class& kc_current_view=static_cast<view_gen_fnkdecls_c_class&>(kc_current_view_base);
	    if ((this->ac_constant_expression_option_1->prod_sel() == sel_Noac_constant_expression)) {
		const ac_declaration_specifiers ds = this->ac_declaration_specifiers_1;
		const ac_abstract_declarator ad = this->ac_abstract_declarator_1;
		kc::unparse(ds, kc_printer, kc_current_view);
		{ kc_printer(kc_t(" "), kc_current_view); }
		kc::unparse(ad, kc_printer, kc_current_view);
	    } else
		if ((this->ac_constant_expression_option_1->prod_sel() == sel_Yesac_constant_expression)) {
		const ac_declaration_specifiers ds = this->ac_declaration_specifiers_1;
		const ac_abstract_declarator ad = this->ac_abstract_declarator_1;
		const ac_constant_expression expr = phylum_cast<const impl_ac_constant_expression_option_Yesac_constant_expression*>(this->ac_constant_expression_option_1)->ac_constant_expression_1;
		kc::unparse(ds, kc_printer, kc_current_view);
		{ kc_printer(kc_t(" "), kc_current_view); }
		kc::unparse(ad, kc_printer, kc_current_view);
		{ kc_printer(kc_t("="), kc_current_view); }
		kc::unparse(expr, kc_printer, kc_current_view);
	    } else
		    goto kc_unparsing_default;
	    break;
	}
	case view_gen_fnk_h_enum: {
	    view_gen_fnk_h_class& kc_current_view=static_cast<view_gen_fnk_h_class&>(kc_current_view_base);
	    if ((this->ac_constant_expression_option_1->prod_sel() == sel_Noac_constant_expression)) {
		const ac_declaration_specifiers ds = this->ac_declaration_specifiers_1;
		const ac_abstract_declarator ad = this->ac_abstract_declarator_1;
		kc::unparse(ds, kc_printer, kc_current_view);
		{ kc_printer(kc_t(" "), kc_current_view); }
		kc::unparse(ad, kc_printer, kc_current_view);
	    } else
		if ((this->ac_constant_expression_option_1->prod_sel() == sel_Yesac_constant_expression)) {
		const ac_declaration_specifiers ds = this->ac_declaration_specifiers_1;
		const ac_abstract_declarator ad = this->ac_abstract_declarator_1;
		const ac_constant_expression expr = phylum_cast<const impl_ac_constant_expression_option_Yesac_constant_expression*>(this->ac_constant_expression_option_1)->ac_constant_expression_1;
		kc::unparse(ds, kc_printer, kc_current_view);
		{ kc_printer(kc_t(" "), kc_current_view); }
		kc::unparse(ad, kc_printer, kc_current_view);
		{ kc_printer(kc_t("="), kc_current_view); }
		kc::unparse(expr, kc_printer, kc_current_view);
	    } else
		    goto kc_unparsing_default;
	    break;
	}

	default:
	kc_unparsing_default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		const ac_declaration_specifiers ds = this->ac_declaration_specifiers_1;
		const ac_abstract_declarator ad = this->ac_abstract_declarator_1;
		kc::unparse(ds, kc_printer, kc_current_view);
		{ kc_printer(kc_t(" "), kc_current_view); }
		kc::unparse(ad, kc_printer, kc_current_view);
	    }
	    break;
	}
    }
}


void
impl_ac_parameter_declaration_AcParDeclDecl::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case view_gen_member_dcl_h_enum: {
	    view_gen_member_dcl_h_class& kc_current_view=static_cast<view_gen_member_dcl_h_class&>(kc_current_view_base);
	    if ((this->ac_constant_expression_option_1->prod_sel() == sel_Noac_constant_expression)) {
		const ac_declaration_specifiers ds = this->ac_declaration_specifiers_1;
		const ac_declarator d = this->ac_declarator_1;
		kc::unparse(ds, kc_printer, kc_current_view);
		{ kc_printer(kc_t(" "), kc_current_view); }
		kc::unparse(d, kc_printer, kc_current_view);
	    } else
		if ((this->ac_constant_expression_option_1->prod_sel() == sel_Yesac_constant_expression)) {
		const ac_declaration_specifiers ds = this->ac_declaration_specifiers_1;
		const ac_declarator d = this->ac_declarator_1;
		const ac_constant_expression expr = phylum_cast<const impl_ac_constant_expression_option_Yesac_constant_expression*>(this->ac_constant_expression_option_1)->ac_constant_expression_1;
		kc::unparse(ds, kc_printer, kc_current_view);
		{ kc_printer(kc_t(" "), kc_current_view); }
		kc::unparse(d, kc_printer, kc_current_view);
		{ kc_printer(kc_t("="), kc_current_view); }
		kc::unparse(expr, kc_printer, kc_current_view);
	    } else
		    goto kc_unparsing_default;
	    break;
	}
	case view_gen_fnkdecls_enum: {
	    view_gen_fnkdecls_class& kc_current_view=static_cast<view_gen_fnkdecls_class&>(kc_current_view_base);
	    if ((this->ac_constant_expression_option_1->prod_sel() == sel_Noac_constant_expression)) {
		const ac_declaration_specifiers ds = this->ac_declaration_specifiers_1;
		const ac_declarator d = this->ac_declarator_1;
		kc::unparse(ds, kc_printer, kc_current_view);
		{ kc_printer(kc_t(" "), kc_current_view); }
		kc::unparse(d, kc_printer, kc_current_view);
	    } else
		if ((this->ac_constant_expression_option_1->prod_sel() == sel_Yesac_constant_expression)) {
		const ac_declaration_specifiers ds = this->ac_declaration_specifiers_1;
		const ac_declarator d = this->ac_declarator_1;
		const ac_constant_expression expr = phylum_cast<const impl_ac_constant_expression_option_Yesac_constant_expression*>(this->ac_constant_expression_option_1)->ac_constant_expression_1;
		kc::unparse(ds, kc_printer, kc_current_view);
		{ kc_printer(kc_t(" "), kc_current_view); }
		kc::unparse(d, kc_printer, kc_current_view);
		{ kc_printer(kc_t("="), kc_current_view); }
		kc::unparse(expr, kc_printer, kc_current_view);
	    } else
		    goto kc_unparsing_default;
	    break;
	}
	case view_gen_fnkargs_enum: {
	    view_gen_fnkargs_class& kc_current_view=static_cast<view_gen_fnkargs_class&>(kc_current_view_base);
	    {
		const ac_declarator d = this->ac_declarator_1;
		kc::unparse(d, kc_printer, kc_current_view);
	    }
	    break;
	}
	case view_gen_fnkdecls_c_enum: {
	    view_gen_fnkdecls_c_class& kc_current_view=static_cast<view_gen_fnkdecls_c_class&>(kc_current_view_base);
	    if ((this->ac_constant_expression_option_1->prod_sel() == sel_Noac_constant_expression)) {
		const ac_declaration_specifiers ds = this->ac_declaration_specifiers_1;
		const ac_declarator d = this->ac_declarator_1;
		kc::unparse(ds, kc_printer, kc_current_view);
		{ kc_printer(kc_t(" "), kc_current_view); }
		kc::unparse(d, kc_printer, kc_current_view);
	    } else
		if ((this->ac_constant_expression_option_1->prod_sel() == sel_Yesac_constant_expression)) {
		const ac_declaration_specifiers ds = this->ac_declaration_specifiers_1;
		const ac_declarator d = this->ac_declarator_1;
		const ac_constant_expression expr = phylum_cast<const impl_ac_constant_expression_option_Yesac_constant_expression*>(this->ac_constant_expression_option_1)->ac_constant_expression_1;
		kc::unparse(ds, kc_printer, kc_current_view);
		{ kc_printer(kc_t(" "), kc_current_view); }
		kc::unparse(d, kc_printer, kc_current_view);
		{ kc_printer(kc_t("="), kc_current_view); }
		kc::unparse(expr, kc_printer, kc_current_view);
	    } else
		    goto kc_unparsing_default;
	    break;
	}
	case view_gen_fnk_h_enum: {
	    view_gen_fnk_h_class& kc_current_view=static_cast<view_gen_fnk_h_class&>(kc_current_view_base);
	    if ((this->ac_constant_expression_option_1->prod_sel() == sel_Noac_constant_expression)) {
		const ac_declaration_specifiers ds = this->ac_declaration_specifiers_1;
		const ac_declarator d = this->ac_declarator_1;
		kc::unparse(ds, kc_printer, kc_current_view);
		{ kc_printer(kc_t(" "), kc_current_view); }
		kc::unparse(d, kc_printer, kc_current_view);
	    } else
		if ((this->ac_constant_expression_option_1->prod_sel() == sel_Yesac_constant_expression)) {
		const ac_declaration_specifiers ds = this->ac_declaration_specifiers_1;
		const ac_declarator d = this->ac_declarator_1;
		const ac_constant_expression expr = phylum_cast<const impl_ac_constant_expression_option_Yesac_constant_expression*>(this->ac_constant_expression_option_1)->ac_constant_expression_1;
		kc::unparse(ds, kc_printer, kc_current_view);
		{ kc_printer(kc_t(" "), kc_current_view); }
		kc::unparse(d, kc_printer, kc_current_view);
		{ kc_printer(kc_t("="), kc_current_view); }
		kc::unparse(expr, kc_printer, kc_current_view);
	    } else
		    goto kc_unparsing_default;
	    break;
	}

	default:
	kc_unparsing_default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		const ac_declaration_specifiers ds = this->ac_declaration_specifiers_1;
		const ac_declarator d = this->ac_declarator_1;
		kc::unparse(ds, kc_printer, kc_current_view);
		{ kc_printer(kc_t(" "), kc_current_view); }
		kc::unparse(d, kc_printer, kc_current_view);
	    }
	    break;
	}
    }
}

void
impl_ac_identifier_list::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    if(is_nil())
	nil_do_unparse(kc_printer, kc_current_view_base);
    else
	switch(kc_current_view_base) {

	default:
	kc_unparsing_default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    if ((this->ac_identifier_list_1->prod_sel() == sel_Nilac_identifier_list)) {
		const ID h = this->ID_1;
		kc::unparse(h, kc_printer, kc_current_view);
	    } else
	    {
		const ID h = this->ID_1;
		const ac_identifier_list t = this->ac_identifier_list_1;
		kc::unparse(t, kc_printer, kc_current_view);
		{ kc_printer(kc_t(", "), kc_current_view); }
		kc::unparse(h, kc_printer, kc_current_view);
	    }
	    break;
	}
    }
}

void
impl_ac_identifier_list::nil_do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

	default:
	kc_unparsing_default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    { /* Alternative( *, args ) -> [view_gen_unparsedefs_default_c: */
	    }
	    break;
	}
    }
}


void
impl_ac_abstract_declarator_AcAbsdeclDirdecl::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case view_gen_fnkdecls_enum: {
	    view_gen_fnkdecls_class& kc_current_view=static_cast<view_gen_fnkdecls_class&>(kc_current_view_base);
	    {
		const ac_pointer_option p = this->ac_pointer_option_1;
		const ac_direct_abstract_declarator dad = this->ac_direct_abstract_declarator_1;
		kc::unparse(p, kc_printer, kc_current_view);
		kc::unparse(dad, kc_printer, kc_current_view);
	    }
	    break;
	}
	case view_gen_fnkargs_enum: {
	    view_gen_fnkargs_class& kc_current_view=static_cast<view_gen_fnkargs_class&>(kc_current_view_base);
	    {
		const ac_direct_abstract_declarator dad = this->ac_direct_abstract_declarator_1;
		kc::unparse(dad, kc_printer, kc_current_view);
	    }
	    break;
	}

	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		const ac_pointer_option po = this->ac_pointer_option_1;
		const ac_direct_abstract_declarator dad = this->ac_direct_abstract_declarator_1;
		kc::unparse(po, kc_printer, kc_current_view);
		kc::unparse(dad, kc_printer, kc_current_view);
	    }
	    break;
	}
    }
}


void
impl_ac_abstract_declarator_AcAbsdeclPointer::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case view_gen_fnkdecls_enum: {
	    view_gen_fnkdecls_class& kc_current_view=static_cast<view_gen_fnkdecls_class&>(kc_current_view_base);
	    {
		const ac_pointer p = this->ac_pointer_1;
		kc::unparse(p, kc_printer, kc_current_view);
		{ kc_printer(kc_t(" kc_arg_missing"), kc_current_view); }
	    }
	    break;
	}
	case view_gen_fnkargs_enum: {
	    view_gen_fnkargs_class& kc_current_view=static_cast<view_gen_fnkargs_class&>(kc_current_view_base);
	    {
		{ kc_printer(kc_t("kc_arg_missing"), kc_current_view); }
	    }
	    break;
	}

	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		const ac_pointer p = this->ac_pointer_1;
		kc::unparse(p, kc_printer, kc_current_view);
	    }
	    break;
	}
    }
}


void
impl_ac_direct_abstract_declarator_option_Yesac_direct_abstract_declarator::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		const ac_direct_abstract_declarator dad = this->ac_direct_abstract_declarator_1;
		kc::unparse(dad, kc_printer, kc_current_view);
	    }
	    break;
	}
    }
}


void
impl_ac_direct_abstract_declarator_option_Noac_direct_abstract_declarator::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    { /* Alternative( *, args ) -> [view_gen_unparsedefs_default_c: */
	    }
	    break;
	}
    }
}


void
impl_ac_direct_abstract_declarator_AcDirAbsdeclFn::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case view_gen_fnkargs_enum: {
	    view_gen_fnkargs_class& kc_current_view=static_cast<view_gen_fnkargs_class&>(kc_current_view_base);
	    {
		const ac_direct_abstract_declarator_option dado = this->ac_direct_abstract_declarator_option_1;
		kc::unparse(dado, kc_printer, kc_current_view);
	    }
	    break;
	}

	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		const ac_direct_abstract_declarator_option dado = this->ac_direct_abstract_declarator_option_1;
		const ac_parameter_type_list ptl = this->ac_parameter_type_list_1;
		kc::unparse(dado, kc_printer, kc_current_view);
		{ kc_printer(kc_t("("), kc_current_view); }
		kc::unparse(ptl, kc_printer, kc_current_view);
		{ kc_printer(kc_t(")"), kc_current_view); }
	    }
	    break;
	}
    }
}


void
impl_ac_direct_abstract_declarator_AcDirAbsdeclArray::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case view_gen_fnkargs_enum: {
	    view_gen_fnkargs_class& kc_current_view=static_cast<view_gen_fnkargs_class&>(kc_current_view_base);
	    {
		const ac_direct_abstract_declarator_option dado = this->ac_direct_abstract_declarator_option_1;
		kc::unparse(dado, kc_printer, kc_current_view);
	    }
	    break;
	}

	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		const ac_direct_abstract_declarator_option dado = this->ac_direct_abstract_declarator_option_1;
		const ac_constant_expression_option ceo = this->ac_constant_expression_option_1;
		kc::unparse(dado, kc_printer, kc_current_view);
		{ kc_printer(kc_t("["), kc_current_view); }
		kc::unparse(ceo, kc_printer, kc_current_view);
		{ kc_printer(kc_t("]"), kc_current_view); }
	    }
	    break;
	}
    }
}


void
impl_ac_direct_abstract_declarator_AcDirAbsdeclPack::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case view_gen_fnkargs_enum: {
	    view_gen_fnkargs_class& kc_current_view=static_cast<view_gen_fnkargs_class&>(kc_current_view_base);
	    {
		const ac_abstract_declarator ad = this->ac_abstract_declarator_1;
		kc::unparse(ad, kc_printer, kc_current_view);
	    }
	    break;
	}

	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		const ac_abstract_declarator ad = this->ac_abstract_declarator_1;
		{ kc_printer(kc_t("("), kc_current_view); }
		kc::unparse(ad, kc_printer, kc_current_view);
		{ kc_printer(kc_t(")"), kc_current_view); }
	    }
	    break;
	}
    }
}


void
impl_ac_constant_expression_option_Noac_constant_expression::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    { /* Alternative( *, args ) -> [view_gen_unparsedefs_default_c: */
	    }
	    break;
	}
    }
}


void
impl_ac_constant_expression_option_Yesac_constant_expression::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    { /* Alternative( *, args ) -> [view_gen_unparsedefs_default_c: */
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


void
impl_ac_constant_expression_AcConstExpr::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		const Cexpression ce = this->Cexpression_1;
		kc::unparse(ce, kc_printer, view_gen_initializephyla_c);
	    }
	    break;
	}
    }
}

void
impl_ac_constant_expression_list::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    if(is_nil())
	nil_do_unparse(kc_printer, kc_current_view_base);
    else
	switch(kc_current_view_base) {

	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		const ac_constant_expression head = this->ac_constant_expression_1;
		const ac_constant_expression_list tail = this->ac_constant_expression_list_1;
		kc::unparse(tail, kc_printer, kc_current_view);
		{ kc_printer(kc_t("["), kc_current_view); }
		kc::unparse(head, kc_printer, kc_current_view);
		{ kc_printer(kc_t("]"), kc_current_view); }
	    }
	    break;
	}
    }
}

void
impl_ac_constant_expression_list::nil_do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    { /* Alternative( *, args ) -> [view_gen_unparsedefs_default_c: */
	    }
	    break;
	}
    }
}


void
impl_ac_opt_base_init_list_AcYesBaseInit::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case view_gen_fnk_c_enum: {
	    view_gen_fnk_c_class& kc_current_view=static_cast<view_gen_fnk_c_class&>(kc_current_view_base);
	    {
		const ac_base_init_list base_init_list = this->ac_base_init_list_1;
		{ kc_printer(kc_t(":"), kc_current_view); }
		kc::unparse(base_init_list, kc_printer, kc_current_view);
	    }
	    break;
	}

	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
	    }
	    break;
	}
    }
}


void
impl_ac_opt_base_init_list_AcNoBaseInit::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
	    }
	    break;
	}
    }
}

void
impl_ac_base_init_list::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    if(is_nil())
	nil_do_unparse(kc_printer, kc_current_view_base);
    else
	switch(kc_current_view_base) {
	case view_gen_fnk_c_enum: {
	    view_gen_fnk_c_class& kc_current_view=static_cast<view_gen_fnk_c_class&>(kc_current_view_base);
	    if ((this->ac_base_init_list_1->prod_sel() == sel_Nilac_base_init_list)) {
		const ac_base_init head = this->ac_base_init_1;
		kc::unparse(head, kc_printer, kc_current_view);
	    } else
	    {
		const ac_base_init head = this->ac_base_init_1;
		const ac_base_init_list tail = this->ac_base_init_list_1;
		kc::unparse(tail, kc_printer, kc_current_view);
		{ kc_printer(kc_t(","), kc_current_view); }
		kc::unparse(head, kc_printer, kc_current_view);
	    }
	    break;
	}

	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    { /* Alternative( *, args ) -> [view_gen_unparsedefs_default_c: */
		for (ac_base_init_list iterator_ = this; iterator_->ac_base_init_list_1 != 0; iterator_ = iterator_->ac_base_init_list_1)
		    iterator_->ac_base_init_1->unparse(kc_printer, kc_current_view);
	    }
	    break;
	}
    }
}

void
impl_ac_base_init_list::nil_do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    { /* Alternative( *, args ) -> [view_gen_unparsedefs_default_c: */
	    }
	    break;
	}
    }
}


void
impl_ac_base_init_AcBaseInit::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case view_gen_fnk_c_enum: {
	    view_gen_fnk_c_class& kc_current_view=static_cast<view_gen_fnk_c_class&>(kc_current_view_base);
	    {
		const ID id = this->ID_1;
		const ac_constant_expression expr = this->ac_constant_expression_1;
		kc::unparse(id, kc_printer, view_gen_fn_pointer_name);
		{ kc_printer(kc_t("("), kc_current_view); }
		kc::unparse(expr, kc_printer, kc_current_view);
		{ kc_printer(kc_t(")"), kc_current_view); }
	    }
	    break;
	}

	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    { /* Alternative( *, args ) -> [view_gen_unparsedefs_default_c: */
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}

void
impl_baseclass_declarations::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    if(is_nil())
	nil_do_unparse(kc_printer, kc_current_view_base);
    else
	switch(kc_current_view_base) {

	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    { /* Alternative( *, args ) -> [view_gen_unparsedefs_default_c: */
		for (baseclass_declarations iterator_ = this; iterator_->baseclass_declarations_1 != 0; iterator_ = iterator_->baseclass_declarations_1)
		    iterator_->baseclass_decl_1->unparse(kc_printer, kc_current_view);
	    }
	    break;
	}
    }
}

void
impl_baseclass_declarations::nil_do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    { /* Alternative( *, args ) -> [view_gen_unparsedefs_default_c: */
	    }
	    break;
	}
    }
}


void
impl_baseclass_decl_BaseClassDecl::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    { /* Alternative( *, args ) -> [view_gen_unparsedefs_default_c: */
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}

void
impl_baseclass_list::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    if(is_nil())
	nil_do_unparse(kc_printer, kc_current_view_base);
    else
	switch(kc_current_view_base) {

	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    if ((this->baseclass_list_1->prod_sel() == sel_Nilbaseclass_list)) {
		const ID head = this->ID_1;
		{ kc_printer(kc_t("public "), kc_current_view); }
		kc::unparse(head, kc_printer, view_gen_fn_pointer_name);
	    } else
	    {
		const ID head = this->ID_1;
		const baseclass_list tail = this->baseclass_list_1;
		kc::unparse(tail, kc_printer, kc_current_view);
		{ kc_printer(kc_t(", public "), kc_current_view); }
		kc::unparse(head, kc_printer, view_gen_fn_pointer_name);
	    }
	    break;
	}
    }
}

void
impl_baseclass_list::nil_do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    { /* Alternative( *, args ) -> [view_gen_unparsedefs_default_c: */
	    }
	    break;
	}
    }
}


void
impl_error_Warning::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case view_error_enum: {
	    view_error_class& kc_current_view=static_cast<view_error_class&>(kc_current_view_base);
	    {
		const fileline fl = this->fileline_1;
		const problem e = this->problem_1;
		kc::unparse(g_progname, kc_printer, kc_current_view);
		{ kc_printer(kc_t(": warning"), kc_current_view); }
		kc::unparse(fl, kc_printer, kc_current_view);
		{ kc_printer(kc_t(": "), kc_current_view); }
		kc::unparse(e, kc_printer, kc_current_view);
		{ kc_printer(kc_t("\n"), kc_current_view); }
	    }
	    break;
	}
	case view_error_format_enum: {
	    view_error_format_class& kc_current_view=static_cast<view_error_format_class&>(kc_current_view_base);
	    {
		const fileline fl = this->fileline_1;
		const problem e = this->problem_1;

		kc_current_view.program(g_progname->name);
		kc_current_view.severity("warning");

		kc::unparse(fl, kc_printer, kc_current_view);
		PRINT(kc_current_view.get_msg()); 
		kc::unparse(e, kc_printer, view_error);
		{ kc_printer(kc_t("\n"), kc_current_view); }
	    }
	    break;
	}

	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    { /* Alternative( *, args ) -> [view_gen_unparsedefs_default_c: */
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


void
impl_error_NonFatal::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case view_error_enum: {
	    view_error_class& kc_current_view=static_cast<view_error_class&>(kc_current_view_base);
	    {
		const fileline fl = this->fileline_1;
		const problem e = this->problem_1;
		gp_no_fatal_problems=false; 
		kc::unparse(g_progname, kc_printer, kc_current_view);
		{ kc_printer(kc_t(": error"), kc_current_view); }
		kc::unparse(fl, kc_printer, kc_current_view);
		{ kc_printer(kc_t(": "), kc_current_view); }
		kc::unparse(e, kc_printer, kc_current_view);
		{ kc_printer(kc_t("\n"), kc_current_view); }
	    }
	    break;
	}
	case view_error_format_enum: {
	    view_error_format_class& kc_current_view=static_cast<view_error_format_class&>(kc_current_view_base);
	    {
		const fileline fl = this->fileline_1;
		const problem e = this->problem_1;
		gp_no_fatal_problems=false;
		kc_current_view.program(g_progname->name);
		kc_current_view.severity("error");

		kc::unparse(fl, kc_printer, kc_current_view);
		PRINT(kc_current_view.get_msg()); 
		kc::unparse(e, kc_printer, view_error);
		{ kc_printer(kc_t("\n"), kc_current_view); }
	    }
	    break;
	}

	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    { /* Alternative( *, args ) -> [view_gen_unparsedefs_default_c: */
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


void
impl_error_Fatal::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case view_error_enum: {
	    view_error_class& kc_current_view=static_cast<view_error_class&>(kc_current_view_base);
	    {
		const fileline fl = this->fileline_1;
		const problem e = this->problem_1;
		gp_no_fatal_problems=false; 
		kc::unparse(g_progname, kc_printer, kc_current_view);
		{ kc_printer(kc_t(": fatal error"), kc_current_view); }
		kc::unparse(fl, kc_printer, kc_current_view);
		{ kc_printer(kc_t(": "), kc_current_view); }
		kc::unparse(e, kc_printer, kc_current_view);
		{ kc_printer(kc_t("\n"), kc_current_view); }
		leave( 1 ); 
	    }
	    break;
	}
	case view_error_format_enum: {
	    view_error_format_class& kc_current_view=static_cast<view_error_format_class&>(kc_current_view_base);
	    {
		const fileline fl = this->fileline_1;
		const problem e = this->problem_1;
		gp_no_fatal_problems=false;
		kc_current_view.program(g_progname->name);
		kc_current_view.severity("fatal error");

		kc::unparse(fl, kc_printer, kc_current_view);
		PRINT(kc_current_view.get_msg()); 
		kc::unparse(e, kc_printer, view_error);
		{ kc_printer(kc_t("\n"), kc_current_view); }
		leave( 1 ); 
	    }
	    break;
	}

	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    { /* Alternative( *, args ) -> [view_gen_unparsedefs_default_c: */
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


void
impl_problem_Problem6::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case view_error_enum: {
	    view_error_class& kc_current_view=static_cast<view_error_class&>(kc_current_view_base);
	    {
		const casestring s1 = this->casestring_1;
		const casestring s2 = this->casestring_2;
		const casestring s3 = this->casestring_3;
		const casestring s4 = this->casestring_4;
		const casestring s5 = this->casestring_5;
		const casestring s6 = this->casestring_6;
		kc::unparse(s1, kc_printer, kc_current_view);
		{ kc_printer(kc_t(" "), kc_current_view); }
		kc::unparse(s2, kc_printer, kc_current_view);
		{ kc_printer(kc_t(" "), kc_current_view); }
		kc::unparse(s3, kc_printer, kc_current_view);
		{ kc_printer(kc_t(" "), kc_current_view); }
		kc::unparse(s4, kc_printer, kc_current_view);
		{ kc_printer(kc_t(" "), kc_current_view); }
		kc::unparse(s5, kc_printer, kc_current_view);
		{ kc_printer(kc_t(" "), kc_current_view); }
		kc::unparse(s6, kc_printer, kc_current_view);
	    }
	    break;
	}

	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    { /* Alternative( *, args ) -> [view_gen_unparsedefs_default_c: */
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


void
impl_problem_Problem5::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case view_error_enum: {
	    view_error_class& kc_current_view=static_cast<view_error_class&>(kc_current_view_base);
	    {
		const casestring s1 = this->casestring_1;
		const casestring s2 = this->casestring_2;
		const casestring s3 = this->casestring_3;
		const casestring s4 = this->casestring_4;
		const casestring s5 = this->casestring_5;
		kc::unparse(s1, kc_printer, kc_current_view);
		{ kc_printer(kc_t(" "), kc_current_view); }
		kc::unparse(s2, kc_printer, kc_current_view);
		{ kc_printer(kc_t(" "), kc_current_view); }
		kc::unparse(s3, kc_printer, kc_current_view);
		{ kc_printer(kc_t(" "), kc_current_view); }
		kc::unparse(s4, kc_printer, kc_current_view);
		{ kc_printer(kc_t(" "), kc_current_view); }
		kc::unparse(s5, kc_printer, kc_current_view);
	    }
	    break;
	}

	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    { /* Alternative( *, args ) -> [view_gen_unparsedefs_default_c: */
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


void
impl_problem_Problem4::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case view_error_enum: {
	    view_error_class& kc_current_view=static_cast<view_error_class&>(kc_current_view_base);
	    {
		const casestring s1 = this->casestring_1;
		const casestring s2 = this->casestring_2;
		const casestring s3 = this->casestring_3;
		const casestring s4 = this->casestring_4;
		kc::unparse(s1, kc_printer, kc_current_view);
		{ kc_printer(kc_t(" "), kc_current_view); }
		kc::unparse(s2, kc_printer, kc_current_view);
		{ kc_printer(kc_t(" "), kc_current_view); }
		kc::unparse(s3, kc_printer, kc_current_view);
		{ kc_printer(kc_t(" "), kc_current_view); }
		kc::unparse(s4, kc_printer, kc_current_view);
	    }
	    break;
	}

	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    { /* Alternative( *, args ) -> [view_gen_unparsedefs_default_c: */
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


void
impl_problem_Problem3int1::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case view_error_enum: {
	    view_error_class& kc_current_view=static_cast<view_error_class&>(kc_current_view_base);
	    {
		const casestring s1 = this->casestring_1;
		const casestring s2 = this->casestring_2;
		const casestring s3 = this->casestring_3;
		const integer i1 = this->integer_1;
		const casestring s4 = this->casestring_4;
		kc::unparse(s1, kc_printer, kc_current_view);
		{ kc_printer(kc_t(" "), kc_current_view); }
		kc::unparse(s2, kc_printer, kc_current_view);
		{ kc_printer(kc_t(" "), kc_current_view); }
		kc::unparse(s3, kc_printer, kc_current_view);
		{ kc_printer(kc_t(" "), kc_current_view); }
		kc::unparse(i1, kc_printer, kc_current_view);
		{ kc_printer(kc_t(" "), kc_current_view); }
		kc::unparse(s4, kc_printer, kc_current_view);
	    }
	    break;
	}

	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    { /* Alternative( *, args ) -> [view_gen_unparsedefs_default_c: */
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


void
impl_problem_Problem3::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case view_error_enum: {
	    view_error_class& kc_current_view=static_cast<view_error_class&>(kc_current_view_base);
	    {
		const casestring s1 = this->casestring_1;
		const casestring s2 = this->casestring_2;
		const casestring s3 = this->casestring_3;
		kc::unparse(s1, kc_printer, kc_current_view);
		{ kc_printer(kc_t(" "), kc_current_view); }
		kc::unparse(s2, kc_printer, kc_current_view);
		{ kc_printer(kc_t(" "), kc_current_view); }
		kc::unparse(s3, kc_printer, kc_current_view);
	    }
	    break;
	}

	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    { /* Alternative( *, args ) -> [view_gen_unparsedefs_default_c: */
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


void
impl_problem_Problem2::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case view_error_enum: {
	    view_error_class& kc_current_view=static_cast<view_error_class&>(kc_current_view_base);
	    {
		const casestring s1 = this->casestring_1;
		const casestring s2 = this->casestring_2;
		kc::unparse(s1, kc_printer, kc_current_view);
		{ kc_printer(kc_t(" "), kc_current_view); }
		kc::unparse(s2, kc_printer, kc_current_view);
	    }
	    break;
	}

	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    { /* Alternative( *, args ) -> [view_gen_unparsedefs_default_c: */
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


void
impl_problem_Problem1storageoption1ID::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case view_error_enum: {
	    view_error_class& kc_current_view=static_cast<view_error_class&>(kc_current_view_base);
	    {
		const casestring s1 = this->casestring_1;
		const storageoption so = this->storageoption_1;
		const casestring s2 = this->casestring_2;
		const ID id = this->ID_1;
		kc::unparse(s1, kc_printer, kc_current_view);
		{ kc_printer(kc_t(" "), kc_current_view); }
		kc::unparse(so, kc_printer, kc_current_view);
		{ kc_printer(kc_t(" "), kc_current_view); }
		kc::unparse(s2, kc_printer, kc_current_view);
		{ kc_printer(kc_t(" "), kc_current_view); }
		kc::unparse(id, kc_printer, kc_current_view);
	    }
	    break;
	}

	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    { /* Alternative( *, args ) -> [view_gen_unparsedefs_default_c: */
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


void
impl_problem_Problem1INT1ID1ID::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case view_error_enum: {
	    view_error_class& kc_current_view=static_cast<view_error_class&>(kc_current_view_base);
	    {
		const casestring s1 = this->casestring_1;
		const INT i1 = this->INT_1;
		const casestring s2 = this->casestring_2;
		const ID id1 = this->ID_1;
		const casestring s3 = this->casestring_3;
		const ID id2 = this->ID_2;
		kc::unparse(s1, kc_printer, kc_current_view);
		{ kc_printer(kc_t(" "), kc_current_view); }
		kc::unparse(i1, kc_printer, kc_current_view);
		{ kc_printer(kc_t(" "), kc_current_view); }
		kc::unparse(s2, kc_printer, kc_current_view);
		{ kc_printer(kc_t(" "), kc_current_view); }
		kc::unparse(id1, kc_printer, kc_current_view);
		{ kc_printer(kc_t(" "), kc_current_view); }
		kc::unparse(s3, kc_printer, kc_current_view);
		{ kc_printer(kc_t(" "), kc_current_view); }
		kc::unparse(id2, kc_printer, kc_current_view);
	    }
	    break;
	}

	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    { /* Alternative( *, args ) -> [view_gen_unparsedefs_default_c: */
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


void
impl_problem_Problem1ID1ID1ID::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case view_error_enum: {
	    view_error_class& kc_current_view=static_cast<view_error_class&>(kc_current_view_base);
	    {
		const casestring s1 = this->casestring_1;
		const ID id1 = this->ID_1;
		const casestring s2 = this->casestring_2;
		const ID id2 = this->ID_2;
		const casestring s3 = this->casestring_3;
		const ID id3 = this->ID_3;
		kc::unparse(s1, kc_printer, kc_current_view);
		{ kc_printer(kc_t(" "), kc_current_view); }
		kc::unparse(id1, kc_printer, kc_current_view);
		{ kc_printer(kc_t(" "), kc_current_view); }
		kc::unparse(s2, kc_printer, kc_current_view);
		{ kc_printer(kc_t(" "), kc_current_view); }
		kc::unparse(id2, kc_printer, kc_current_view);
		{ kc_printer(kc_t(" "), kc_current_view); }
		kc::unparse(s3, kc_printer, kc_current_view);
		{ kc_printer(kc_t(" "), kc_current_view); }
		kc::unparse(id3, kc_printer, kc_current_view);
	    }
	    break;
	}

	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    { /* Alternative( *, args ) -> [view_gen_unparsedefs_default_c: */
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


void
impl_problem_Problem1INT1ID::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case view_error_enum: {
	    view_error_class& kc_current_view=static_cast<view_error_class&>(kc_current_view_base);
	    {
		const casestring s1 = this->casestring_1;
		const INT i1 = this->INT_1;
		const casestring s2 = this->casestring_2;
		const ID id1 = this->ID_1;
		kc::unparse(s1, kc_printer, kc_current_view);
		{ kc_printer(kc_t(" "), kc_current_view); }
		kc::unparse(i1, kc_printer, kc_current_view);
		{ kc_printer(kc_t(" "), kc_current_view); }
		kc::unparse(s2, kc_printer, kc_current_view);
		{ kc_printer(kc_t(" "), kc_current_view); }
		kc::unparse(id1, kc_printer, kc_current_view);
	    }
	    break;
	}

	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    { /* Alternative( *, args ) -> [view_gen_unparsedefs_default_c: */
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


void
impl_problem_Problem1int1::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case view_error_enum: {
	    view_error_class& kc_current_view=static_cast<view_error_class&>(kc_current_view_base);
	    {
		const casestring s1 = this->casestring_1;
		const integer i1 = this->integer_1;
		const casestring s2 = this->casestring_2;
		kc::unparse(s1, kc_printer, kc_current_view);
		{ kc_printer(kc_t(" "), kc_current_view); }
		kc::unparse(i1, kc_printer, kc_current_view);
		{ kc_printer(kc_t(" "), kc_current_view); }
		kc::unparse(s2, kc_printer, kc_current_view);
	    }
	    break;
	}

	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    { /* Alternative( *, args ) -> [view_gen_unparsedefs_default_c: */
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


void
impl_problem_Problem1INT::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case view_error_enum: {
	    view_error_class& kc_current_view=static_cast<view_error_class&>(kc_current_view_base);
	    {
		const casestring s1 = this->casestring_1;
		const INT i1 = this->INT_1;
		kc::unparse(s1, kc_printer, kc_current_view);
		{ kc_printer(kc_t(" "), kc_current_view); }
		kc::unparse(i1, kc_printer, kc_current_view);
	    }
	    break;
	}

	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    { /* Alternative( *, args ) -> [view_gen_unparsedefs_default_c: */
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


void
impl_problem_Problem1t1ID::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case view_error_enum: {
	    view_error_class& kc_current_view=static_cast<view_error_class&>(kc_current_view_base);
	    {
		const casestring s1 = this->casestring_1;
		const IDtype t = this->IDtype_1;
		const casestring s2 = this->casestring_2;
		const ID id = this->ID_1;
		kc::unparse(s1, kc_printer, kc_current_view);
		{ kc_printer(kc_t(" "), kc_current_view); }
		kc::unparse(t, kc_printer, kc_current_view);
		{ kc_printer(kc_t(" "), kc_current_view); }
		kc::unparse(s2, kc_printer, kc_current_view);
		{ kc_printer(kc_t(" "), kc_current_view); }
		kc::unparse(id, kc_printer, kc_current_view);
	    }
	    break;
	}

	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    { /* Alternative( *, args ) -> [view_gen_unparsedefs_default_c: */
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


void
impl_problem_Problem1ID1ID::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case view_error_enum: {
	    view_error_class& kc_current_view=static_cast<view_error_class&>(kc_current_view_base);
	    {
		const casestring s1 = this->casestring_1;
		const ID id1 = this->ID_1;
		const casestring s2 = this->casestring_2;
		const ID id2 = this->ID_2;
		kc::unparse(s1, kc_printer, kc_current_view);
		{ kc_printer(kc_t(" "), kc_current_view); }
		kc::unparse(id1, kc_printer, kc_current_view);
		{ kc_printer(kc_t(" "), kc_current_view); }
		kc::unparse(s2, kc_printer, kc_current_view);
		{ kc_printer(kc_t(" "), kc_current_view); }
		kc::unparse(id2, kc_printer, kc_current_view);
	    }
	    break;
	}

	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    { /* Alternative( *, args ) -> [view_gen_unparsedefs_default_c: */
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


void
impl_problem_Problem1we::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case view_error_enum: {
	    view_error_class& kc_current_view=static_cast<view_error_class&>(kc_current_view_base);
	    {
		const casestring s1 = this->casestring_1;
		const withexpression we1 = this->withexpression_1;
		kc::unparse(s1, kc_printer, kc_current_view);
		{ kc_printer(kc_t(" "), kc_current_view); }
		kc::unparse(we1, kc_printer, kc_current_view);
	    }
	    break;
	}

	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    { /* Alternative( *, args ) -> [view_gen_unparsedefs_default_c: */
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


void
impl_problem_Problem1tID::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case view_error_enum: {
	    view_error_class& kc_current_view=static_cast<view_error_class&>(kc_current_view_base);
	    {
		const casestring s1 = this->casestring_1;
		const ID id = this->ID_1;
		kc::unparse(s1, kc_printer, kc_current_view);
		{ kc_printer(kc_t(" "), kc_current_view); }
		kc::unparse(id, kc_printer, view_error_tID);
	    }
	    break;
	}

	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    { /* Alternative( *, args ) -> [view_gen_unparsedefs_default_c: */
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


void
impl_problem_Problem1ID::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case view_error_enum: {
	    view_error_class& kc_current_view=static_cast<view_error_class&>(kc_current_view_base);
	    {
		const casestring s1 = this->casestring_1;
		const ID id = this->ID_1;
		kc::unparse(s1, kc_printer, kc_current_view);
		{ kc_printer(kc_t(" "), kc_current_view); }
		kc::unparse(id, kc_printer, kc_current_view);
	    }
	    break;
	}

	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    { /* Alternative( *, args ) -> [view_gen_unparsedefs_default_c: */
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


void
impl_problem_Problem1::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case view_error_enum: {
	    view_error_class& kc_current_view=static_cast<view_error_class&>(kc_current_view_base);
	    {
		const casestring s1 = this->casestring_1;
		kc::unparse(s1, kc_printer, kc_current_view);
	    }
	    break;
	}

	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    { /* Alternative( *, args ) -> [view_gen_unparsedefs_default_c: */
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}

void
impl_addedphylumdeclarations::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    if(is_nil())
	nil_do_unparse(kc_printer, kc_current_view_base);
    else
	switch(kc_current_view_base) {

	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    { /* Alternative( *, args ) -> [view_gen_unparsedefs_default_c: */
		for (addedphylumdeclarations iterator_ = this; iterator_->addedphylumdeclarations_1 != 0; iterator_ = iterator_->addedphylumdeclarations_1)
		    iterator_->addedphylumdeclaration_1->unparse(kc_printer, kc_current_view);
	    }
	    break;
	}
    }
}

void
impl_addedphylumdeclarations::nil_do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    { /* Alternative( *, args ) -> [view_gen_unparsedefs_default_c: */
	    }
	    break;
	}
    }
}


void
impl_addedphylumdeclaration_AddedPhylumdeclaration::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    { /* Alternative( *, args ) -> [view_gen_unparsedefs_default_c: */
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}

void
impl_countedphylumdeclarations::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    if(is_nil())
	nil_do_unparse(kc_printer, kc_current_view_base);
    else
	switch(kc_current_view_base) {

	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    { /* Alternative( *, args ) -> [view_gen_unparsedefs_default_c: */
		for (countedphylumdeclarations iterator_ = this; iterator_->countedphylumdeclarations_1 != 0; iterator_ = iterator_->countedphylumdeclarations_1)
		    iterator_->countedphylumdeclaration_1->unparse(kc_printer, kc_current_view);
	    }
	    break;
	}
    }
}

void
impl_countedphylumdeclarations::nil_do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    { /* Alternative( *, args ) -> [view_gen_unparsedefs_default_c: */
	    }
	    break;
	}
    }
}


void
impl_countedphylumdeclaration_CountedPhylumdeclaration::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    { /* Alternative( *, args ) -> [view_gen_unparsedefs_default_c: */
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


void
impl_charruns_Stars::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    if ((KC_TRACE_PROVIDED((this->number>0), "gutil.k", 369, this))) {
		{ kc_printer(kc_t("*"), kc_current_view); }
		this->number--; 
		kc::unparse(this, kc_printer, kc_current_view);
	    } else
	    { /* Alternative( *, args ) -> [view_gen_unparsedefs_default_c: */
	    }
	    break;
	}
    }
}


void
impl_charruns_QuotedNewlines::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    if ((KC_TRACE_PROVIDED((this->number>0), "gutil.k", 368, this))) {
		{ kc_printer(kc_t("\\\n\\n"), kc_current_view); }
		this->number--; 
		kc::unparse(this, kc_printer, kc_current_view);
	    } else
	    { /* Alternative( *, args ) -> [view_gen_unparsedefs_default_c: */
	    }
	    break;
	}
    }
}


void
impl_charruns_Newlines::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    if ((KC_TRACE_PROVIDED((this->number>0), "gutil.k", 367, this))) {
		{ kc_printer(kc_t("\n"), kc_current_view); }
		this->number--; 
		kc::unparse(this, kc_printer, kc_current_view);
	    } else
	    { /* Alternative( *, args ) -> [view_gen_unparsedefs_default_c: */
	    }
	    break;
	}
    }
}

void
impl_bindingidmarks::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    if(is_nil())
	nil_do_unparse(kc_printer, kc_current_view_base);
    else
	switch(kc_current_view_base) {

	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    { /* Alternative( *, args ) -> [view_gen_unparsedefs_default_c: */
		for (bindingidmarks iterator_ = this; iterator_->bindingidmarks_1 != 0; iterator_ = iterator_->bindingidmarks_1)
		    iterator_->bindingidmark_1->unparse(kc_printer, kc_current_view);
	    }
	    break;
	}
    }
}

void
impl_bindingidmarks::nil_do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    { /* Alternative( *, args ) -> [view_gen_unparsedefs_default_c: */
	    }
	    break;
	}
    }
}


void
impl_bindingidmark_BindingIdMark::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    { /* Alternative( *, args ) -> [view_gen_unparsedefs_default_c: */
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


} // namespace kc
