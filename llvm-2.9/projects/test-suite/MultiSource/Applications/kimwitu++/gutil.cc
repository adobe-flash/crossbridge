/* translation of file "gutil.k" */
/* generated by:
 *  @(#)$Author: criswell $
 */
#define KC_FUNCTIONS_gutil_

#include <stdlib.h>
#include "k.h"
#include "gutil.h"
namespace kc { }
using namespace kc;
/* included stuff */
//
// The Termprocessor Kimwitu++
//
// Copyright (C) 1991 University of Twente, Dept TIOS.
// Copyright (C) 1998-2003 Humboldt-University of Berlin, Institute of Informatics
// All rights reserved.
//
// Kimwitu++ is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation; either version 2 of the License, or
// (at your option) any later version.
//
// Kimwitu++ is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with Kimwitu++; if not, write to the Free Software
// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
//

static char gutil_kAccesSid[] = "@(#)$Id: gutil.cc 12720 2004-04-06 20:25:22Z criswell $";

/* string(s) stuff */
#include <string.h>
#include <ctype.h>

phylumdeclaration The_abstract_phylum_decl;
phylumdeclaration The_abstract_phylum_ref_decl;
phylumdeclaration The_abstract_list_decl;

#include "util.h"

#include "parse.h"

#include "unpk.h"

#define MKSELVARMAXINTREPR 30

#include <ctype.h>

static ID global_filterview; /* to be used by filteronview */

#include "rk.h"		/* for the rewrite_withcasesinfo call below */

/* end included stuff */


namespace kc {

#ifndef KC_TRACE_PROVIDED
#define KC_TRACE_PROVIDED(COND,FILE,LINE,NODE) COND
#endif

static  bool f_attributes_to_initialize (attributes attr);
static  bool f_constructors_in_members (fndeclarations dcl);
static  bool f_destructors_in_members (fndeclarations dcl);
static  bool f_post_create_in_members (fndeclarations dcl);
static  bool f_rewrite_in_members (fndeclarations dcl);
static  ac_parameter_declaration lookup_and_create_ac_parameter_declaration (ID a_fnarg, ac_declaration_list C_vardecls);
static  bool filterrewriteruleinfoonview (rewriteruleinfo a_rewriteruleinfo);
static  bool filterunparsedeclinfoonview (unparsedeclinfo a_unparsedeclinfo);
static  bool is_viewname_in_rewriteruleinfo (ID a_view, rewriteruleinfo a_rewriteruleinfo);
static  bool is_viewname_in_unparsedeclinfo (ID a_view, unparsedeclinfo a_unparsedeclinfo);
static  bool is_viewname_in_viewnames (ID a_view, viewnames a_viewnames);
static  ID f_operatorofelem_patternrepresentation (elem_patternrepresentation a_elem_patternrepresentation);
static  ID f_operatorofpaths (paths a_paths);
static  ID f_operatorofpath (path a_path);
static  elem_patternrepresentation f_outmost_nl_preds_in_patternrepresentation (patternrepresentation p);
static  bool f_outmost_nl_preds_in_elem_patternrepresentation (elem_patternrepresentation e_p);
static  bool f_outmost_nl_preds_in_paths (paths p);
bool f_something_to_initialize(Ccode_option cco)
{
    {
	Ccode_option kc_selvar_0_1 = phylum_cast<Ccode_option>( cco );
	if ((kc_selvar_0_1->prod_sel() == sel_CcodeOption)) {
	    const attributes attr = phylum_cast<const impl_Ccode_option_CcodeOption*>(kc_selvar_0_1)->attributes_1;
	    const Ctexts ct = phylum_cast<const impl_Ccode_option_CcodeOption*>(kc_selvar_0_1)->Ctexts_1;

	    return (f_attributes_to_initialize( attr ) || (! f_NilCtexts( ct )));

	} else
	{ kc_no_default_in_with( "f_something_to_initialize", __LINE__, __FILE__ );
	    return static_cast<bool>(0); }
    }

}

bool f_something_to_initialize(alternative a)
{
    return false;

}

bool f_NilCtexts(Ctexts c)
{
    {
	Ctexts kc_selvar_0_1 = phylum_cast<Ctexts>( c );
	if ((kc_selvar_0_1->prod_sel() == sel_ConsCtexts)) {
	    return false; 
	    	} else
	    if ((kc_selvar_0_1->prod_sel() == sel_NilCtexts)) {
	    return true; 
	    	} else
	{ kc_no_default_in_with( "f_NilCtexts", __LINE__, __FILE__ );
	    return static_cast<bool>(0); }
    }

}

static  bool f_attributes_to_initialize(attributes attr)
{
    {
	attributes kc_fe_selvar_1 =  attr ;

	while(
		kc_fe_selvar_1->prod_sel() == sel_Consattributes
	    ) {
	    attribute kc_selvar_0_1 = kc_fe_selvar_1->attribute_1;
	    {
		{
		    {
			const attribute a = kc_selvar_0_1;

			{
			    attribute kc_selvar_1_1 = phylum_cast<attribute>( a );
			    if ((kc_selvar_1_1->prod_sel() == sel_Attribute) && (phylum_cast<const impl_attribute_Attribute*>(kc_selvar_1_1)->attribute_initialisation_option_1->prod_sel() == sel_Yesattribute_initialisation)) {

				return true;

			    } else
				if ((kc_selvar_1_1->prod_sel() == sel_Attribute) && (phylum_cast<const impl_attribute_Attribute*>(kc_selvar_1_1)->attribute_initialisation_option_1->prod_sel() == sel_Noattribute_initialisation)) {
				/*EMPTY*/
					} else
			    { kc_no_default_in_with( "f_attributes_to_initialize", __LINE__, __FILE__ );
				return static_cast<bool>(0); }
			}

		    }
		}

	    }
	    kc_fe_selvar_1 = kc_fe_selvar_1->attributes_1;

	}
    }
    return false;

}

static  bool f_constructors_in_members(fndeclarations dcl)
{{
	fndeclarations kc_selvar_0_1 = phylum_cast<fndeclarations>(dcl);
	if ((kc_selvar_0_1->prod_sel() == sel_Consfndeclarations) && ((kc_selvar_0_1)->fndeclaration_1->prod_sel() == sel_FnAcDeclaration) && (phylum_cast<const impl_fndeclaration_FnAcDeclaration*>((kc_selvar_0_1)->fndeclaration_1)->fnclass_1->prod_sel() == sel_ConstructorFn)) {
	    return true; 
	    	} else
	    if ((kc_selvar_0_1->prod_sel() == sel_Consfndeclarations)) {
	    const fndeclarations tail = (kc_selvar_0_1)->fndeclarations_1;
	    return f_constructors_in_members(tail); 
	    	} else
	{
	    return false; 
	}
    }

}

bool f_constructors_in_operatordecl(alternative op)
{
    return f_constructors_in_members(op->additional_members);

}

bool f_constructors_in_phylumdecl(phylumdeclaration ph)
{
    return f_constructors_in_members(ph->additional_members);

}

static  bool f_destructors_in_members(fndeclarations dcl)
{{
	fndeclarations kc_selvar_0_1 = phylum_cast<fndeclarations>(dcl);
	if ((kc_selvar_0_1->prod_sel() == sel_Consfndeclarations) && ((kc_selvar_0_1)->fndeclaration_1->prod_sel() == sel_FnAcDeclaration) && (phylum_cast<const impl_fndeclaration_FnAcDeclaration*>((kc_selvar_0_1)->fndeclaration_1)->fnclass_1->prod_sel() == sel_DestructorFn)) {
	    return true; 
	    	} else
	    if ((kc_selvar_0_1->prod_sel() == sel_Consfndeclarations)) {
	    const fndeclarations tail = (kc_selvar_0_1)->fndeclarations_1;
	    return f_destructors_in_members(tail); 
	    	} else
	{
	    return false; 
	}
    }

}

bool f_destructors_in_operatordecl(alternative op)
{
    return f_destructors_in_members(op->additional_members);

}

bool f_destructors_in_phylumdecl(phylumdeclaration ph)
{
    return f_destructors_in_members(ph->additional_members);

}

bool f_no_params(ac_parameter_type_list p)
{{
	ac_parameter_type_list kc_selvar_0_1 = phylum_cast<ac_parameter_type_list>(p);
	if ((kc_selvar_0_1->prod_sel() == sel_AcParList) && (phylum_cast<const impl_ac_parameter_type_list_AcParList*>(kc_selvar_0_1)->ac_parameter_list_1->prod_sel() == sel_Nilac_parameter_list)) {
	    return true; 
	    	} else
	{
	    return false; 
	}
    }

}

static  bool f_post_create_in_members(fndeclarations dcl)
{{
	fndeclarations kc_selvar_0_1 = phylum_cast<fndeclarations>(dcl);
	if ((kc_selvar_0_1->prod_sel() == sel_Consfndeclarations) && ((kc_selvar_0_1)->fndeclaration_1->prod_sel() == sel_FnAcDeclaration) && (phylum_cast<const impl_fndeclaration_FnAcDeclaration*>((kc_selvar_0_1)->fndeclaration_1)->ac_declarator_1->prod_sel() == sel_AcDeclarator) && (phylum_cast<const impl_ac_declarator_AcDeclarator*>(phylum_cast<const impl_fndeclaration_FnAcDeclaration*>((kc_selvar_0_1)->fndeclaration_1)->ac_declarator_1)->ac_direct_declarator_1->prod_sel() == sel_AcQualifiedDeclProto) && (phylum_cast<const impl_ac_direct_declarator_AcQualifiedDeclProto*>(phylum_cast<const impl_ac_declarator_AcDeclarator*>(phylum_cast<const impl_fndeclaration_FnAcDeclaration*>((kc_selvar_0_1)->fndeclaration_1)->ac_declarator_1)->ac_direct_declarator_1)->ac_direct_declarator_1->prod_sel() == sel_AcDirectDeclId) && (phylum_cast<const impl_ac_direct_declarator_AcDirectDeclId*>(phylum_cast<const impl_ac_direct_declarator_AcQualifiedDeclProto*>(phylum_cast<const impl_ac_declarator_AcDeclarator*>(phylum_cast<const impl_fndeclaration_FnAcDeclaration*>((kc_selvar_0_1)->fndeclaration_1)->ac_declarator_1)->ac_direct_declarator_1)->ac_direct_declarator_1)->ID_1->prod_sel() == sel_Id) && (phylum_cast<const impl_ID_Id*>(phylum_cast<const impl_ac_direct_declarator_AcDirectDeclId*>(phylum_cast<const impl_ac_direct_declarator_AcQualifiedDeclProto*>(phylum_cast<const impl_ac_declarator_AcDeclarator*>(phylum_cast<const impl_fndeclaration_FnAcDeclaration*>((kc_selvar_0_1)->fndeclaration_1)->ac_declarator_1)->ac_direct_declarator_1)->ac_direct_declarator_1)->ID_1)->uniqID_1->prod_sel() == sel_Str) && (kc_strcmp(phylum_cast<const impl_uniqID_Str*>(phylum_cast<const impl_ID_Id*>(phylum_cast<const impl_ac_direct_declarator_AcDirectDeclId*>(phylum_cast<const impl_ac_direct_declarator_AcQualifiedDeclProto*>(phylum_cast<const impl_ac_declarator_AcDeclarator*>(phylum_cast<const impl_fndeclaration_FnAcDeclaration*>((kc_selvar_0_1)->fndeclaration_1)->ac_declarator_1)->ac_direct_declarator_1)->ac_direct_declarator_1)->ID_1)->uniqID_1)->casestring_1->name, kc_t("post_create"))==0) && (phylum_cast<const impl_fndeclaration_FnAcDeclaration*>((kc_selvar_0_1)->fndeclaration_1)->fnclass_1->prod_sel() == sel_MemberFn)) {
	    return true; 
	    	} else
	    if ((kc_selvar_0_1->prod_sel() == sel_Consfndeclarations)) {
	    const fndeclarations tail = (kc_selvar_0_1)->fndeclarations_1;
	    return f_post_create_in_members(tail); 
	    	} else
	{
	    return false; 
	}
    }

}

bool f_post_create_in_operatordecl(alternative op)
{
    return f_post_create_in_members(op->additional_members);

}

bool f_post_create_in_phylumdecl(phylumdeclaration ph)
{
    return f_post_create_in_members(ph->additional_members);

}

static  bool f_rewrite_in_members(fndeclarations dcl)
{{
	fndeclarations kc_selvar_0_1 = phylum_cast<fndeclarations>(dcl);
	if ((kc_selvar_0_1->prod_sel() == sel_Consfndeclarations) && ((kc_selvar_0_1)->fndeclaration_1->prod_sel() == sel_FnAcDeclaration) && (phylum_cast<const impl_fndeclaration_FnAcDeclaration*>((kc_selvar_0_1)->fndeclaration_1)->ac_declarator_1->prod_sel() == sel_AcDeclarator) && (phylum_cast<const impl_ac_declarator_AcDeclarator*>(phylum_cast<const impl_fndeclaration_FnAcDeclaration*>((kc_selvar_0_1)->fndeclaration_1)->ac_declarator_1)->ac_direct_declarator_1->prod_sel() == sel_AcQualifiedDeclProto) && (phylum_cast<const impl_ac_direct_declarator_AcQualifiedDeclProto*>(phylum_cast<const impl_ac_declarator_AcDeclarator*>(phylum_cast<const impl_fndeclaration_FnAcDeclaration*>((kc_selvar_0_1)->fndeclaration_1)->ac_declarator_1)->ac_direct_declarator_1)->ac_direct_declarator_1->prod_sel() == sel_AcDirectDeclId) && (phylum_cast<const impl_ac_direct_declarator_AcDirectDeclId*>(phylum_cast<const impl_ac_direct_declarator_AcQualifiedDeclProto*>(phylum_cast<const impl_ac_declarator_AcDeclarator*>(phylum_cast<const impl_fndeclaration_FnAcDeclaration*>((kc_selvar_0_1)->fndeclaration_1)->ac_declarator_1)->ac_direct_declarator_1)->ac_direct_declarator_1)->ID_1->prod_sel() == sel_Id) && (phylum_cast<const impl_ID_Id*>(phylum_cast<const impl_ac_direct_declarator_AcDirectDeclId*>(phylum_cast<const impl_ac_direct_declarator_AcQualifiedDeclProto*>(phylum_cast<const impl_ac_declarator_AcDeclarator*>(phylum_cast<const impl_fndeclaration_FnAcDeclaration*>((kc_selvar_0_1)->fndeclaration_1)->ac_declarator_1)->ac_direct_declarator_1)->ac_direct_declarator_1)->ID_1)->uniqID_1->prod_sel() == sel_Str) && (kc_strcmp(phylum_cast<const impl_uniqID_Str*>(phylum_cast<const impl_ID_Id*>(phylum_cast<const impl_ac_direct_declarator_AcDirectDeclId*>(phylum_cast<const impl_ac_direct_declarator_AcQualifiedDeclProto*>(phylum_cast<const impl_ac_declarator_AcDeclarator*>(phylum_cast<const impl_fndeclaration_FnAcDeclaration*>((kc_selvar_0_1)->fndeclaration_1)->ac_declarator_1)->ac_direct_declarator_1)->ac_direct_declarator_1)->ID_1)->uniqID_1)->casestring_1->name, kc_t("rewrite"))==0) && (phylum_cast<const impl_fndeclaration_FnAcDeclaration*>((kc_selvar_0_1)->fndeclaration_1)->fnclass_1->prod_sel() == sel_MemberFn)) {
	    return true; 
	    	} else
	    if ((kc_selvar_0_1->prod_sel() == sel_Consfndeclarations)) {
	    const fndeclarations tail = (kc_selvar_0_1)->fndeclarations_1;
	    return f_rewrite_in_members(tail); 
	    	} else
	{
	    return false; 
	}
    }

}

bool f_rewrite_in_phylumdecl(phylumdeclaration ph)
{
    return f_rewrite_in_members(ph->additional_members);

}

bool f_rewrite_in_operatordecl(alternative op)
{{
	alternative kc_selvar_0_1 = phylum_cast<alternative>(op);
	if ((kc_selvar_0_1->prod_sel() == sel_Alternative)) {
	    const ID oid = phylum_cast<const impl_alternative_Alternative*>(kc_selvar_0_1)->ID_1;

	    if(f_rewrite_in_members(op->additional_members))
	    return true;
	    return f_rewrite_in_phylumdecl(f_phylumdeclofid(f_phylumofoperator(oid)));

	} else
	{
	    return false; 
	}
    }

}

ID f_phylumofwithcasesinfo(withcasesinfo wcso)
{
    ID id;
    {
	withcasesinfo kc_selvar_0_1 = phylum_cast<withcasesinfo>( wcso );
	if ((kc_selvar_0_1->prod_sel() == sel_Conswithcasesinfo)) {
	    const withcaseinfo wco = (kc_selvar_0_1)->withcaseinfo_1;
	    const withcasesinfo r_wcso = (kc_selvar_0_1)->withcasesinfo_1;

	    {
		withcaseinfo kc_selvar_1_1 = phylum_cast<withcaseinfo>( wco );
		if ((kc_selvar_1_1->prod_sel() == sel_Withcaseinfo)) {
		    const patternrepresentation patrep = phylum_cast<const impl_withcaseinfo_Withcaseinfo*>(kc_selvar_1_1)->patternrepresentation_1;

		    if ( (id = f_phylumofpatternrepresentation( patrep ))->eq( f_emptyId() )) {
			return f_phylumofwithcasesinfo( r_wcso );
		    } else {
			return id;
		    }   
		    	} else
		{ kc_no_default_in_with( "f_phylumofwithcasesinfo", __LINE__, __FILE__ );
		    return static_cast<ID>(0); }
	    }

	} else
	    if ((kc_selvar_0_1->prod_sel() == sel_Nilwithcasesinfo)) {

	    v_report(NonFatal( NoFileLine(), Problem1S( "Error: can not find type of with expression" )));
	    return Id( Str( mkcasestring( "KC_ERRORunknownTYPE" )));

	} else
	{ kc_no_default_in_with( "f_phylumofwithcasesinfo", __LINE__, __FILE__ );
	    return static_cast<ID>(0); }
    }

}

ID f_phylumofpatternrepresentation(patternrepresentation a_patrep)
{
    {
	patternrepresentation kc_selvar_0_1 = phylum_cast<patternrepresentation>( a_patrep );
	if ((kc_selvar_0_1->prod_sel() == sel_Conspatternrepresentation)) {
	    const elem_patternrepresentation a_patrep_elem = (kc_selvar_0_1)->elem_patternrepresentation_1;
	    const patternrepresentation r_patrep = (kc_selvar_0_1)->patternrepresentation_1;

	    {
		elem_patternrepresentation kc_selvar_1_1 = phylum_cast<elem_patternrepresentation>( a_patrep_elem );
		if ((kc_selvar_1_1->prod_sel() == sel_PROperPredicate)) {
		    const ID id = phylum_cast<const impl_elem_patternrepresentation_PROperPredicate*>(kc_selvar_1_1)->ID_1;

		    return f_phylumofoperator( id );

		} else
		{

		    return f_phylumofpatternrepresentation( r_patrep );

		}
	    }

	} else
	    if ((kc_selvar_0_1->prod_sel() == sel_Nilpatternrepresentation)) {

	    return f_emptyId();

	} else
	{ kc_no_default_in_with( "f_phylumofpatternrepresentation", __LINE__, __FILE__ );
	    return static_cast<ID>(0); }
    }

}

ac_parameter_type_list sort_extend_parameter_type_list(ac_declaration_list C_vardecls, ac_declarator decl)
{{
	ac_declarator kc_selvar_0_1 = phylum_cast<ac_declarator>(decl);
	if ((kc_selvar_0_1->prod_sel() == sel_AcDeclarator)) {
	    const ac_direct_declarator add = phylum_cast<const impl_ac_declarator_AcDeclarator*>(kc_selvar_0_1)->ac_direct_declarator_1;

	    {
		ac_direct_declarator kc_selvar_1_1 = phylum_cast<ac_direct_declarator>( add );
		if ((kc_selvar_1_1->prod_sel() == sel_AcQualifiedDeclProto)) {
		    const ac_parameter_type_list fn_proto = phylum_cast<const impl_ac_direct_declarator_AcQualifiedDeclProto*>(kc_selvar_1_1)->ac_parameter_type_list_1;
		    return fn_proto; 
		    	} else
		    if ((kc_selvar_1_1->prod_sel() == sel_AcDirectDeclProto)) {
		    const ac_parameter_type_list fn_proto = phylum_cast<const impl_ac_direct_declarator_AcDirectDeclProto*>(kc_selvar_1_1)->ac_parameter_type_list_1;
		    return fn_proto; 
		    	} else
		    if ((kc_selvar_1_1->prod_sel() == sel_AcDirectDeclArray)) {
		    return AcParList( Nilac_parameter_list() ); 
		    	} else
		    if ((kc_selvar_1_1->prod_sel() == sel_AcDirectDeclPack)) {
		    return AcParList( Nilac_parameter_list() ); 
		    	} else
		    if ((kc_selvar_1_1->prod_sel() == sel_AcDirectDeclId)) {
		    return AcParList( Nilac_parameter_list() ); 
		    	} else
		{ kc_no_default_in_with( "sort_extend_parameter_type_list", __LINE__, __FILE__ );
		    return static_cast<ac_parameter_type_list>(0); }
	    }

	} else
	{ kc_no_default_in_with( "sort_extend_parameter_type_list", __LINE__, __FILE__ );
	    return static_cast<ac_parameter_type_list>(0); }
    }

}

ac_parameter_list t_sort_extend_parameter_list(ac_declaration_list C_vardecls, ac_identifier_list fn_args, ac_parameter_list temp)
{
    {
	ac_identifier_list kc_selvar_0_1 = phylum_cast<ac_identifier_list>( fn_args );
	if ((kc_selvar_0_1->prod_sel() == sel_Consac_identifier_list)) {
	    const ID a_fnarg = (kc_selvar_0_1)->ID_1;
	    const ac_identifier_list r_fnargs = (kc_selvar_0_1)->ac_identifier_list_1;

	    temp =  t_sort_extend_parameter_list( C_vardecls, r_fnargs, temp );
	    return Consac_parameter_list( lookup_and_create_ac_parameter_declaration( a_fnarg, C_vardecls ), temp );

	} else
	    if ((kc_selvar_0_1->prod_sel() == sel_Nilac_identifier_list)) {
	    return temp; 
	    	} else
	{ kc_no_default_in_with( "t_sort_extend_parameter_list", __LINE__, __FILE__ );
	    return static_cast<ac_parameter_list>(0); }
    }

}

static  ac_parameter_declaration lookup_and_create_ac_parameter_declaration(ID a_fnarg, ac_declaration_list C_vardecls)
{
    ac_parameter_declaration result = 0;
    int number_of_results = 0;
    {
	ac_declaration_list kc_fe_selvar_1 =  C_vardecls ;

	while(
		kc_fe_selvar_1->prod_sel() == sel_Consac_declaration_list
	    ) {
	    ac_declaration kc_selvar_0_1 = kc_fe_selvar_1->ac_declaration_1;
	    {
		{
		    if ((kc_selvar_0_1->prod_sel() == sel_AcDeclaration)) {
			const ac_declaration_specifiers type = phylum_cast<const impl_ac_declaration_AcDeclaration*>(kc_selvar_0_1)->ac_declaration_specifiers_1;
			const ac_init_declarator_list cvars = phylum_cast<const impl_ac_declaration_AcDeclaration*>(kc_selvar_0_1)->ac_init_declarator_list_1;

			{
			    ac_init_declarator_list kc_fe_selvar_1 =  cvars ;

			    while(
				    kc_fe_selvar_1->prod_sel() == sel_Consac_init_declarator_list
				) {
				ac_init_declarator kc_selvar_1_1 = kc_fe_selvar_1->ac_init_declarator_1;
				{
				    {
					if ((kc_selvar_1_1->prod_sel() == sel_AcInitDecl)) {
					    const ac_declarator decl = phylum_cast<const impl_ac_init_declarator_AcInitDecl*>(kc_selvar_1_1)->ac_declarator_1;

					    ID name = f_ID_of_declarator( decl );
					    if (name->eq( a_fnarg ) ) {
						result = AcParDeclDecl( type, decl, Noac_constant_expression());
						number_of_results++;
					    }   
					    	} else
					{/* EMPTY */ /*skip: no matching pattern in foreach patterns*/}
				    }

				}
				kc_fe_selvar_1 = kc_fe_selvar_1->ac_init_declarator_list_1;

			    }
			}

		    } else
		    {/* EMPTY */ /*skip: no matching pattern in foreach patterns*/}
		}

	    }
	    kc_fe_selvar_1 = kc_fe_selvar_1->ac_declaration_list_1;

	}
    }
    if (number_of_results == 1) {
	return result;
    } else {

	if (number_of_results > 1) {
	    v_report(Warning( FileLine( a_fnarg->file, a_fnarg->line ), Problem1S1ID( "more than one type defined for function argument:", a_fnarg )));
	} else { 
	    v_report(Warning( FileLine( a_fnarg->file, a_fnarg->line ), Problem1S1ID( "can not find type of function argument:", a_fnarg )));
	}

	return AcParDeclDecl(
	    Consac_declaration_specifiers(
		AcDeclSpecTypeSpec(
		    AcTypeSpec( Id( Str( mkcasestring( "KC_ERRORunknownTYPE" ))))),
		Nilac_declaration_specifiers()),
	    AcDeclarator(
		Nopointer(),
		AcNoRef(),
		AcDirectDeclId( a_fnarg )),
	    Noac_constant_expression());
    }

}

void unparse(const char *s, printer_functor printer_fn, uview v)
{
    printer_fn( s, v );

}

charruns impl_charruns::set(int _n)
{ number=_n; return this; 
}

ID f_mkselvar(const char *prefix, int level)
{



    char fixbuf[BUFSIZ] ;
    char *dynbuf = 0;
    char *buf = 0;
    ID id;
    if (strlen(prefix) + MKSELVARMAXINTREPR + 1 > BUFSIZ) {
	dynbuf = new char[strlen(prefix) + MKSELVARMAXINTREPR + 1];
	buf = dynbuf;
    } else {
	buf = fixbuf;
    }
    strcpy( buf, prefix );
    sprintf( &buf[strlen(prefix)], "%d", level );
    id = Id( Str( mkcasestring( buf )));
    if (dynbuf != 0) {
	delete[] dynbuf;
    }
    return id;

}

ID f_mkselvar2(const char *prefix, int level, int branch)
{




    char fixbuf[BUFSIZ] ;
    char *dynbuf = 0;
    char *buf = 0;
    ID id;
    int constant_factor = MKSELVARMAXINTREPR + 1 + MKSELVARMAXINTREPR + 1;
    if (strlen(prefix) + constant_factor > BUFSIZ) {
	dynbuf = new char[strlen(prefix) + constant_factor];
	buf = dynbuf;
    } else {
	buf = fixbuf;
    }
    strcpy( buf, prefix );
    sprintf( &buf[strlen(prefix)], "%d_%d", level, branch );
    id = Id( Str( mkcasestring( buf )));
    if (dynbuf != 0) {
	delete[] dynbuf;
    }
    return id;

}

char *f_mk_filename(casestring a_casestring, const char *suffix)
{
    char const *basename;

    if ((basename = strrchr( a_casestring->name, '/' )) == 0)
    basename = a_casestring->name;
    if (*basename == '/')
    basename++;
    else if (*basename == '"')
    basename++;
    size_t baselen = strlen(basename);

    char *filename = new char[baselen+strlen(suffix)+1];
    strcpy( filename, basename );
    if (baselen > 0 && filename[baselen-1] == '"' ) {
	filename[baselen-1] = '\0';
	baselen--;
    }
    if ( baselen > 1 && (filename[baselen-1] == 'k' && filename[baselen-2] == '.' ))
    baselen-=2;
    if (strlen(suffix)==0) {
	filename[baselen]='\0';
	return filename;
    }
    filename[baselen] = '.';

    char *eofn=filename+baselen+1;
    while ((*eofn++=*suffix++)) ;
    return filename;

}

char *f_mk_filename(casestring a_casestring, const string &suffix)
{
    return f_mk_filename(a_casestring, suffix.c_str());

}

char *f_make_identifier_basename(const char *fn)
{
    char *nn;

    size_t len = strlen(fn);
    assertCond(len >2);
    nn = new char[len-2+1]; 
    strncpy(nn, fn, len-2);
    nn[len-2] = '\0';
    for (unsigned i=0; i < len-2; i++) {
	if (! isalnum(nn[i])) {
	    nn[i] = '_';
	}   }
    return nn;

}

rewriterulesinfo f_rewriterulesinfoofalternativeinview(alternative a_alternative, ID a_view)
{
    global_filterview = a_view;
    return a_alternative->rewriteinfo->filter( filterrewriteruleinfoonview );

}

rewriteviewsinfo f_rewriteviewsinfo_of_alternative(alternative a_alternative, viewnames a_views)
{
    rewriterulesinfo tmp_rulesinfo = a_alternative->rewriteinfo;
    rewriteviewsinfo tmp_viewsinfo = Nilrewriteviewsinfo();
    {
	viewnames kc_fe_selvar_1 =  a_views ;

	while(
		kc_fe_selvar_1->prod_sel() == sel_Consviewnames
	    ) {
	    ID kc_selvar_0_1 = kc_fe_selvar_1->ID_1;
	    {
		{
		    {
			const ID a_view = kc_selvar_0_1;

			global_filterview = a_view;
			tmp_viewsinfo = Consrewriteviewsinfo( Rewriteviewinfo( a_view, tmp_rulesinfo->filter( filterrewriteruleinfoonview )), tmp_viewsinfo );

		    }
		}

	    }
	    kc_fe_selvar_1 = kc_fe_selvar_1->viewnames_1;

	}
    }
    return tmp_viewsinfo;

}

unparseviewsinfo f_unparseviewsinfo_of_alternative(alternative a_alternative, viewnames a_views)
{
    unparsedeclsinfo tmp_declsinfo = a_alternative->unparseinfo;
    unparseviewsinfo tmp_viewsinfo = Nilunparseviewsinfo();
    {
	viewnames kc_fe_selvar_1 =  a_views ;

	while(
		kc_fe_selvar_1->prod_sel() == sel_Consviewnames
	    ) {
	    ID kc_selvar_0_1 = kc_fe_selvar_1->ID_1;
	    {
		{
		    {
			const ID a_view = kc_selvar_0_1;

			global_filterview = a_view;
			tmp_viewsinfo = Consunparseviewsinfo( Unparseviewinfo( a_view, tmp_declsinfo->filter( filterunparsedeclinfoonview )), tmp_viewsinfo );

		    }
		}

	    }
	    kc_fe_selvar_1 = kc_fe_selvar_1->viewnames_1;

	}
    }
    return tmp_viewsinfo;

}

static  bool filterrewriteruleinfoonview(rewriteruleinfo a_rewriteruleinfo)
{
    return is_viewname_in_rewriteruleinfo( global_filterview, a_rewriteruleinfo );

}

static  bool filterunparsedeclinfoonview(unparsedeclinfo a_unparsedeclinfo)
{
    return is_viewname_in_unparsedeclinfo( global_filterview, a_unparsedeclinfo );

}

static  bool is_viewname_in_rewriteruleinfo(ID a_view, rewriteruleinfo a_rewriteruleinfo)
{
    {
	rewriteruleinfo kc_selvar_0_1 = phylum_cast<rewriteruleinfo>( a_rewriteruleinfo );
	if ((kc_selvar_0_1->prod_sel() == sel_Rewriteruleinfo) && (phylum_cast<const impl_rewriteruleinfo_Rewriteruleinfo*>(kc_selvar_0_1)->rewriteclause_1->prod_sel() == sel_RewriteClause)) {
	    const viewnames a_viewnames = phylum_cast<const impl_rewriteclause_RewriteClause*>(phylum_cast<const impl_rewriteruleinfo_Rewriteruleinfo*>(kc_selvar_0_1)->rewriteclause_1)->viewnames_1;

	    return is_viewname_in_viewnames( a_view, a_viewnames );

	} else
	{ kc_no_default_in_with( "is_viewname_in_rewriteruleinfo", __LINE__, __FILE__ );
	    return static_cast<bool>(0); }
    }

}

static  bool is_viewname_in_unparsedeclinfo(ID a_view, unparsedeclinfo a_unparsedeclinfo)
{
    {
	unparsedeclinfo kc_selvar_0_1 = phylum_cast<unparsedeclinfo>( a_unparsedeclinfo );
	if ((kc_selvar_0_1->prod_sel() == sel_Unparsedeclinfo) && (phylum_cast<const impl_unparsedeclinfo_Unparsedeclinfo*>(kc_selvar_0_1)->unparseclause_1->prod_sel() == sel_UnparseClause)) {
	    const viewnames a_viewnames = phylum_cast<const impl_unparseclause_UnparseClause*>(phylum_cast<const impl_unparsedeclinfo_Unparsedeclinfo*>(kc_selvar_0_1)->unparseclause_1)->viewnames_1;

	    return is_viewname_in_viewnames( a_view, a_viewnames );

	} else
	{ kc_no_default_in_with( "is_viewname_in_unparsedeclinfo", __LINE__, __FILE__ );
	    return static_cast<bool>(0); }
    }

}

static  bool is_viewname_in_viewnames(ID a_view, viewnames a_viewnames)
{
    {
	viewnames kc_fe_selvar_1 =  a_viewnames ;

	while(
		kc_fe_selvar_1->prod_sel() == sel_Consviewnames
	    ) {
	    ID kc_selvar_0_1 = kc_fe_selvar_1->ID_1;
	    {
		{
		    {
			const ID a_viewname = kc_selvar_0_1;

			if ( a_view->eq( a_viewname ) ) {
			    return true;
			}   
		    }
		}

	    }
	    kc_fe_selvar_1 = kc_fe_selvar_1->viewnames_1;

	}
    }
    return false;

}

ID f_typeof(path a_path)
{
    if (a_path->id->eq(f_emptyId())) {
	{
	    path kc_selvar_0_1 = phylum_cast<path>( a_path );
	    if ((kc_selvar_0_1->prod_sel() == sel_Conspath)) {
		const integer i = (kc_selvar_0_1)->integer_1;
		const path r_path = (kc_selvar_0_1)->path_1;

		return f_subphylumofoperator( r_path->op, Int( i ) );

	    } else
		if ((kc_selvar_0_1->prod_sel() == sel_Nilpath)) {

		return f_phylumofoperator( a_path->op );

	    } else
	    { kc_no_default_in_with( "f_typeof", __LINE__, __FILE__ );
		return static_cast<ID>(0); }
	}
    } else {
	return a_path->id;
    }

}

ID f_operatorofpatternrepresentation(patternrepresentation a_patternrepresentation)
{
    {
	patternrepresentation kc_selvar_0_1 = phylum_cast<patternrepresentation>( a_patternrepresentation );
	if ((kc_selvar_0_1->prod_sel() == sel_Conspatternrepresentation)) {
	    const elem_patternrepresentation e = (kc_selvar_0_1)->elem_patternrepresentation_1;

	    return f_operatorofelem_patternrepresentation( e );

	} else
	    if ((kc_selvar_0_1->prod_sel() == sel_Nilpatternrepresentation)) {

	    return f_emptyId();

	} else
	{ kc_no_default_in_with( "f_operatorofpatternrepresentation", __LINE__, __FILE__ );
	    return static_cast<ID>(0); }
    }

}

static  ID f_operatorofelem_patternrepresentation(elem_patternrepresentation a_elem_patternrepresentation)
{
    {
	elem_patternrepresentation kc_selvar_0_1 = phylum_cast<elem_patternrepresentation>( a_elem_patternrepresentation );
	if ((kc_selvar_0_1->prod_sel() == sel_PRDefault)) {
	    return f_emptyId(); 
	    	} else
	    if ((kc_selvar_0_1->prod_sel() == sel_PRUserPredicate)) {
	    return f_emptyId(); 
	    	} else
	    if ((kc_selvar_0_1->prod_sel() == sel_PRIntLiteral)) {
	    const path p = phylum_cast<const impl_elem_patternrepresentation_PRIntLiteral*>(kc_selvar_0_1)->path_1;
	    return f_operatorofpath( p ); 
	    	} else
	    if ((kc_selvar_0_1->prod_sel() == sel_PRStringLiteral)) {
	    const path p = phylum_cast<const impl_elem_patternrepresentation_PRStringLiteral*>(kc_selvar_0_1)->path_1;
	    return f_operatorofpath( p ); 
	    	} else
	    if ((kc_selvar_0_1->prod_sel() == sel_PRWildcard)) {
	    const path p = phylum_cast<const impl_elem_patternrepresentation_PRWildcard*>(kc_selvar_0_1)->path_1;
	    return f_operatorofpath( p ); 
	    	} else
	    if ((kc_selvar_0_1->prod_sel() == sel_PRNonLeafBinding)) {
	    const path p = phylum_cast<const impl_elem_patternrepresentation_PRNonLeafBinding*>(kc_selvar_0_1)->path_1;
	    return f_operatorofpath( p ); 
	    	} else
	    if ((kc_selvar_0_1->prod_sel() == sel_PROperPredicate)) {
	    const path p = phylum_cast<const impl_elem_patternrepresentation_PROperPredicate*>(kc_selvar_0_1)->path_1;
	    return f_operatorofpath( p ); 
	    	} else
	    if ((kc_selvar_0_1->prod_sel() == sel_PRBinding)) {
	    const path p = phylum_cast<const impl_elem_patternrepresentation_PRBinding*>(kc_selvar_0_1)->path_1;
	    return f_operatorofpath( p ); 
	    	} else
	    if ((kc_selvar_0_1->prod_sel() == sel_PRVarPredicate)) {
	    const paths ps = phylum_cast<const impl_elem_patternrepresentation_PRVarPredicate*>(kc_selvar_0_1)->paths_1;
	    return f_operatorofpaths( ps ); 
	    	} else
	{ kc_no_default_in_with( "f_operatorofelem_patternrepresentation", __LINE__, __FILE__ );
	    return static_cast<ID>(0); }
    }

}

static  ID f_operatorofpaths(paths a_paths)
{
    {
	paths kc_selvar_0_1 = phylum_cast<paths>( a_paths );
	if ((kc_selvar_0_1->prod_sel() == sel_Conspaths)) {
	    const path p = (kc_selvar_0_1)->path_1;

	    return f_operatorofpath( p );

	} else
	    if ((kc_selvar_0_1->prod_sel() == sel_Nilpaths)) {

	    return f_emptyId();

	} else
	{ kc_no_default_in_with( "f_operatorofpaths", __LINE__, __FILE__ );
	    return static_cast<ID>(0); }
    }

}

static  ID f_operatorofpath(path a_path)
{
    {
	path kc_selvar_0_1 = phylum_cast<path>( a_path );
	if ((kc_selvar_0_1->prod_sel() == sel_Conspath)) {
	    const path r_path = (kc_selvar_0_1)->path_1;

	    return r_path->op;

	} else
	    if ((kc_selvar_0_1->prod_sel() == sel_Nilpath)) {

	    return a_path->op;

	} else
	{ kc_no_default_in_with( "f_operatorofpath", __LINE__, __FILE__ );
	    return static_cast<ID>(0); }
    }

}

ID f_typeofunpsubterm(unpsubterm a_unpsubterm, ID a_operator)
{
    {
	unpsubterm kc_selvar_0_1 = phylum_cast<unpsubterm>( a_unpsubterm );
	if ((kc_selvar_0_1->prod_sel() == sel_UnpCastedVariable)) {
	    const ID a_cast = phylum_cast<const impl_unpsubterm_UnpCastedVariable*>(kc_selvar_0_1)->ID_1;
	    return a_cast; 
	    	} else
	    if ((kc_selvar_0_1->prod_sel() == sel_UnpDollarvarAttr)) {
	    const INT i = phylum_cast<const impl_unpsubterm_UnpDollarvarAttr*>(kc_selvar_0_1)->INT_1;
	    const unpattributes a_unpattributes = phylum_cast<const impl_unpsubterm_UnpDollarvarAttr*>(kc_selvar_0_1)->unpattributes_1;
	    return f_check_unpattributes_in_phylum( a_unpattributes, f_subphylumofoperator( a_operator, i ) ); 
	    	} else
	    if ((kc_selvar_0_1->prod_sel() == sel_UnpSubAttr)) {
	    const ID an_id = phylum_cast<const impl_unpsubterm_UnpSubAttr*>(kc_selvar_0_1)->ID_1;
	    const unpattributes an_unpattributes = phylum_cast<const impl_unpsubterm_UnpSubAttr*>(kc_selvar_0_1)->unpattributes_1;
	    return f_check_unpattributes_in_phylum( an_unpattributes, f_phylumofpatternID( an_id ) ); 
	    	} else
	    if ((kc_selvar_0_1->prod_sel() == sel_UnpDollarvarTerm)) {
	    const INT i = phylum_cast<const impl_unpsubterm_UnpDollarvarTerm*>(kc_selvar_0_1)->INT_1;
	    return f_subphylumofoperator( a_operator, i ); 
	    	} else
	    if ((kc_selvar_0_1->prod_sel() == sel_UnpSubTerm)) {
	    const ID a_id = phylum_cast<const impl_unpsubterm_UnpSubTerm*>(kc_selvar_0_1)->ID_1;
	    return f_phylumofpatternID( a_id ); 
	    	} else
	{ kc_no_default_in_with( "f_typeofunpsubterm", __LINE__, __FILE__ );
	    return static_cast<ID>(0); }
    }

}

elem_patternrepresentation f_outmost_nl_preds_in_rewriterulesinfo(rewriterulesinfo ri)
{
    {
	rewriterulesinfo kc_selvar_0_1 = phylum_cast<rewriterulesinfo>( ri );
	if ((kc_selvar_0_1->prod_sel() == sel_Consrewriterulesinfo) && ((kc_selvar_0_1)->rewriteruleinfo_1->prod_sel() == sel_Rewriteruleinfo)) {
	    const patternrepresentation preds = phylum_cast<const impl_rewriteruleinfo_Rewriteruleinfo*>((kc_selvar_0_1)->rewriteruleinfo_1)->patternrepresentation_1;
	    const rewriterulesinfo r_ri = (kc_selvar_0_1)->rewriterulesinfo_1;

	    elem_patternrepresentation epr =
	    f_outmost_nl_preds_in_patternrepresentation( preds );
	    return epr ? epr
	    : f_outmost_nl_preds_in_rewriterulesinfo( r_ri );

	} else
	    if ((kc_selvar_0_1->prod_sel() == sel_Nilrewriterulesinfo)) {
	    return 0; 
	    	} else
	{ kc_no_default_in_with( "f_outmost_nl_preds_in_rewriterulesinfo", __LINE__, __FILE__ );
	    return static_cast<elem_patternrepresentation>(0); }
    }

}

elem_patternrepresentation f_outmost_nl_preds_in_unparsedeclsinfo(unparsedeclsinfo ri)
{
    {
	unparsedeclsinfo kc_selvar_0_1 = phylum_cast<unparsedeclsinfo>( ri );
	if ((kc_selvar_0_1->prod_sel() == sel_Consunparsedeclsinfo) && ((kc_selvar_0_1)->unparsedeclinfo_1->prod_sel() == sel_Unparsedeclinfo)) {
	    const patternrepresentation preds = phylum_cast<const impl_unparsedeclinfo_Unparsedeclinfo*>((kc_selvar_0_1)->unparsedeclinfo_1)->patternrepresentation_1;
	    const unparsedeclsinfo r_ri = (kc_selvar_0_1)->unparsedeclsinfo_1;

	    elem_patternrepresentation epr =
	    f_outmost_nl_preds_in_patternrepresentation( preds );
	    return epr ? epr
	    : f_outmost_nl_preds_in_unparsedeclsinfo( r_ri );

	} else
	    if ((kc_selvar_0_1->prod_sel() == sel_Nilunparsedeclsinfo)) {
	    return 0; 
	    	} else
	{ kc_no_default_in_with( "f_outmost_nl_preds_in_unparsedeclsinfo", __LINE__, __FILE__ );
	    return static_cast<elem_patternrepresentation>(0); }
    }

}

static  elem_patternrepresentation f_outmost_nl_preds_in_patternrepresentation(patternrepresentation p)
{
    {
	patternrepresentation kc_selvar_0_1 = phylum_cast<patternrepresentation>( p );
	if ((kc_selvar_0_1->prod_sel() == sel_Conspatternrepresentation)) {
	    const elem_patternrepresentation a_p = (kc_selvar_0_1)->elem_patternrepresentation_1;
	    const patternrepresentation r_p = (kc_selvar_0_1)->patternrepresentation_1;

	    return f_outmost_nl_preds_in_elem_patternrepresentation( a_p ) ? a_p
	    : f_outmost_nl_preds_in_patternrepresentation( r_p );

	} else
	    if ((kc_selvar_0_1->prod_sel() == sel_Nilpatternrepresentation)) {
	    return 0; 
	    	} else
	{ kc_no_default_in_with( "f_outmost_nl_preds_in_patternrepresentation", __LINE__, __FILE__ );
	    return static_cast<elem_patternrepresentation>(0); }
    }

}

static  bool f_outmost_nl_preds_in_elem_patternrepresentation(elem_patternrepresentation e_p)
{
    {
	elem_patternrepresentation kc_selvar_0_1 = phylum_cast<elem_patternrepresentation>( e_p );
	if ((kc_selvar_0_1->prod_sel() == sel_PRVarPredicate)) {
	    const paths a_p = phylum_cast<const impl_elem_patternrepresentation_PRVarPredicate*>(kc_selvar_0_1)->paths_1;

	    return f_outmost_nl_preds_in_paths( a_p );

	} else
	{
	    return false; 
	}
    }

}

static  bool f_outmost_nl_preds_in_paths(paths p)
{
    {
	paths kc_selvar_0_1 = phylum_cast<paths>( p );
	if ((kc_selvar_0_1->prod_sel() == sel_Conspaths) && ((kc_selvar_0_1)->path_1->prod_sel() == sel_Conspath)) {
	    const paths r_p = (kc_selvar_0_1)->paths_1;

	    return f_outmost_nl_preds_in_paths( r_p );

	} else
	    if ((kc_selvar_0_1->prod_sel() == sel_Conspaths) && ((kc_selvar_0_1)->path_1->prod_sel() == sel_Nilpath)) {
	    return true; 
	    	} else
	    if ((kc_selvar_0_1->prod_sel() == sel_Nilpaths)) {
	    return false; 
	    	} else
	{ kc_no_default_in_with( "f_outmost_nl_preds_in_paths", __LINE__, __FILE__ );
	    return static_cast<bool>(0); }
    }

}

bool f_is_known_ptr_type(ID id)
{
    static phylumnames known = 0;

    if (! known ) {		
	known = Nilphylumnames();
	known = Consphylumnames( Id( Str( mkcasestring( "size_t" ))), known );
	known = Consphylumnames( Id( Str( mkcasestring( "unsigned" ))), known );
	known = Consphylumnames( Id( Str( mkcasestring( "enum_phyla" ))), known );
	known = Consphylumnames( Id( Str( mkcasestring( "enum_operators" ))), known );
	known = Consphylumnames( Id( Str( mkcasestring( "KC_UNIQ_INFO" ))), known );
	known = Consphylumnames( Id( Str( mkcasestring( "bool" ))), known );
	known = Consphylumnames( Id( Str( mkcasestring( "hashtable_t" ))), known );
	known = Consphylumnames( Id( Str( mkcasestring( "KC_IO_STATUS" ))), known );
	known = Consphylumnames( Id( Str( mkcasestring( "uview" ))), known );
	known = Consphylumnames( Id( Str( mkcasestring( "rview" ))), known );
    }
    {
	phylumnames kc_fe_selvar_1 =  known ;

	while(
		kc_fe_selvar_1->prod_sel() == sel_Consphylumnames
	    ) {
	    ID kc_selvar_0_1 = kc_fe_selvar_1->ID_1;
	    {
		{
		    {
			const ID pn = kc_selvar_0_1;

			if ( pn->eq( id )) {
			    return true;
			}	
		    }
		}

	    }
	    kc_fe_selvar_1 = kc_fe_selvar_1->phylumnames_1;

	}
    }
    return false;

}

withcasesinfo rewrite_withcasesinfo(withcasesinfo a_withcasesinfo)
{{
	withcasesinfo kc_selvar_0_1 = phylum_cast<withcasesinfo>(a_withcasesinfo);
	if ((kc_selvar_0_1->prod_sel() == sel_Conswithcasesinfo) && ((kc_selvar_0_1)->withcaseinfo_1->prod_sel() == sel_Withcaseinfo)) {
	    const patternrepresentation p = phylum_cast<const impl_withcaseinfo_Withcaseinfo*>((kc_selvar_0_1)->withcaseinfo_1)->patternrepresentation_1;
	    const patternrepresentation b = phylum_cast<const impl_withcaseinfo_Withcaseinfo*>((kc_selvar_0_1)->withcaseinfo_1)->patternrepresentation_2;
	    const Ctext ct = phylum_cast<const impl_withcaseinfo_Withcaseinfo*>((kc_selvar_0_1)->withcaseinfo_1)->Ctext_1;
	    const withcasesinfo r = (kc_selvar_0_1)->withcasesinfo_1;

	    return Conswithcasesinfo(
		Withcaseinfo( p->rewrite(base_rview), b, ct ),
		rewrite_withcasesinfo( r ) );

	} else
	    if ((kc_selvar_0_1->prod_sel() == sel_Nilwithcasesinfo)) {
	    return kc_selvar_0_1; 
	    	} else
	{ kc_no_default_in_with( "rewrite_withcasesinfo", __LINE__, __FILE__ );
	    return static_cast<withcasesinfo>(0); }
    }

}

int pos_of_sole_dollar_or_pattern_in_patternchain(patternchain a_patternchain)
{
    return t_pos_of_sole_dollar_or_pattern_in_patternchain(a_patternchain, -2, 1);

}

int t_pos_of_sole_dollar_or_pattern_in_patternchain(patternchain a_patternchain, int tmp_result, int pos)
{
    if (tmp_result == -1) { 
	return tmp_result;
    }
    {
	patternchain kc_selvar_0_1 = phylum_cast<patternchain>( a_patternchain );
	if ((kc_selvar_0_1->prod_sel() == sel_Conspatternchain)) {
	    const patternchainitem h = (kc_selvar_0_1)->patternchainitem_1;
	    const patternchain t = (kc_selvar_0_1)->patternchain_1;

	    tmp_result = t_pos_of_sole_dollar_or_pattern_in_patternchain( t, tmp_result, pos+1 );
	    if (tmp_result == -1) { 
		return tmp_result;
	    }
	    {
		patternchainitem kc_selvar_1_1 = phylum_cast<patternchainitem>( h );
		if ((kc_selvar_1_1->prod_sel() == sel_PatternchainitemDollarid)) {

		    return tmp_result >= 0 ?  -1  : pos;

		} else
		    if ((kc_selvar_1_1->prod_sel() == sel_PatternchainitemOutmost)) {
		    const outmostpattern p = phylum_cast<const impl_patternchainitem_PatternchainitemOutmost*>(kc_selvar_1_1)->outmostpattern_1;

		    {
			outmostpattern kc_selvar_2_1 = phylum_cast<outmostpattern>( p );
			if ((kc_selvar_2_1->prod_sel() == sel_OPOperatorWildcard) && (phylum_cast<const impl_outmostpattern_OPOperatorWildcard*>(kc_selvar_2_1)->ID_1->prod_sel() == sel_Id)) {
			    const uniqID uid = phylum_cast<const impl_ID_Id*>(phylum_cast<const impl_outmostpattern_OPOperatorWildcard*>(kc_selvar_2_1)->ID_1)->uniqID_1;

			    {
				IDtype kc_selvar_3_1 = phylum_cast<IDtype>( uid->type );
				if ((kc_selvar_3_1->prod_sel() == sel_ITUnknown)) {

				    return tmp_result;

				} else
				    if ((kc_selvar_3_1->prod_sel() == sel_ITPatternVariable)) {

				    return tmp_result;

				} else
				{

				    if (tmp_result >= 0) {
					return -1; 
				    } else {
					return pos;
				    }   
				}
			    }

			} else
			{

			    return tmp_result >= 0 ?  -1  : pos;

			}
		    }

		} else
		{

		    return -1; 

		}
	    }

	} else
	{

	    return tmp_result;

	}
    }

}

string f_getidentfromstring(const char **c)
{
    string s="";
    if (isalnum(**c) || **c=='_')
    while (isalnum(**c) || **c=='_') s+=*(*c)++;
    else
    while (!(isalnum(**c) || **c=='_' || **c=='\0')) s+=*(*c)++;
    return s;

}


} // namespace kc
