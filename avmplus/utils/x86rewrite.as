/* -*- mode: java; tab-width: 4 -*- */
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

// Rewrites Interpreter.asm (generated by MSVC) to convert it from switch 
// dispatch to direct threaded dispatch.  See comments in core/Interpreter.cpp 
// for a discussion of why this program exists at all.
//
// Follow these 11 easy steps:
//
//  - Select the Release configuration in MSVC
//
//  - Check that FastInterpreter.asm is excluded from the build
//    of the avmplus component
//
//  - Check that Interpreter.cpp is included in the build
//
//  - Check that assembly listing generation is turned on for avmplus
//    (Configuration > C/C++ > Output files > Assembler output),
//    you must select "Assembly with Source Code" (/FAs).
//
//  - Build.  You will have lots of linking errors and no .exe.
//
//  - Now open platform/win32/obj_8/avmplus/Release/Interpreter.asm
//    in an editor and search for "NEXT;".  It will be found
//    in some comment (it's source code).  Above the comment
//    there is some code that looks mostly like this:
//
//          mov	eax, DWORD PTR [edi]
//          add	edi, 4
//	    cmp	eax, 511				; 000001ffH
//	    mov	DWORD PTR _pc$[ebp], edi
//	    ja	$LN497@interp
//
//    Immediately /prior/ to that code is a label.  Record it.
//
//  - Invoke x86rewrite with three arguments: the label you recorded 
//    in the previous step, the path to the above mentioned Interpreter.asm,
//    and the path to the file core/FastInterpreter.asm.  This program 
//    reads the former and generates a new version of the latter.
//
//  - Invoke "Build > Clean"
//
//  - Include FastInterpreter.asm in the build
//
//  - Exclude Interpreter.cpp from the build
//
//  - Build again, it should compile and link.
//
// Caveats:
//
//  - Only tested on VS2005 sp 1 "Release" mode output so far.
//    Obviously you're at the mercy of the optimizer and register 
//    allocator, and there is little guarantee that this program will
//    in fact remain fully applicable to the output of the compiler.
//    In fact, there are several hacks in this code to work around
//    arbitrary problems, usually noted in the comments.
//
//  - Sometimes MSVC does not place a label correctly in the compiler
//    output; I've experienced this with L_ext_push_doublebits.  The
//    reason is that the labels are not referenced from the compiled
//    code.  So there is a 'default' case far down in the interpreter
//    code that inserts artificial conditional jumps to labels found to
//    have this problem.  Add more as needed.

package x86rewrite 
{
    import avmplus.*;

    function assert(cond) {
        if (!cond)
            throw new Error("Assertion failed");
    }

    // Remove inline functions that are duplicated in the ASM output.
    // These are always PUBLIC followed by _TEXT SEGMENT .. _TEXT ENDS.  
    // We don't need them because they have been inlined into
    // the functions we do want to keep.  Instead of guessing what to
    // remove, we have a list of functions to keep.
    //
    // (Note we have to deal with multiple PUBLIC directives, only some
    // of which have trailing text segments.)
    //
    // We need to keep the EXTRN definitions that are inside the
    // inline functions, though, as those symbols are referenced from
    // the inlined versions too.
    //
    // The inclusion of branchCheck in the followin list is a hack
    // required to get linking to work.  Probably brittle.
    //
    // The hacking up of EXTRN definitions for integer_i and integer_u
    // are hacks required to get linking to work.  Probably brittle.

    function cleanup(lines) {
        var special = [/[^a-zA-Z0-9]getTraits[^a-zA-Z0-9]/, 
                       /[^a-zA-Z0-9]initMultiname[^a-zA-Z0-9]/, 
                       /[^a-zA-Z0-9]interpN[^a-zA-Z0-9]/, 
                       /[^a-zA-Z0-9]interp32[^a-zA-Z0-9]/,
                       /[^a-zA-Z0-9]interp[^a-zA-Z0-9]/,
                       /[^a-zA-Z0-9]branchCheck[^a-zA-Z0-9]/];

        var i = 0;
        var new_lines = [];
        var flag = false;
    outer:
        while (i < lines.length) {
            if (/^PUBLIC\t/.test(lines[i])) {
                var probe = /^PUBLIC\s+(\?integer_(?:i|u)@[^\s]+)/.exec(lines[i]);
                if (probe != null)
                    new_lines.push("EXTRN\t" + probe[1] + ":PROC");
                var keep = false;
                for ( var j=0 ; j < special.length ; j++ ) {
                    if (special[j].test(lines[i])) {
                        keep = true;
                        break;
                    }
                }
                if (!keep && /^PUBLIC\t/.test(lines[i+1])) {
                    i++;
                    continue;
                }
                for (;;) {
                    if (i == lines.length)
                        break;
                    var is_extern = /^EXTRN\s/.test(lines[i]);
                    var is_ends = /^_TEXT\tENDS/.test(lines[i]);
                    if (keep || is_extern)
                        new_lines.push(lines[i]);
                    i++;
                    if (is_ends)
                        break;
                }
            }
            else {
                new_lines.push(lines[i]);
                i++;
            }
        }
        return new_lines;
    }


    // Construct the jump table by rewriting the code.

    function jumptable(lines) {

        // find and remove call lines, save label offsets in jump table
        // find and remove the line that defines the jump table, store in 'definer'

        var labelcall = /^\s+call\s+\?LLLLABEL_0x([0-9A-Za-z]+)_L_([a-zA-Z0-9_]+)@/;
        var calls = {};
        var definer = null;
        var tablesize = 0;
        var new_lines = [];
        for ( var i=0 ; i < lines.length ; i++ ) {
            var probe = labelcall.exec(lines[i]);
            if (probe != null) 
                if (probe[2] != "illegal_op")
                    calls["L_" + probe[2]] = { offset: parseInt(probe[1], 16) };
            var probe2 = /^(\?opcode_labels@.+)\s+DD\s+([0-9A-Fa-f]+H)\s+DUP/.exec(lines[i]);
            if (probe2 != null) {
                definer = probe2[1];
                tablesize = parseInt(probe2[2], 16);
            }
            var probe3 = /^EXTRN\s+\?LLLLABEL_/.test(lines[i]);
            if (!(probe || probe2 || probe3))
                new_lines.push(lines[i]);
        }
        assert(definer != null);

        // search for the label definitions, store label names with the table offsets

        var labelsearch = "";
        for ( var idx in calls ) {
            if (labelsearch != "")
                labelsearch += "|";
            labelsearch += idx;
        }
        labelsearch = new RegExp("^(\\$(L_illegal_op|" + labelsearch + ")\\$\\d+):");

        var illegal_label = null;
        for ( var i=0 ; i < new_lines.length ; i++ ) {
            var probe = labelsearch.exec(new_lines[i]);
            if (probe != null) {
                if (probe[2] == "L_illegal_op")
                    illegal_label = probe[1];
                else
                    calls[probe[2]].label = probe[1];
            }
        }
        assert(illegal_label != null);

        // construct and emit a definition of the jump table, attach it to the end
        // of the segment for 'interp' (labels appear to be scoped in masm)

        var acalls = [];
        var dds = [];
        for ( var idx in calls )
            acalls[calls[idx].offset] = calls[idx].label;
        for ( var i=0 ; i < tablesize ; i++ ) {
            if (!(i in acalls))
                dds.push("DD\t" + illegal_label);
            else
                dds.push("DD\t" + acalls[i]);
        }

        lines = new_lines;
        new_lines = [];
        var flag = false;
        for ( var i=0 ; i < lines.length ; i++ ) {
            if (/^PUBLIC\s\?interp@/.test(lines[i]))
                flag = true;
            if (flag && /^.+\s+ENDP/.test(lines[i])) {
                new_lines.push(definer + ":");
                for ( var j=0 ; j < dds.length ; j++ )
                    new_lines.push(dds[j]);
                flag = false;
            }
            new_lines.push(lines[i]);
        }

        return new_lines;
    }

    // The NEXT sequence.  MSVC keeps SP in memory, and PC is in EDI on entry
    // to an instruction but must be saved to memory by the time we leave - 
    // some instructions will use EDI for other purposes on entry without saving
    // it first, then will reload PC into EDI as needed.  But sometimes that 
    // leaves something in EDI that is not the PC when we come to the dispatch.

    function mkDispatch(scratchreg, pcreg) {
        return ["\tmov\t" + scratchreg + ", DWORD PTR [" + pcreg + "]",
                "\tadd\t" + pcreg + ", 4",
                "\tmov\tDWORD PTR _pc$[ebp], " + pcreg,
                "\tjmp\t" + scratchreg];
    }

    // Find the jump instructions to replace by NEXT sequences.  This
    // includes the initial dispatch, at the top-of-loop label itself.

    function patchupNext(lines, label, next) {
        var new_lines = [];
        var lblmatch = new RegExp("^\\" + label + ":");
        var jmpmatch = new RegExp("^\\s+jmp\\s+(?:SHORT\\s+)?\\" + label);
        for ( var i=0 ; i < lines.length ; i++ ) {
            if (jmpmatch.test(lines[i])) {
                add();
                new_lines.push("; " + lines[i]);
            }
            else if (lblmatch.test(lines[i])) {
                new_lines.push(lines[i]);
                add();
            }
            else
                new_lines.push(lines[i]);
        }
        return new_lines;

        function add() {
            for ( var j=0 ; j < next.length ; j++ )
                new_lines.push(next[j]);
        }
    }

    // Main

    if (System.argv.length != 3) {
        print("Usage: x86rewrite label inputfile outputfile");
        print("  label should be the full label at the switch, eg '$LL417@interp'");
        System.exit(1);
    }
    
    File.write(System.argv[2], 
               patchupNext(jumptable(cleanup(File.read(System.argv[1]).split("\n"))),
                           System.argv[0],
                           mkDispatch("eax","edi")).join("\n"));
}
